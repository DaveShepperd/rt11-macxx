	.TITLE	RTEXEK	Operating system hooks
	.SBTTL **********
	.SBTTL * RTEXEC *
	.SBTTL **********
	.ENABL LC

	.IIF NDF,VAX$,VAX$ = 0
.IF NE,VAX$
VAX.GR = 23		;GET RECORD
VAX.PR = 24		;PUT RECORD
VAX.RR = 25		;REWIND RECORD
VAX.IT = 34		;INIT STATISTICS
VAX.GT = 35		;GET STATISTICS
VAX.XL = 40		;TRANSLATE LOGICAL
.ENDC

	.GLOBL	START,CONT,FIN,ENDLIN,ERRBTS

MCEXEC=0

	.MCALL	.SETTOP,.WAIT,.CLOSE,.SRESET,.LOOKUP,.CSIGEN
	.MCALL	.PRINT,.DATE,.LOCK,.UNLOCK,.RCTRLO,.CSISPC,.ENTER
	.MCALL	.TTYOUT,.TTYIN,.FETCH,.GTIM,.EXIT
	.MCALL  .DSTAT,.SAVES,.REOPEN,.READW,.WRITW,.CHAIN

	USRLOC=46
	HIGHAD=50
	EMTERR=52
	ERRCOM=53
	MONLOW=54
	CONFIG=300
	MONCOM=356
	JSW=44
	SPAREA=500
	TTYBUF=SPAREA+<39.*2>+<5*8.>

	PARAM	STKFDG,60.	;STACK OVERFLOW FUDGE FACTOR

	ENTSEC	IMPUR$
IMPUR$:

	.MACRO	XITSEC		;OVER-RIDE FOR EXEC
	.CSECT	MAIN$
	.ENDM	XITSEC
	XITSEC

	.IF NDF	BRERR		;BRIEF ERRORS?
	.MACRO	SERROR	NUMBER,MESSAGE,LETTER,TERM
	.SAVE
	.PSECT	MSGS
...1	=.
	.MACQQ		; ?MACxxx program name goes here
...LET	='F
	.IIF NB,<LETTER>,...LET=''LETTER
	.BYTE	'-,...LET,'-
	.ASCII	\'MESSAGE'\
	.IF NB,<TERM>
	.BYTE TERM
	.IFF
	.BYTE 128.
	.ENDC
	.RESTORE
	.PRINT	#...1
	.ENDM	SERROR
	.IFF
	.MACRO	SERROR	NUMBER,MESSAGE
	JSR	R0,SERROR
	.ASCIZ	/?'NUMBER'?/
	.EVEN
	.ENDM	SERROR
	.ENDC

	.MACRO	.FIND	CHAN,FILE
	MOV	FILE,-(SP)
	MOV	CHAN,-(SP)
	JSR	PC,FIND
	.ENDM	.FIND

..T	=1		;JUST FOR BIT SHIFTING
	.IRPC	CHAR,< ABDEILMNOPQRTUZ>
ERR.'CHAR	=..T
..T	=..T+..T
	.ENDR

	.MACRO	ERROR	ARG
	BIS	#ERR.'ARG,ERRBTS
	.ENDM

	.MACRO BITDEF BIT,LABL
...R	=10
	.RADIX 10
...B	=1
	.REPT	BIT
...B	=...B+...B
	.ENDR
LABL	=...B
	.RADIX	...R
	.ENDM

;   BITS IN THE JSW

	BITDEF	15,$USR		;SWAP USR ALWAYS
	BITDEF	14,$LC		;LOWER CASE ENABLE
	BITDEF	13,RENTER	;PGM RE-ENTERABLE
	BITDEF	12,$TTSPC	;TTY SPECIAL
	BITDEF	9,$OVLY		;PGM IS OVERLAYED
	BITDEF	8,$CHAIN	;PGM HAS BEEN CHAINED TO
	BITDEF	7,$HIO		;HALT ON I/O ERRORS
	BITDEF	6,$TTWT		;NO WAIT ON TTY

;   BITS IN THE CONFIG WORD

	BITDEF	15,$KW11	;KW11 INSTALLED AND RUNNING
	BITDEF	11,$1103	;PROCESSOR IS AN 11/03
	BITDEF	9,$USRP		;USR HAS BEEN SET NOSWAP
	BITDEF	8,$GT40C	;A GT40 IS THE SYSTEM CONSOLE
	BITDEF	7,$FGACT	;FOREGROUND IS ACTIVE
	BITDEF	6,$1145		;PROCESSOR HAS FLOATING POINT
	BITDEF	5,$CLK50	;LINE CLOCK IS 50 CYCLES
	BITDEF	3,$BTCH		;BATCH HAS BACKGROUND
	BITDEF	2,$GT40		;SYSTEM HAS A GT40 ON-LINE
	BITDEF	0,$FB		;O.S. IS RT-11FB

MONVER	=276			;SYSTEM RELEASE LEVEL (BYTE)

	.IF DF,NEWEXT
EXTNSN	=SMDEXT		;use system macro extension (whatever it is)
	.IFF
EXTNSN	=^RMAC		;ALWAYS .MAC  UNTIL FURTHER NOTICE
	.ENDC

	.SBTTL	PROGRAM START

	BR	ERRB		;REENTRY POINT
START:
	.IF DF	TRAPS
	MOV	#TRPPRO,@#34	;SET UP TRAP VECTOR
	CLR	@#36
	.ENDC

; SET UP USR TO LOAD OVER PURE CODE >>>>>>>>>>>>>>>>>>>>>>>>>>>
	MOV	#ASSEM,@#USRLOC

	BIS	#RENTER,@#JSW	;MARK JOB REENTERABLE
	.SETTOP	#-2		;EXCISE THE USR
	MOV	R0,STKSAV	;INITIALIZATION FOR STACK
	MOV	PRGLIM+2,R1	;INITIALISE THE STACK LIMIT
	ADD	#STKFDG,R1
	MOV	R1,STKLIM
	.IF DF	FIXSTK
	MOV	#SYMBUE,SYTTOP
	.ENDC
CONT:
	MOV	#IMPUR$,R1	;CLEAR IMPURE AREA
1$:	CLR	(R1)+
	CMP	R1,#IMPURT
	BLO	1$
	CALL	ASSEM		;INITIALIZE SYMBOL ROLLS
	MOV	STKSAV,SP	;INIT THE STACK
	MOV	#CTLTBL,R0
2$:	MOV	(R0)+,R1	;GET ADDR OF NEXT ROUTINE TO EXEC
	MOV	R0,-(SP)	;SAVE POINTER
	CALL	(R1)		;EXEC NEXT ROUTINE
	MOV	(SP)+,R0	;RETRIEVE POINTER
	BR	2$

	ENTSEC	DPURE$
CTLTBL:				;TABLE TO EXEC ASSEMBLER
	.WORD	INIOF,	MACP0
	.WORD	INIP1,	MACP1
	.WORD	FINP1,	ENDP1
	.WORD	INIP2,	MACP2
	.WORD	FINP2,	ENDP2
	.WORD	SETDN		;GO TO RESTART POINT
	XITSEC

ERRB:	JMP	ERR

	.SBTTL	GET COMMAND STRING

	.MCALL	.SERR,.HERR,.TRPSET

	.ENABL LSB
INIOF:
.IF NE,VAX$			;IF WE'RE ON THE VAX
	MOV #SCHTBL,R2		;POINT TO DEST
	MOV #SCHSIZ,R1		;GET LENGTH OF ARRAY
	MOV #SCHNAM,R0		;POINT TO NAME (.ASCIC STRING IN VAX TERMS)
	VAX.XL			;GET THE SEARCH STRING
.ENDC
	DEC	FRECOR		;INITIALIZE FREE CORE COUNT
	MOV	#TTYBUF,R2	;POINT TO INPUT LINE BUFFER
	MOV	#SPAREA,R1	;POINT TO FREE SPACE
	.CSISPC	R1,#DEFEXT,#0,R2
	TST	30.(R1)		;ANY INPUT SPEC'D?
	BNE	1$		;YEP
	.SAVE
	.PSECT	MSGS
...1	=.
	.MACII
	.ASCII \ V\
v$num::	GTVNUM
	.RESTORE
	.PRINT	#...1
	MOV	R1,R0
	CLR	(R0)
	JMP	SERROR

1$:
.IF EQ,VAX$
	.GTIM	#IOTWRD		;GET START TIME FOR I/O
	.GTIM	#CPUWRD		;GET START TIME FOR CPU
.IFF
	VAX.IT			;INIT THE TIMERS
.ENDC
7$:	TSTB	(R2)+		;SKIP TO END
	BNE	7$
	TSTB	-(R2)		;BACK UP 1
	MOVB	#CR,(R2)+	;FIX END OF TTYBUF AGAIN
	MOVB	#LF,(R2)+
	CLRB	(R2)+
	MOV	(SP)+,R0	;GET # OF SWITCHES
	.IF NDF	XSWIT
	BEQ	ENDSWT		;NO SWITCHES - JUMP
	MOV	#-1,EXMFLG	;INDICATE SWITCH PROCESSING
SWNEXT:	MOV	(SP)+,R1	;GET NEXT SWITCH
	MOV	#SWTBL,R2	;ADDR OF SWITCH TABLE
10$:	CMPB	(R2)+,R1	;IS THIS THE ONE?
	BEQ	12$		;YUP - GO CALL ROUTINE
	INC	R2		;ELSE POINT TO NEXT TABLE ENTRY
	CMP	#SWTEND,R2	;TABLE EXHAUSTED?
	BNE	10$		;NO - GO BACK
	JMP	SWTERR		;ELSE ERROR - BAD SWITCH
12$:	MOVB	@R2,R2		;GET ROUTINE INDEX
	TST	R1		;WAS VALUE SUPPLIED?
	BMI	13$		;YES - SKIP NEXT
	CLR	-(SP)		;ELSE SUPPLY DEFAULT
13$:	CLR	R3		;CLEAN REGS 3 & 5
	CLR	R5
	JMP	SWTDON+128.(R2)	;BRANCH TO APPROPRIATE ROUTINE
SWTDON:	DEC	R0		;# OF SWITCHES - 1
	BNE	SWNEXT		;GO BACK IF ANY LEFT
	.IFF
	BNE	SWTERR		;NO SWITCHES ARE LEGAL
	.ENDC			;NDF XSWIT
	JMP	ENDSWT		;GO DO I/O STUFF

	.DSABL LSB

	.SBTTL	SWITCH HANDLERS
	.GLOBL	SWT.S

SWTERR:	SERROR	BSW,<Bad switch  />
	MOV	#SPAREA+1,R0
	CLRB	(R0)
	MOVB	R1,-(R0)
	JMP	SERROR

	.IF NDF XSWIT

;	LIST/NOLIST SWITCH ROUTINES

SWRN:	COM	R3		;R3 = -1 FOR NLIST
SWRL:	ASL	R3		;R3 = 1  FOR LIST
	INC	R3
	MOV	(SP)+,SYMBOL	;INSTALL SWITCH VALUE IN SYMBOL
	CLR	SYMBOL+2
	MOV	#1,ARGCNT
	MOV	R1,-(SP)	;SAVE SWITCH CHAR
	MOV	R0,-(SP)	;SAVE # OF SWITCHES LEFT
	CALL	$NLIST		;LET .LIST/.NLIST HANDLER DO THE WORK
	BR	SWTCOM

;	ENABL/DSABL SWITCH ROUTINES

SWRD:	COM	R3		;R3 = -1 FOR DSABL
SWRE:	MOV	(SP)+,SYMBOL	;R3 = 0  FOR ENABL
	CLR	SYMBOL+2
	MOV	R1,-(SP)	;SAVE SWITCH CHAR
	MOV	R0,-(SP)	;SAVE # OF SWITCHES REMAINING
	CALL	$EDABL		;CALL .ENABL/.DSABL PROCESSOR
SWTCOM:	MOV	(SP)+,R0	;RESTORE # OF SWITCHES
	MOV	(SP)+,R1	;RESTORE SWITCH CHAR
	TST	ERRBTS		;ERROR IN VALUE?
	BNE	SWTERR		;YES
JSWTDN:	JMP	SWTDON		;ELSE WE'RE DONE
	.PAGE
	.IF NDF	XCREF
;	CREF SWITCH ROUTINE

SWRC:	MOV	#CRFTAB,R2	;GET ADRS OF VALUE TABLE
1$:	CMP	@SP,(R2)+	;IS THIS THE ONE?
	BEQ	2$		;YES
	TST	(R2)+		;ELSE SKIP FLAG BITS
	TST	@R2		;END OF TABLE?
	BNE	1$		;NOPE
	MOV	#'C,R1		;BAD /C
	BR	SWTERR		;ELSE ERROR
2$:	BIS	@R2,CRFFLG	;REMEMBER SECTIONS REQUESTED
PSWV:	TST	(SP)+		;DISCARD SWITCH VALUE
	JMP	SWTDON		;AND LEAVE

	ENTSEC	IMPUR$
CRFFLG:	.WORD	0
CRFTST:	.WORD	0
CRFCNT:	.WORD	0		;# OF REFERENCES MADE IN PASS 1
SWT.S:	.WORD	0
	XITSEC
	.ENDC		;XCREF

SWRS:	MOV	SP,SWT.S	;SUPPRESS DISK SEARCH
	BR	PSWV

SWRX:	CLR	R0
	.EXIT			;BACK TO RT-11

	.SBTTL	/A HANDLER
SWRA:	MOV	#SPAREA,R1	;WORK SPACE
	MOV	SP,SLASHA	;INDICATE /A ENTERED
	TST	(R1)+		;BIN OUTPUT SPECIFIED?
	BNE	1$		;YEP. LEAVE IT ALONE
	MOV	30.(R1),(R1)+	;COPY INPUT FILE NAME TO OBJ SPEC
	MOV	30.(R1),(R1)+
	MOV	DEFEXT+2,(R1)+	;BUT USE DEFAULT EXTENSION
	CLR	(R1)		;USE 1/2 LARGEST SPACE
1$:	MOV	#SPAREA+10.,R1
.IF EQ,VAX$
	TST	(R1)		;LST OUTPUT SPECIFIED?
.IFF
	TST	(R1)+		;.LST SPEC'D?
.IFTF
	BNE	PSWV		;YEP. LEAVE IT ALONE
.IFT
	MOV	#^RDK1,(R1)+	;LST GOES TO DK1
.IFTF
	MOV	-10.(R1),(R1)+
	MOV	-10.(R1),(R1)+
	MOV	DEFEXT+4,(R1)+	;BUT USE THE DEFAULT EXTENSION
.IFT
	MOV	#-1,(R1)	;SIZE LARGEST EMPTY SPACE
.IFF
	CLR	(R1)		;0 ALLOCATION ON VX:
.ENDC
	BR	PSWV
	.ENDC		;XSWIT

	ENTSEC IMPUR$
SLASHA:	.WORD 0			;/A ENTERED
DTYPE:	.BLKB 12.
	XITSEC
	.PAGE
	.SBTTL	INIT I/O FILES
ENDSWT:	.LOCK			;GET USR
	TST	CRFFLG		;CREF REQUESTED?
	BEQ	15$		;NOPE
	MOV	#SPAREA+20.,R2	;POINT TO CREF SPACE
	MOV	#CRFSPC,R1	;POINT TO DUMMY NAME
	CMP	(R1),SPAREA+10.	;CREF AND .LST THE SAME DEVICE?
	BNE	17$		;NOPE
	CMP	#-1,SPAREA+18.	;.LST[-1]?
	BNE	17$		;NOPE
	CLR	SPAREA+18.	;GIVE 1/2 TO LIST FILE
17$:	XMIT	4		;MOVE 4 WORDS
	MOV	#-1,(R2)	;GIVE LARGEST SPACE TO CREF

15$:	MOV	#3,R5		;START AT CHAN 3
	MOV	#SPAREA+30.,R3	;NOW WE OPEN INPUTS

11$:	.FIND	R5,R3		;LOOK FOR FILE
	BCC	9$		;IT WORKED

10$:	.PRINT	#FILNF		;FNF
	MOV	#SPAREA,R2	;POINT TO SOME FREE SPACE
	MOV	2(R3),SYMBOL	;COPY IN FILE NAME
	MOV	4(R3),SYMBOL+2
	CALL	R50UNP		;UNPACK FILE NAME
	CLRB	(R2)		;MARK THE END
	.UNLOCK			;KICK OUT USR
	MOV	#SPAREA,R0	;POINT TO BEGINING
	JMP	SERROR

9$:	ADD	#8.,R3		;TO NEXT INPUT
	TST	(R3)		;FILE PRESENT?
	BEQ	4$		;NOPE. WE'RE DONE
	INC	R5		;NEXT CHANNEL
	CMP	R5,#9.		;END?
	BLO	11$		;NOPE

4$:	CLR	R5		;START AT CHAN 0
	MOV	#SPAREA,R2
18$:	TST	(R2)		;ANY BIN OR LST?
	BNE	8$		;YEP
	TST	SLASHA		;/A ENTERED?
	BEQ	8$		;NO
	MOV	SPAREA+30.,(R2)	;YES. COPY INPUT DEVICE NAME TO BIN
8$:	TST	(R2)		;FILE PRESENT?
	BEQ	6$		;NOPE
	CALL	LHAND		;LOAD HANDLER
	BCS	7$		;ILLEGAL DEVICE
	.ENTER	#WA,R5,R2,8.(R2)	;OPEN FILE FOR OUTPUT
	BCC	6$		;IT WORKED!
	.PAGE
7$:	.UNLOCK			;DONE WITH USR
	MOV	CSIERR+6,R0	;DEV FULL
	JMP	SERROR

6$:	ADD	#10.,R2		;NEXT DVCBLK
	INC	R5		;NEXT CHAN
	CMP	R5,#2		;CREF CHAN?
	BNE	14$		;NO. PROCEED
	TST	CRFFLG		;CREF REQUESTED?
	BEQ	IIOEND		;NOPE. SKIP THE OPEN
14$:	CMP	R5,#3		;DONE?
.IF EQ,VAX$	
	BLO	8$		;NO.
.IFF
	BLO	18$		;NO
.ENDC
	.PAGE
IIOEND:	MOV	STKLIM,R1	;POINT TO FREE SPACE
	SUB	#STKFDG,R1	;BACKUP FUDGE AMOUNT
	.UNLOCK			;DONE WITH THE USR
	.WAIT	#0		;CHECK BINARY OUTPUT CHAN
	BCS	1$		;NOT THERE
	BIS	#IO.NNU,IOFTBL+BINCHN
	MOV	R1,PTRTBL+<BINCHN*4>
	MOV	R1,PTRTBL+<RELCHN*4>
	ADD	#512.,R1	;POINT TO END OF BUFFER
	MOV	R1,BLKTBL+<BINCHN*4>	;SAVE BUF ADDR
	MOV	R1,BLKTBL+<RELCHN*4>
1$:	.WAIT	#1		;LISTING OUTPUT?
	BCS	3$		;NO
	BIS	#IO.NNU,IOFTBL+LSTCHN
	MOV	R1,PTRTBL+<LSTCHN*4>
	ADD	#512.,R1	;POINT TO END OF BUFFER
	MOV	R1,BLKTBL+<LSTCHN*4>
3$:
	.IF NDF	XCREF
	TST	CRFFLG		;CREF REQUESTED?
	BEQ	2$		;NOPE
	BIS	#IO.NNU,IOFTBL+CRFCHN ;INDICATE CREF FILE PRESENT
	MOV	R1,PTRTBL+<CRFCHN*4>
	ADD	#512.,R1	;ALLOCATE CREF BUFFER
	MOV	R1,BLKTBL+<CRFCHN*4>
	.ENDC
2$:	ADD	#512.,R1	;ALLOCATE SOURCE FILE BUFFER
	MOV	R1,BLKTBL+<SRCCHN*4>
	ADD	#STKFDG,R1	;ALLOW SOME BREATHING ROOM
	MOV	R1,STKLIM	;AND SET STACK LIMIT
	JMP	DATE		;END OF SWITCHES - JUMP AROUND HANDLRS
	.PAGE
FIND:	MOV	R1,-(SP)	;SAVE SOME REGS
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	#SCHTBL,R3	;POINT TO NEW DVC'S
	.LOCK
	.SERR			;SOFT LANDINGS
	MOV	10.(SP),R2	;GET FILE SPEC ADDRESS

3$:	CALL	LHAND		;LOAD HANDLER
	BCS	2$		;ERROR
	MOV	8.(SP),R1	;GET CHANNEL
	.CLOSE	R1		;CLAIM CHANNEL
.IF NE,VAX$
	CLRB	DTYPE-3(R1)	;ASSUME NORMAL I/O
	COMB	WA		;TRUE?
	BNE	6$		;NOPE
	DECB	DTYPE-3(R1)	;YEP, SIGNAL VAX MODE
.ENDC
6$:	.LOOKUP	#WA,R1,R2	;OPEN FILE FOR INPUT
	BCC	2$		;ITS GOOD
	CMP	R3,#SCHTBL	;HAVE WE SEARCHED SOME?
	BNE	4$		;YEP. CONTINUE
	CMP	(R2),#^RDK 	;DEFAULT DVC:?
	BNE	5$		;NOPE
4$:	MOV	(R3)+,(R2)	;PUT IN A NEW DEVICE
	BNE	3$		;TRY AGAIN
5$:	SEC
2$:	ROR	-(SP)
	.HERR			;RESTORE HARD ERROR
	.UNLOCK
	ROL	(SP)+		;RESTORE CARRY
	MOV	(SP)+,R3	;RESTORE REGS
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0	;RETURN ADDRESS
	BIT	(SP)+,(SP)+	;ZAP ARGS
	JMP	(R0)		;RETURN

FNDX:	.WORD	10.,SPAREA+30.
	.WORD	8.,SPAREA+78.
	.WORD	0

SCHTBL:
.IF EQ,VAX$
	.RAD50	/DK1/	;SEARCH THESE DRIVES FOR A FILE
	.RAD50	/DY1/
	.RAD50	/DY0/
.IFF
	.BLKW	24.	;GET THE SEARCH LIST FROM THE VAX
SCHSIZ = .-SCHTBL	;COMPUTE THE SIZE OF THE ARRAY
.IFTF
	.WORD	0	;TERMINATOR
.IFF

SCHNAM:	.BLKB	;NAME TO USE TO DO XLATE LOGICAL
	.MACII		;MACxx name goes here
	.ASCII	\$SEARCH\	;Builds as MACxx$SEARCH
...1 = .
	.SAVE
	.=SCHNAM	;BACKUP
	.BYTE ...1 - <.+1>
	.RESTORE
	.EVEN		;FIXUP
.ENDC

LHAND:	.DSTAT	#WA,R2		;FIND STATS ON DVC:
	BCS	1$		;ILLEGAL
	TST	WA+4		;ALREADY LOADED?
	BNE	1$		;YEP. PROCEED (C=0)
	MOV	STKLIM,R1	;GET BOTTOM
	ADD	WA+2,R1		;COMPUTE NEW BOTTOM
	CMP	SP,R1		;ROOM FOR HANDLER?
	BHIS	2$		;OK
	JMP	CORERR		;INSUFFICIENT MEMORY

2$:	MOV	R1,STKLIM	;SAVE NEW BOTTOM ADDRESS
	SUB	#STKFDG,R1	;COMPUTE HANDLER LOAD POINT
	SUB	WA+2,R1
	.FETCH	R1,R2		;GET HANDLER
1$:	RETURN
	.PAGE
	.SBTTL	END-OF-PASS ROUTINES
INIP2:				;INITIALIZE PASS 2
	.IF NDF XCREF
	MOV	CRFFLG,CRFTST	;ALLOW CREF OUTPUT ON PASS 2
	.ENDC
1$:	CLR	RECNUM+SRCCHN	;INPUT RECORD #
INIP1:				;INITIALIZE PASS 1
INITI:	MOV	#3,CHAN+SRCCHN	;SET RT11 INPUT CHAN
				;AND INPUT BUFFER POINTER
	MOV	BLKTBL+<SRCCHN*4>,R0
	MOVB	#FF,-(R0)	;START PASS WITH A FORM FEED
	MOV	R0,PTRTBL+<SRCCHN*4>
	MOV	#SSAREA,SSNDX	;RESET INCLUDE, COPY CONTROLS
	CLR	CPYLVL+2	;NO INCLUDES TO START WITH
.IF NE,VAX$
	MOV	#^RVX ,SMDBLK	;RESET MACLIB DEVICE
.IFF
	MOV	#^RDK ,SMDBLK	;RESET MACLIB DVC NAME
.ENDC

FINP1:				;FINISH PASS 1
FINP2:	RETURN			;FINISH PASS 2

	.SBTTL	SWITCH AND DATE DATA AREAS

	ENTSEC	DPURE$

	.IF NDF XSWIT

	.MACRO	SWTGEN	SW.NAM
	.ASCII	/SW.NAM/
	.BYTE	SWR'SW.NAM-SWTDON-128.
	.ENDM

	.MACRO	GSWARG	SWARG,SWVAL
	.RAD50	/SWARG/
	.WORD	SWVAL
	.ENDM

	.GLOBL	CRFTAB
	.IF NDF XCREF
CRFS=000002	; SYMBOL CREF DESIRED
CRFR=000004	; REGISTER CREF DESIRED
CRFM=000010	; MACRO  CREF DESIRED
CRFP=000020	; PST    CREF DESIRED
CRFC=000040	; CSECT  CREF DESIRED
CRFE=000100	; ERROR  CREF DESIRED
	.GLOBL	CRFTAB,CRFFLG,CRFTST


CRFTAB:
	GSWARG	< >,CRFS+CRFM+CRFE
	GSWARG	S,CRFS
	GSWARG	R,CRFR
	GSWARG	M,CRFM
	GSWARG	P,CRFP
	GSWARG	C,CRFC
	GSWARG	E,CRFE
	.WORD	0		; END OF TABLE FLAG
CRFPNT:	.WORD	0
	.ENDC


SWTBL:
	SWTGEN	A		;PRODUCE ALL OUTPUT FILES
	.IF NDF XCREF
	SWTGEN	C
	.ENDC
	SWTGEN	D
	SWTGEN	E
	SWTGEN	L
	SWTGEN	N
	SWTGEN	S		;SUPPRESS TTY ERROR OUTPUT ON TTY
	SWTGEN	X		;EXIT ASSEMBLER
SWTEND	= .

	.ENDC

PRGLIM:	.LIMIT
DEFEXT:
	.IF NDF	XMACRO
	.WORD	EXTNSN		;FILE EXTENSION
	.IFF
	.RAD50	/PAL/
	.ENDC
	.RAD50	/OBJ/
	.RAD50	/LST/
	.IF NDF XCREF
	.RAD50	/CRF/
	.IFF
	.WORD	0
	.ENDC
	.PAGE
	.IF NDF	XCREF

CRFSPC:	.RAD50	/DK /
	.RAD50	/CREF  /
	.RAD50	/TMP/
	.ENDC

	.IF NDF	XTIME
MONTBL:	.ASCIZ	/Jan/		;TABLE OF MONTH NAMES
	.ASCIZ	/Feb/
	.ASCIZ	/Mar/
	.ASCIZ	/Apr/
	.ASCIZ	/May/
	.ASCIZ	/Jun/
	.ASCIZ	/Jul/
	.ASCIZ	/Aug/
	.ASCIZ	/Sep/
	.ASCIZ	/Oct/
	.ASCIZ	/Nov/
	.ASCIZ	/Dec/

TIMWRD:	.BYTE	0,21		;V2 TIME PARAMETER BLOCK
	.WORD	TIME		;ADRS OF TIME AREA
TIME:	.BLKW	2		;TIME-OF-DAY AREA

OBJTIM::.BLKW	2		;OBJECT CODE DATE/TIME RECORD
	.WORD	2*400		;GSD TYPE FOR DAT/TIM
OBJDAT:	.BLKW			;OBJECT FILE DATE CODE GOES HERE

OBJERR::
	.MAC50
	.WORD	2*400		;GSD TYPE FOR LANG/ERROR
OBJERC::.WORD	0		;ERROR/WARN COUNTS
	.ENDC

.IF EQ,VAX$
CPUWRD:	.BYTE	0,21
	.WORD	CPUTIM
IOTWRD:	.BYTE	0,21
	.WORD	IOTIME

IOTIME:	.BLKW	2		;THESE 2 AREAS MUST BE TOGETHER
CPUTIM:	.BLKW	2
.ENDC

CSIERR:	.WORD	ILLCMD		;CSI ERROR CODES
	.WORD	ILLDEV
	.WORD	0
	.WORD	DEVFUL
	.WORD	FILNF
ILLCMD:	.ASCIZ	/?CSI-F-Illegal command./
ILLDEV:	.ASCIZ	/?CSI-F-Illegal device./
DEVFUL:	.MACQQ
	.ASCIZ	/-F-Device full./
FILNF:	.MACQQ
	.ASCII	/-F-File not found  /<200>
	.EVEN

	XITSEC

	.SBTTL	INIT OUTPUT FILES (CONTINUED)
	.ENABL LSB

DATE:
	.IF NDF XTIME
	MOV	#TIMWRD,R0	;ADRS OF TIME PARAMETER BLOCK
	.GTIM
	.DATE			;GET CODED DATE INTO R0
	MOV	R0,OBJDAT	;PASS DATE TO OBJECT FILE
	MOV	#DATTIM+1,R2	;CHAR PTR
	MOV	R0,R1		;DATE WORD
	BEQ	5$		;NO DATE, SO SKIP IT
	MOV	R1,-(SP)
	ROL	R1
	ROL	R1
	ROL	R1
	SWAB	R1
	BIC	#177740,R1
	CALL	DNC		;DAY
	MOVB	#'-,(R2)+
	MOV	@SP,R1
	SWAB	R1
	BIC	#177703,R1
	ADD	#MONTBL-4,R1	;POINT TO MONTH
	CALL	MOVBYT
	MOVB	#'-,(R2)+
	MOVB	(SP)+,R1
	BIC	#177740,R1
	ADD	#72.,R1
	CALL	DNC		;YEAR
5$:	MOV	#TIME,R3	;PICK UP TIME OF DAY
	MOV	(R3)+,R0	;HIGH ORDER
	MOV	@R3,R1		;LOW ORDER
	MOV	R0,OBJTIM	;PASS TIME CODE TO OBJECT RECORD
	MOV	R1,OBJTIM+2
.IF EQ,VAX$
	MOV	#IOTIME+2,R4	;COMPUTE DIFFERENCE FROM START
	SUB	(R4),(R3)
	SBC	-(R3)
	SUB	-(R4),(R3)
	MOV	(R3)+,(R4)+	;KEEP DIFFERENCE AT I/O TIME
	MOV	(R3),(R4)
.ENDC
	MOV	#60.,R3		;ASSUME 60 CYCLE CLOCK
	CALL	DIV60		;GET RID OF TICKS
UNPTIM:	CALL	DIV60		;GET SECONDS IN R5
	CLR	-(SP)		;STOPPER FOR DIGIT DUMPER
	MOV	R5,-(SP)	;AND SAVE THEM
	CALL	DIV60		;NOW GET MINUTES IN R5
				;AND HOURS IN R1
	MOV	R5,-(SP)	;AND SAVE MINUTES
	MOV	#24.,R3		;ASSURE MIDNIGHT ROLLOVER
	CALL	DIV60		;GET HOURS IN R5
	INC	R2		;LEAVE A BLANK AFTER DATE
8$:	MOVB	R5,(R2)+	;STORE FIRST DIGIT
	SWAB	R5		;GET OTHER ONE
	MOVB	R5,(R2)+	;STORE SECOND ONE
	MOVB	#':,(R2)+	;PUT OUT DELIMITER
	MOV	(SP)+,R5	;GET NEXT SET OF DIGITS
	BNE	8$		;THERE ARE STILL SOME LEFT
	DEC	R2		;SET TO CLOBBER LAST ":"
9$:	CLRB	(R2)+		;MAKE LINE ASCIZ
	RETURN
	.DSABL	LSB

; DIVIDE R0-R1 BY R3, LEAVING REMAINDER IN R5.
; DESTROYS R5.
DIV60:	CALL	DDIV		;DO DOUBLE DIVIDE
3$:	ADD	#366,R5		;APPLY MAGIC NUMBER TRANSFORMATION
	TSTB	R5		;TO GET REMAINDER IN ASCII
	BPL	3$
	ADD	#"00-366,R5
	SWAB	R5
	MOV	#60.,R3		;ASSURE CORRECT DIVISOR
	.ENDC
	RETURN

	.SBTTL	FINISH ASSEMBLY AND RESTART

	.GLOBL	WRNCNT,R50UNP
SETDN:	MOV	#FINMSG,R1
	MOV	#LINBUF,R2
	CALL	MOVBYT		;POSITION MESSAGE
	MOV	ERRCNT,R1
	BEQ	3$		;NO ERRORS
	BISB	#2,@#ERRCOM	;SIGNAL ERROR TO INDIRECT COMMAND FILE
3$:	MOV	MONLOW,R0	;GET RMON @
	MOVB	R1,MONCOM(R0)	;PASS ERROR COUNT TO BATCH
	BIT	#-128.,R1	;OVERFLOW?
	BEQ	2$		;NO
	MOVB	#127.,MONCOM(R0)	;LIMIT BATCH ERROR COUNT TO 127
2$:	CALL	DNC		;DECIMAL NUMBER CONVERTER
	TST	WRNCNT		;ANY WARNINGS?
	BEQ	1$		;NOPE. IGNORE OUTPUT
	BISB	#1,@#ERRCOM	;SIGNAL WARNINGS
	MOV	#FINMS3,R1	;YEP. PRINT COUNT
	CALL	MOVBYT
	MOV	WRNCNT,R1
	CALL	DNC
1$:	MOV	#FINMS1,R1
	CALL	MOVBYT
	MOV	FRECOR,R1
	.IF NDF	FIXSTK
	SUB	STKLIM,R1	;CALC FREE CORE
	.IFF
	SUB	#SYMBUF+20.,R1	;CALC FREE CORE
	.ENDC
	ROR	R1		;IN WORDS
	CALL	DNC
	MOV	#FINMS2,R1
	CALL	MOVBYT
	PUTLP	#LINBUF		;PRINT ON LISTING
	PUTLP	#TTYBUF		;ALSO PRINT COMMAND STRING
	CALL	UNP$A		;CONVERT ACTUAL FILE NAMES TO ASCII
	PUTLP	R2		;PRINT THEM
	MOV	R2,-(SP)	;SAVE FREE SPACE POINTER
	MOV	#STATM1,R1	;PRINT STATEMENT COUNT
	CALL	MOVBYT
	CALL	UNPSNM
	MOV	#STATM2,R1
	CALL	MOVBYT
.IF EQ,VAX$
	.GTIM	#TIMWRD		;GET CURRENT TIME
	MOV	#TIME+2,R3	;POINT TO IT
	MOV	#CPUTIM+2,R1	;POINT TO START TIME
	SUB	(R1),(R3)	;COMPUTE CPUTIM=END-START-IOTIME
	SBC	-(R3)
	SUB	-(R1),(R3)+
	SUB	-(R1),(R3)
	SBC	-(R3)
	SUB	-(R1),(R3)
	CALL	TIMOUT		;UNLOAD CPU TIME
	MOV	#TMMSG2,R1
	CALL	MOVBYT		;GET IO TIME MESSAGE
	MOV	#IOTIME,R3	;GET ADDR
	CALL	TIMOUT		;UNLOAD IO TME
.IFF
	MOV	R2,-(SP)	;POINT TO PLACE TO PUT TEXT
	MOV	#132.,-(SP)	;AND A COUNT
	VAX.GT			;GET THE JOB STATS
	ADD	(SP)+,R2	;COMPUTE END OF RETURNED TEXT
.ENDC
	MOVB	#CR,(R2)+	;POLISH OFF LINE
	MOVB	#LF,(R2)+
	CLRB	(R2)+
	PUTLP	(SP)+		;PRINT DATA
FIN:	$FLUSH	LST		;DUMP LAST BUFFERS
	$FLUSH	BIN
	.RCTRLO
	.PRINT	#LINBUF		;PRINT STATISTICS ON TTY
	.IF NDF	XCREF
	$FLUSH	CRF
	TST	CRFFLG		;ANY CREF DESIRED?
	BEQ	FINCL		;NOPE
	MOV	#CHNSPC,R2	;ELSE POINT TO CHAIN INFO
	MOV	(R2)+,R1	;R1 = 500 (.CHAIN AREA)
	MOV	(R2)+,(R1)+	;MOVE IN CREF NAME
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+	;OUTPUT (LST) CHANNEL #
	TST	(R1)+		;OUTPUT DEVICE (SET BY CSISPC)
	BEQ	FINCL		;NO CREF IF NO LISTING DEVICE
	MOV	RECNUM+LSTCHN,(R1)+ ;OUTPUT HIGHEST BLOCK WRITTEN
	MOV	(R2)+,(R1)+	;INPUT (CRF) CHANNEL #
	MOV	(R2)+,(R1)+	;INPUT DEVICE
	MOV	@#<500+<2*10.>>,R0 ;GET DEVICE, IF SPECIFIED
	BEQ	3$		;NOPE - JUST USE DEFAULT
	MOV	R0,-2(R1)	;ELSE PUT IN INTERFACE
3$:	MOV	RECNUM+CRFCHN,(R1)+ ;INPUT HIGHEST BLOCK WRITTEN
	CLR	(R1)+		;LISTING WIDTH FLAG
	BIT	#LC.TTM,LCMASK	;IN .NLIST TTM MODE?
	BEQ	1$		;NOPE
	COM	-2(R1)		;ELSE NOTE
1$:	MOV	(R2)+,(R1)+	;MOVE IN NAME OF RETURN CHAIN
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+
	MOV	@R2,R2		;POINT TO LAST TITLE LINE
2$:	MOVB	(R2)+,(R1)+	;COPY INTO CHAIN AREA
	CMP	R2,TTLBRK	;END OF TITLE?
	BLO	2$		;NOPE - KEEP COPYING
	CLRB	(R1)+		;ASSURE ASCIZ
	$CLOUT	BIN		;ASSURE BINARY CLOSED
	.CHAIN			;CHAIN TO CREF
	BR	ERR		;CAN'T HAPPEN (EXCEPT IN DISASTERS)
	.ENDC			;NDF XCREF

FINCL:	.LOCK			;KEEP USR IN CORE
	$CLOUT	BIN		;CLOSE BINARY
	$CLOUT	LST		;AND LISTING
	.UNLOCK			;RELEASE USR
ERR:	.SRESET
	.RCTRLO
	JMP	CONT

SERROR:	.PRINT			;PRINT ERROR MESSAGE
	MOV	MONLOW,R0	;GET RMON @
	MOVB	#128.,MONCOM(R0)	;PASS HARD ERROR FLAG TO BATCH
	BISB	#4,@#ERRCOM	;PASS HARD ERROR TO INDIRECT COMMAND FILE
	BR	ERR

UNP$A:	MOV	SRCDAT+6,R2	;GET SOME WORK AREA
	SUB	#512.,R2	;USE THE SOURCE BUFFER
	MOV	R2,-(SP)	;SAVE THE ADDRESS
	CLR	R5
	MOV	#'(,(R2)	;START WITH OPEN BRACKET
	MOV	#SPAREA,R4	;R50 STUFF LOCATED HERE
3$:	CALL	UNP$FN		;UNPACK FILE NAME
	ADD	FNDX(R5),R4	;SKIP TO NEXT FILE
	CMP	R4,FNDX+2(R5)	;END?
	BLO	3$		;NO. CONTINUE
	MOVB	#'=,(R2)
	CMP	(R5)+,(R5)+	;R5=R5+4
	TST	FNDX(R5)	;DONE?
	BNE	3$		;NO. CONTINUE
	MOVB	#'),(R2)+	;CLOSE BRACKET
	CLRB	(R2)		;PREPARE TO COMPRESS
	MOV	(SP),R2		;RESET ADDRESS TO BEGINING
	MOV	R2,R1		;KEEP A COPY
5$:	MOVB	(R2)+,(R1)	;SQUEEZE
	BEQ	4$		;DONE
	CMPB	#' ,(R1)	;SPACE?
	BEQ	5$		;YEP. IGNORE IT
	INC	R1		;NO. KEEP IT
	BR	5$		;CONTINUE
4$:	MOVB	#CR,(R2)+
	MOVB	#LF,(R2)+
	CLRB	(R2)
	MOV	(SP)+,R2	;RESET ADDRESS
	RETURN

UNP$FN:	MOV	(R4),SYMBOL	;DVC:
	BEQ	1$		;NO DATA
	CMP	R4,#SPAREA+20.	;CREF FIELD?
	BNE	6$		;NO
	TST	CRFFLG		;CREF REQUESTED?
	BEQ	1$		;NOPE. SKIP LIST
6$:	CLR	SYMBOL+2	;ONLY 3 CHARACTERS
	INC	R2		;SKIP A PLACE
	CALL	R50UNP		;CONVERT DVC NAME TO ASCII
	MOVB	#':,(R2)+	;DVC SEPERATOR
	MOV	2(R4),SYMBOL	;FILE NAME
	MOV	4(R4),SYMBOL+2
	CALL	R50UNP		;CONVERT FILE NAME TO ASCII
	MOV	6(R4),SYMBOL	;EXT
	BEQ	2$		;NO EXT
	CMP	SYMBOL,(PC)+	;DEFAULT?
	.WORD	EXTNSN
	BEQ	2$		;YES. DON'T PRINT IT
	CLR	SYMBOL+2
	MOVB	#'.,(R2)+	;SEPERATOR
	CALL	R50UNP		;CONVERT EXT TO ASCII
2$:	MOVB	#',,(R2)	;SEPERATOR
1$:	RETURN

TIMOUT:	MOV	(R3)+,R0	;HI ORDER
	MOV	(R3),R1		;LO ORDER
	MOV	#6,R3		;DIVIDE IT BY 6
	MOV	MONLOW,-(SP)
	ADD	#CONFIG,(SP)
	BIT	#$CLK50,@(SP)+	;60 CYCLE CLOCK?
	BEQ	1$		;YES.
	DEC	R3		;NO. 50 CYCLE CLOCK
1$:	CALL	DIV60
	MOV	#10.,R3		;GET TENTHS OF SECONDS
	CALL	DIV60		;IN R5
	MOV	R5,-(SP)	;SAVE IT
	DEC	R2		;BACK UP OVER NULL CODE
	CALL	UNPTIM		;UNPACK REST OF TIME
	CLRB	-(R2)		;FORCE A TERMINATOR
	SUB	#8.,R2		;BACK UP TO BEGINING OF TIME
2$:	MOVB	3(R2),(R2)+	;MOV ALL BACK 3 SPACES
	BNE	2$
	MOVB	#'.,-1(R2)	;CHANGE TERMINATOR TO '.'
	SWAB	(SP)		;GET LS DIGIT
	MOVB	(SP)+,(R2)+	;PUT IT IN
	RETURN

	.GLOBL	SRCCNT

UNPSNM:	MOV	SRCCNT,R1	;PRINT TOTAL STATEMENTS ASSEMBLED
	MOV	SRCCNT+2,R0
	MOV	#10.,R3		;DIVISOR
	CLR	R4		;DIGIT COUNTER
2$:	CALL	DDIV		;DO DOUBLE PRECISION INTEGER DIVIDE
	INC	R4		;COUNT DIGIT
	BIT	#4,R4		;4TH ONE IN A STRING?
	BEQ	1$		;NOPE
	BIS	#100000,R5	;YES. INDICATE TO INSERT A COMMA
	MOV	#1,R4		;RESET R4
1$:	MOV	R5,-(SP)	;SAVE REMAINDER
	MOV	R1,-(SP)
	BIS	R0,(SP)+	;ANY MORE?
	BEQ	3$		;NOPE
	CALL	2$		;YES. RECURSE
3$:	BIS	#'0,(SP)	;ASCIFY DIGIT
	MOVB	(SP),(R2)+	;SEND IT
	TST	(SP)+		;PRUNE STACK
	BPL	4$		;NO COMMA REQUIRED
	MOVB	#54,(R2)+	;INSERT A COMMA
4$:	RETURN

DDIV:	MOV	#31.,-(SP)	;BIT COUNTER
	CLR	R5		;REMAINDER
1$:	ASL	R1		;LSB'S
	ROL	R0		;MSB'S
	ROL	R5		;REMAINDER
	CMP	R5,R3		;ROOM?
	BLO	2$		;NOPE
	SUB	R3,R5		;COMPUTE
	INC	R1		;ACCUMULATE QUOTIENT
2$:	DEC	(SP)		;COUNT
	BPL	1$		;CONTINUE
	TST	(SP)+		;PURGE STACK
	RETURN			;R0,R1 = QUOTIENT; R5 = REMAINDER

	.SBTTL	MEMORY MANAGEMENT
	.GLOBL	LINBUF,LINQUE
TSTSTK:				;TEST IF STACK OUT OF BOUNDS
	CMP	SP,STKLIM
	BLO	CORERR
	.IF NDF	FIXSTK
	CMP	SP,FRECOR	;NEW RECORD FOR STACK
	BHIS	1$		;NO
	MOV	SP,FRECOR	;YES, RECORD IT
	.IFTF
1$:	RETURN
CORERR:	SERROR	CORE,<Ran out of memory while processing statement:>,,0
	.PRINT	#LINBUF
	SERROR	LASTQ,<The last que'd line is:>,I,0
	MOVB	#' ,LINQUE	;RESTORE QUE BUFFER IN CASE IT WAS PURGED
	CLRB	LINQUE+80.	;MAKE SURE WE STOP PRINTING
	.PRINT	#LINQUE
	MOV	#SPAREA,R0
	CLR	(R0)
	JMP	SERROR
	.IFF
TSTSYT:				;TEST SYMBOL TABLE
	CMP	ROLBAS,#SYMBUF+20.
	BLO	CORERR
	CMP	ROLBAS,FRECOR	;NEW RECORD FOR TABLE?
	BHIS	1$		;NO
	MOV	ROLBAS,FRECOR	;YES, RECORD IT
1$:	RETURN
	ENTSEC	ROLBAS
ROLBAS:
	.IFTF
	ENTSEC	MIXED$
STKSAV:	.BLKW
STKLIM:: .BLKW
	.IFT
SYTTOP=STKSAV
	.IFF
SYTTOP:	.BLKW
	ENTSEC	SYMBUF
SYMBUF:	.BLKW	4000.		;FIXED SYMBOL TABLE
SYMBUE:
	.ENDC
	ENTSEC	IMPUR$
FRECOR:	.BLKW
	XITSEC

	.SBTTL	GET PHYSICAL SOURCE LINE

GETPLI:
	$READW	SRC
	CLR	R0
	BIT	#IO.EOF,IOFTBL+SRCCHN	;END OF FILE?
	BEQ	2$		;NO
	TST	CPYLVL		;'INCLUDE' BEING EXECUTED?
	BEQ	3$		;NO
	CALL	DETACH		;RESET POINTERS
	BR	GETPLI		;RE-TRY WITH NEW POINTERS
3$:	MOV	CHAN+SRCCHN,R0	;GET CURRENT INPUT CHAN
	INC	R0		;MOVE TO NEXT CHAN
	CMP	R0,#8.		;LAST CHAN?
	BHI	1$		;YES, FLAG END OF INPUT
	CLR	RECNUM+SRCCHN	;RESET RECORD (BLK) NUMBER
	MOV	BLKTBL+<SRCCHN*4>,PTRTBL+<SRCCHN*4>
	MOV	R0,CHAN+SRCCHN
	.WAIT	CHAN+SRCCHN
	BCS	1$		;BRANCH IF NO MORE INPUT
4$:	MOV	#-1,R0		;FLAG END OF FILE
2$:	RETURN
1$:	MOV	#1,R0		;FLAG END OF INPUT
	RETURN

	.SBTTL	SYSTEM MACRO HANDLERS
	.GLOBL	SMDBLK
	.IF NDF	XSML
	.ENABL	LSB
INISML:
	TST	SMLSW		;NEW CALL?
	BNE	FINSML		;NO, EXIT
	INC	SMLSW		;SET SWITCH
	CLR	RECNUM+SMLCHN	;RESET RECORD #
	.WAIT	CHAN+SMLCHN	;CHANNEL ALREADY OPEN?
	BCC	1$		;YES
	.FIND	CHAN+SMLCHN,#SMDBLK	;OPEN SYSTEM MACRO FILE
	BCS	FINSML		;SOMETHING WRONG

1$:	MOV	#BLKTBL+<SMLCHN*4>,R0
	MOV	@R0,-(R0)	;SET BUF PTR TO EMPTY
	MOV	SP,R0		;SIGNAL GOOD (NON-ZERO) RETURN
	RETURN

FINSML:
	CLR	R0		;SIGNAL DONE
	CLR	SMLSW		;CLEAR SWITCH
	RETURN
	.DSABL	LSB

	ENTSEC	DPURE$
SMDBLK:
.IF EQ,VAX$
	.RAD50	/DK /		;DEVBLK FOR SYSTEM MACRO FILE
.IFF
	.RAD50	/VX /
.ENDC
	.RAD50	/SYSMAC/
	.IF ne,MACXX&..mro
	.RAD50	/SML/
	.IFF
	.WORD	EXTNSN
	.ENDC
	ENTSEC	MIXED$

	.BLKW	256.		;BUFFER FOR SYSTEM MACROS
SMLBLK:
	ENTSEC	IMPUR$
SMLSW:	.BLKW
WA:	.BLKW	5
	XITSEC
	.ENDC

	.SBTTL	WRITE ROUTINES

$WRITW::
$WRITE::CALL	SAVREG
	BIC	#IO.EOF!IO.ERR,IOFTBL(R0)	;CLEAR FLAGS
	MOV	CNTTBL(R0),R4
	MOV	(R4)+,R1	;ACTUAL BYTE COUNT
	MOV	(R4)+,R2	;LOGICAL BUFFER POINTER
	MOV	(R4)+,R3	;PHYSICAL BUFFER POINTER
; R4 NOW POINTS TO PHYSICAL BUFFER END POINTER
	TSTB	IOLTBL+1(R0)	;BINARY MODE?
	BNE	3$		;YES
1$:	MOVB	(R2)+,(R3)+	;MOVE LINE
	CMP	R3,@R4		;END OF PHYSICAL BUFFER
	BLO	2$		;NO
	CALL	POUT		;YES; PERFORM WRITE
	BCS	WRTERR		;EXIT IF ERRORS
2$:	DEC	R1
	BNE	1$		;LOOP UNTIL LINE FINISHED
	MOV	R3,-(R4)	;UPDATE BUFFER POINTER
	RETURN

; FORMATTED BINARY WRITE
3$:	MOV	#BINCHN,R0
	ADD	#4,R1		;INCLUDE PROTOCOL BYTES IN COUNT
	MOV	R1,-(R2)	;MOVE BYTE COUNT TO BEFORE BUFFER
	TST	-(R2)		;MAKE R2 POINT TO FLAG WORD(1)
	MOV	R5,-(SP)
	CLR	-(SP)
	CLR	R5		;INIT CHECKSUM
4$:	MOVB	(R2)+,@SP
	ADD	@SP,R5		;ADD CHAR TO CKSUM
	MOVB	@SP,(R3)+	;AND MOVE CHAR TO OUTPUT
5$:	CMP	R3,@R4		;OUTPUT BUFFER OVERFLOW?
	BLO	6$		;NO
	CALL	POUT		;YES, DUMP BUFFER
	BCS	WRTERR		;EXIT IF ERRORS
6$:	DEC	R1
	BGT	4$
	BEQ	7$		;GO TO STORE CKSUM
	MOV	R3,PTRTBL+<BINCHN*4>	;UPDATE BUF PTR
	MOV	R3,PTRTBL+<RELCHN*4>	;FOR BOTH BINARY CHNS
	TST	(SP)+
	MOV	(SP)+,R5
	RETURN
7$:	NEG	R5
	MOVB	R5,(R3)+	;STORE CKSUM
	BR	5$
WRTERR:	BIT	#IO.ERR,IOFTBL(R0)	;I/O ERROR?
	BNE	IOERR			;YES - REPORT
	MOV	R0,R1
	SERROR	ODF,<Output file full  >
IO$ERR:	MOV	CHAN(R1),R0
	MOV	#SPAREA,R4
	CMP	R0,#3			;CHANNEL 0,1,2 ?
	BGE	1$			;NOPE
	ASL	R0
	ADD	R0,R4			;10*CHAN + AREA
	BR	2$

1$:	ADD	#30.,R4			;ELSE AREA+30. + <CHAN-3>*8
	SUB	#3,R0
	ASL	R0
2$:	ASL	R0
	ASL	R0
	ADD	R0,R4
	MOV	SRCDAT+6,R2		;POINT TO FREE SPACE
	MOV	R2,-(SP)		;SAVE IT FOR LATER
	DEC	R2			;BACKUP 1 BECAUSE UNP$FN BUMPS 1
	CALL	UNP$FN			;UNPACK FILE NAME
	CLRB	(R2)			;ZAP THE END
	MOV	(SP),R2			;POINT TO START
	MOV	R2,R1
3$:	MOVB	(R2)+,(R1)		;COPY TEXT
	BEQ	4$
	CMPB	(R1),#40		;SPACE?
	BEQ	3$			;IGNORE IT
	INC	R1
	BR	3$
4$:	MOV	(SP)+,R0		;POINT TO TEXT
	JMP	SERROR

IOERR:	MOV	R0,R1			;SAVE CHANNEL NUMBER
	SERROR	IOE,<Error reading or writing file - >
	BR	IO$ERR

	.SBTTL	COPY,INCLUDE AND DETACH
	.GLOBL INCLU,COPY,FILENM,CPYLVL,LCLVL,INCFLG,SETCHR,SBTTL

COPY:	TST	PASS		;PASS 2?
	BNE	1$		;YES
2$:	CLR	R5		;SO NO 'Q' ERRORS
	RETURN			;IGNORE COPY DURING PASS 1
1$:	TST	LCLVL		;.NLIST IN EFFECT?
	BLT	2$		;YEP. IGNORE COPY
	CALL	SAVREG
	CLR	R3		;NO DEFAULT EXT FOR COPY
	CALL	ATTACH		;ATTACH FILE TO SRC CHAN
	BCS	2$		;ERROR. NO GOOD
	CALL	ENDLIN		;POLISH OFF THE LINE
.IF NE,VAX$
	MOV	CHAN+SRCCHN,R0
	CLRB	DTYPE-3(R0)	;SIGNAL BLOCK I/O
.ENDC
	MOV	#LSTCHN,R0	;GET LIST INDEX
	MOV	CNTTBL(R0),R4	;GET LISTING CONTROLS ADDRESS
	MOV	#512.,(R4)+	;INIT THE COUNT TO MAX
	MOV	CNTTBL+SRCCHN,R1	;GET SOURCE INPUT CONTROL ADDRESS
	ADD	#6,R1		;SKIP TO INPUT BUFFER ADDRESS
	MOV	(R1),(R4)	;POINT THE OUTPUT TO THE INPUT
	SUB	#512.,(R4)	;BACK UP TO BEGINING OF BUFFER
	MOV	CHAN(R0),-(SP)
	.WAIT	(SP)+		;.WAIT ON .LST CHANNEL
	BCS	3$		;NO LIST. JUST EXIT
4$:	MOV	#SRCCHN,R0	;GET SOURCE CHAN INDEX
	MOV	CNTTBL(R0),R4	;SET R4 TO ADDRESS OF STATISTICS
	ADD	#6,R4		;SKIP UP TO BUFFER END POINTER
	CALL	PIN		;READ A BLOCK
	BCS	3$		;EOF OR ERROR
	$WRITW	LST		;PRINT IT
	BR	4$		;CONTINUE
3$:	MOV	#LSTCHN,R0	;RESET THE LISTING CONTROLS
	MOV	CNTTBL(R0),R4
	CLR	(R4)+		;SET COUNT TO 0
	MOV	#LSTBUF,(R4)	;AND LOGICAL POINTER
	CALL	DETACH		;RESTORE SRC STATUS
	BR	2$		;DONE

INCLU:	CALL	SAVREG
	INC	INCFLG		;SIGNAL WE'RE DOING AN INCLUDE
	MOV	CHRPNT,R0	;POINT TO CHARACTER
	MOVB	-(R0),-(SP)	;SAVE CHARACTER
	MOVB	#11,(R0)	;REPLACE IT WITH A HT
	MOVB	-(R0),-(SP)
	MOVB	#11,(R0)
	MOV	R0,-(SP)	;SAVE MODIFIED CHRPNT
	MOV	R0,CHRPNT	;CHANGE CHRPNT
	CALL	SBTTL		;PUT INCLUDE STATMENT INTO SUBTITLE
	MOV	(SP)+,R0	;GET MODIFIED CHRPNT
	MOVB	(SP)+,(R0)+	;RESTORE CHARACTERS
	MOVB	(SP)+,(R0)+
	MOV	R0,CHRPNT	;RESTORE CHRPNT
	CALL	SETCHR		;RESET R5
	MOV	(PC)+,R3	;SET DEFAULT EXT FOR '.INCLUDE'
	.WORD	EXTNSN
	.PAGE
ATTACH:	.GTIM	#TIMWRD		;PREPARE TO TIME THIS
	CALL	TSTARG		;SKIP TO OPERAND
	BNE	1$		;THERE'S ONE PRESENT
3$:	CALL	CPTIOT		;COMPUTE ELAPSED TIME
5$:	ERROR	O
	SEC
6$:	BIC	R5,R5		;ZAP R5 SO NO 'Q' ERRORS, BUT LEAVE CARRY
	RETURN

1$:	MOV	SSNDX,R2	;GET CURRENT NEST LEVEL
	CMP	R2,#SSEND	;TOO DEEP?
	BHIS	3$		;YEP
	MOV	#CHAN+SRCCHN,R1	;POINT TO CHAN ID
	MOVB	(R1),R0		;GET CHANNEL #
	MOVB	R0,(R2)+	;SAVE CURRENT CHANNEL
.IF NE,VAX$
	MOVB	DTYPE-3(R0),(R2)+  ;SAVE TYPE
.IFF
	CLRB	(R2)+		;TYPE CODE (ALWAYS 0)
.ENDC
	MOV	CPYLVL+2,R0	;SELECT A NEW CHANNEL
	ADD	#3+6,R0		;BEGINING WITH CHANNEL 9
	MOV	R0,(R1)		;POINT TO CHANNEL #
	SUB	#3,R0		;RELATIVE TO 0
	ASL	R0		;*2 BYTES/WORD
	ASL	R0		;*4 WORDS/ENTRY
	ASL	R0
	ADD	#SPAREA+30.,R0	;+ AREA POINTER = FILE NAME
	MOV	RECNUM+SRCCHN,(R2)	;SAVE BLOCK NUMBER
	DEC	(R2)+		;MAKE IT THE CURRENT BLOCK NUMBER
	MOV	SRCDAT+4,(R2)+	;SAVE THE BUFFER POINTER
	MOV	R2,SSNDX	;SAVE POINTER
	MOV	R0,R1		;POINT TO SPACE
	CALL	FILENM		;PUT NEW FILE NAME IN FREE SPACE
	INC	CPYLVL+2	;COUNT LEVEL
	CLR	RECNUM+SRCCHN	;START NEW FILE AT BLOCK 0
	MOV	SRCDAT+6,SRCDAT+4	;WITH BUFFER EMPTY
	.FIND	CHAN+SRCCHN,R1	;TRY FOR FILE
	BCC	4$		;OK
	CALL	CPTIOT		;COMPUTE I/O TIME
	CALL	DETACH		;ERROR. RESET TO ENTRY
	BR	5$		;AND EXIT WITH ERROR

4$:	CALL	CPTIOT		;COMPUTE I/O TIME
	BR	6$		;EXIT WITH NO ERRORS
	.PAGE
DETACH:	CALL	SAVREG		;SAVE ALL THE REGS
	.GTIM	#TIMWRD
	MOV	#CHAN+SRCCHN,R1
	.CLOSE	(R1)		;CLOSE SOURCE CHANNEL SOFTLY
	SUB	#SSZE*2,SSNDX	;BACK UP ONE ENTRY
	MOV	SSNDX,R2	;GET SAVE AREA ADDRESS
	MOVB	(R2)+,R0	;GET SAVED CHANNEL NUMBER
	MOV	R0,(R1)		;RESTORE IT
.IF NE,VAX$
	MOVB	(R2)+,DTYPE-3(R0)  ;RESTORE TYPE CODE
.IFF
	TSTB	(R2)+		;SKIP TYPE CODE
.ENDC
	CALL	CPTIOT		;COMPUTE I/O TIME
	MOV	#SRCCHN,R0	;SOURCE CHAN INDEX => R0
	MOV	#SRCDAT+6,R4	;SOURCE BUFFER @ => R4
	MOV	(R2)+,RECNUM(R0)	;RESTORE CURRENT BLOCK NUMBER
	CALL	PIN		;GET A FRESH COPY OF BLOCK
	MOV	(R2),SRCDAT+4	;RESTORE POINTER
	DEC	CPYLVL+2	;BACK OUT 1 LEVEL
	MOV	CPYLVL+2,CPYLVL	;TERMINATE .INCLUDE IMMEADIATELY
	RETURN			;DONE

SSCNT	=14.-<6+3>		;LEVELS OF DEPTH ALLOWED
SSNDX:	.WORD	SSAREA		;CURRENT LEVEL INDEX
SSZE	=1+2			;SIZE OF EACH ENTRY IN WORDS
SSAREA:	.BLKW	SSCNT*SSZE	;SAVE STATUS AREA
SSEND:

	ENTSEC IMPUR$
CPYLVL:	.BLKW	2		;DEPTH INDICATOR
WSPC:	.BLKW	4		;SPACE FOR FILE NAME
	XITSEC
	.PAGE
	.SBTTL	READ ROUTINE
$READW::
$READ::	CALL	SAVREG
	BIC	#IO.EOF!IO.ERR,IOFTBL(R0)	;CLEAR FLAGS
	CLR	R1		;BYTE COUNT
	MOV	CNTTBL(R0),R4
	TST	(R4)+
	MOV	(R4)+,R2	;LINE BUFFER POINTER
	MOV	(R4)+,R3	;PHYSICAL BUFFER POINTER
; R4 NOW POINTS TO PHYSICAL BUFFER END POINTER
	MOV	R5,-(SP)
	MOV	CPYLVL+2,CPYLVL	;INDICATE .INCLUDE STATUS
.IF NE,VAX$
	MOVB	CHAN(R0),R5	;GET CHANNEL NUMBER
	TSTB	DTYPE-3(R5)	;VAX MODE?
	BMI	90$		;YEP
.ENDC

10$:	CMP	R3,@R4		;INPUT BUFFER EMPTY?
	BLO	30$		;NO
	CALL	PIN		;YES, FILL IT
	BCC	30$		;BRANCH IF NO ERRORS
	BIT	#IO.EOF,IOFTBL(R0) ;END-OF-FILE?
	BEQ	20$		;NOPE, MUST BE BAD, BAD, VERY BAD
	MOV	R3,-(R4)	;UPDATE PHYSICAL BUFFER POINTER
	BR	120$		;GO PUT IN A NULL RECORD

20$:	JMP	IOERR		;ELSE FATAL - REPORT

30$:	MOVB	(R3)+,R5	;GET NEXT BYTE
	BIC	#177600,R5	;STRIP ASCII TO 7 BITS
	INC	R1		;ASSUME GOOD CHAR
	MOVB	R5,(R2)+	;STUFF IT INTO LINE
	CMPB	R5,#SPACE	;GOOD CHAR?
	BLO	40$		;BRANCH IF SPECIAL CHAR
	CMPB	R5,#173		;IGNORE CHAR?
	BHIS	38$		;YEP
35$:	CMPB	R1,IOLTBL(R0)	;LINE TOO LONG?
	BLO	10$		;nope, keep getting chars
	ERROR	L		;YEP, SIGNAL LENGTH ERROR
38$:	MOVB	#LF,-(R2)	;INSERT A LINE TERMINATOR
	DEC	R1		;BACKUP 1
	BR	10$		;AND KEEP LOOKING 'TIL END OF RECORD

40$:	CMPB	R5,#LF		;LINE TERMINATOR?
	BNE	70$		;TRY AGAIN

50$:	MOV	R3,-(R4)	;UPDATE PHYSICAL BUF PTR
60$:	MOV	R1,@CNTTBL(R0)	;YES, END OF LINE
	MOV	(SP)+,R5
	RETURN

70$:	CMPB	R5,#CR		;LEAVE <CR> ALONE
	BEQ	35$
	CMPB	R5,#TAB		;LEAVE TABS
	BEQ	35$
	CMPB	R5,#FF		;ALTERNATE LINE TERMINATOR?
	BEQ	50$		;YES
	BR	38$		;nope, ignore it
	.PAGE
.IF NE,VAX$
90$:	CLR	-(SP)		;PREPARE BUFFER FOR GET-RECORD
	MOVB	IOLTBL(R0),(SP)	;RECORD SIZE
	MOV	R2,-(SP)	;RECORD BUFFER
	MOV	R5,-(SP)	;CHANNEL NUMBER
	MOV	R0,R5		;SAVE INDEX
	MOV	SP,R0		;POINT TO AREA
	TST	RECNUM(R5)	;FIRST TIME THROUGH?
	BNE	100$		;NOPE
	VAX.RR			;REWIND FILE
	MOV	SP,R0		;RESTORE R0 (ERROR STATUS RETURNED IN R0)
	INC	RECNUM(R5)
100$:	VAX.GR			;GET RECORD FROM VMS
	MOV	R0,R4		;SAVE STATUS
	MOV	R5,R0		;RETRIEVE INDEX
	CMP	(SP)+,(SP)+	;PURGE CHANNEL AND BUFFER
	MOV	(SP)+,R1	;GET RECORD SIZE
	ASL	R4		;STATUS * 2
	ADD	R4,PC		;JUMP TO ROUTINE
	BR	140$		;0 = NO ERROR
	BR	110$		;1 = EOF
	BR	130$		;2 = LENGTH ERROR
	BR	20$		;3 = FATAL ERROR
110$:	BIS	#IO.EOF,IOFTBL(R0)  ;SIGNAL EOF
.IFTF
120$:	CLRB	(R2)		;ZAP LINE BUFFER TO MAKE SURE WE FALL THRU
	CLR	R1		;ZAP RECORD COUNT
.IFT
	BR	140$		;CONTINUE

130$:	ERROR	L		;LENGTH ERROR
.IFTF

140$:	MOV	R2,R4		;GET BUFFER POINTER
	ADD	R1,R4		;POINT TO LAST CHAR
	TST	R1		;RECORD LEN 0?
	BEQ	150$		;YES, SKIP FF TEST
	CMPB	-1(R4),#FF	;LAST CHAR A FF?
	BEQ	60$		;YES, LEAVE IT THEN
150$:	MOVB	#CR,(R4)+	;ELSE FOLLOW WITH CR,LF
	MOVB	#LF,(R4)
	ADD	#2,R1		;UPDATE COUNT
	BR	60$		;CONTINUE
.ENDC

	.SBTTL	COMMON I/O ROUTINES

POUT:	MOV	R1,-(SP)
	MOVB	#11,WA+1	;WRITE CODE
	BR	PIO

PIN:	MOV	R1,-(SP)
	MOVB	#10,WA+1	;READ CODE
.IF NE,VAX$
	MOV	CHAN(R0),R1	;GET CHANNEL CODE
	TSTB	DTYPE-3(R1)	;VAX MODE?
	BPL	PIO		;NO, CONTINUE
	INC	RECNUM(R0)	;FIX UP AFTER .INCLUDE
	MOV	(SP)+,R1	;RESTORE R1
	RETURN
.ENDC

PIO:	MOV	R0,-(SP)
	.GTIM	#TIMWRD		;GET CURRENT TIME
	MOV	#WA+6,R1	;POINT TO WORK SPACE
	MOV	#256.,(R1)	;WORD COUNT
	MOV	(R4),R3		;BUFFER ADDRESS
	SUB	#512.,R3	;POINT TO BEGINING
	MOV	R3,-(R1)	;BEGINING ADDRESS MUST ALSO BE RETURNED IN R3
	MOV	(SP),R0		;RESTORE R0
	MOV	RECNUM(R0),-(R1)	;BLOCK #
	MOVB	CHAN(R0),WA	;CHANNEL
	MOV	#WA,R0		;POINT TO AREA
	.READW	,,,,,#0		; (MAY BE A WRITE) (,'S 'TIL MAC11 GETS KEYWORDS)
	ROR	-(SP)		;SAVE CARRY
	CALL	CPTIOT		;COMPUT I/O TIME
	ASL	(SP)+		;RESTORE CARRY
	MOV	(SP)+,R0
	MOV	(SP)+,R1
	INC	RECNUM(R0)
	BCC	$WAIT		;NORMAL RETURN

	TSTB	@#EMTERR	;ZERO IF EOF
	BEQ	2$
	BIS	#IO.ERR,IOFTBL(R0)	;FLAG BAD ERROR
	BR	3$
2$:	BIS	#IO.EOF,IOFTBL(R0)	;FLAG END OF FILE
3$:	SEC
$WAIT::	RETURN
	.PAGE
; FLUSH OUTPUT BUFFERS
$FLUSH::TST	IOFTBL(R0)	;ANYTHING TO DO?
	BEQ	$WAIT
	MOV	CNTTBL(R0),R4
	CMP	(R4)+,(R4)+
	MOV	(R4)+,R3	;BUFFER POINTER
	MOV	@R4,R1		;END OF BUFFER
	MOV	R1,R2
	SUB	#512.,R2	;POINT TO BEGINNING OF BUFF
	CMP	R3,R2		;BUFFER EMPTY?
	BEQ	$WAIT		;YES, JUST CLOSE IT
	BR	2$
1$:	CLRB	(R3)+		;ZERO THE BUFFER FIRST
2$:	CMP	R3,R1
	BLO	1$
	CALL	POUT		;OUTPUT THE LAST BLOCK
	BCC	$WAIT		;REPORT ANY ERRORS
	JMP	WRTERR		; APPROPRIATELY
	.PAGE
; CLOSE OUTPUT FILES
$CLOUT:	MOV	CHAN(R0),-(SP)
	.CLOSE	(SP)+		;CLAIM CHANNEL
	RETURN

CPTIOT:
.IF EQ,VAX$
	MOV	R1,-(SP)		;SAVE R1
	MOV	#TIME,R1
	MOV	(R1)+,-(SP)	;SAVE OLD TIME HI
	MOV	(R1),-(SP)	;LO
	.GTIM	#TIMWRD		;GET NEW TIME
	SUB	(SP)+,(R1)	;COMPUTE DIFFERENCE
	SBC	-(R1)
	SUB	(SP)+,(R1)+
	MOV	#IOTIME+2,R0
	ADD	(R1),(R0)	;ACCUMULATE I/O TIME
	ADC	-(R0)
	ADD	-(R1),(R0)
	MOV	(SP)+,R1		;RESTORE R1
.ENDC
	RETURN

	.SBTTL	MESSAGES

	ENTSEC	<TXTBYT,D,CON>
	.IF NDF	XTIME
DATTIM:	.ASCII	"          "
TIMTIM:	.ASCIZ	"         "
	.ENDC
FINMSG:	.ASCIZ	/Errors detected: /
FINMS1:	.ASCIZ	<CR><LF>/Available memory: /
FINMS2:	.ASCIZ	/. words./<CR><LF>
FINMS3:	.ASCIZ	<CR><LF>/Warnings detected: /
HDRTTL:	.ASCII	/ATARI /
	.MACII
	.ASCII	/ VM/
	GTVNUM			;FOLLOW WITH CURRENT VERSION #
STATM1:	.ASCIZ	<CR><LF>"A total of "
STATM2:	.ASCII	" statements were processed."<cr><lf>
.IF EQ,VAX$
	.ASCIZ	<CR><LF>"CPU time -  "
TMMSG2:	.ASCIZ	"     I/O time -  "
.IFF
	.BYTE cr,lf,0
.ENDC
	.EVEN
	XITSEC

	.IF NDF	XCREF
	ENTSEC	DPURE$
CHNSPC:	.WORD	500		;CHAIN INFO AREA
	.RAD50	/SY /		;NAME OF CREF
	.RAD50	/CREF  /
	.RAD50	/SAV/
	.WORD	1		;OUTPUT CHANNEL
	.WORD	2		;INPUT CHANNEL
	.RAD50	/DK /		;INPUT DEVICE
	.RAD50	/SY /		;TO CHAIN BACK
	.MAC50
	.RAD50	/SAV/
	.WORD	TTLBUF
	XITSEC
	.ENDC

	.SBTTL	I/O TABLES

;IO FLAGS
IO.NNU=	000001		;NON-NULL DEVICE
IO.TTY=	000002		;DEVICE IS TTY
IO.EOF=	000004		;END-OF-FILE
IO.ERR=	000010		;ERROR

	ENTSEC	IMPUR$
IOFTBL:	.BLKW	MAXCHN/2	;I/O FLAG TABLE
RECNUM:	.BLKW	MAXCHN/2	;RECORD NUMBER

	ENTSEC	DPURE$
IOLTBL:
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.LIST
	.BYTE	ZBUF'LEN,ZTYPE
	.NLIST
	.ENDM

	GENCHN

CNTTBL:
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.LIST
	.WORD	ZCHAN'DAT
	.NLIST
	.ENDM

	GENCHN

BUFTBL:
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.LIST
	.WORD	ZBUF'BUF
	.NLIST
	.ENDM

	GENCHN

	ENTSEC	MIXED$
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.IF NZ	ZTYPE
	.LIST
	.WORD	ZTYPE	;PROTOCOL WORDS FOR BINARY OUTPUT
	.WORD	0
	.NLIST
	.ENDC
	.LIST
ZBUF'BUF:	.BLKW	<ZBUF'LEN+1>/2
	.NLIST
	.ENDM

	GENCHN

PTRTBL=	.+4
BLKTBL=	.+6
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.LIST
ZCHAN'DAT:	.WORD	0
	.WORD	ZBUF'BUF
	.WORD	0
	.NLIST
	.IF NB	ZBLK
	.LIST
	.WORD	ZBLK'BLK
	.NLIST
	.IFF
	.LIST
	.WORD	0
	.NLIST
	.ENDC
	.LIST

	.NLIST
	.ENDM

	GENCHN
CHAN:
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.LIST
	.WORD	ZRTCHN
	.NLIST
	.ENDM

	GENCHN

	.SBTTL	FINIS

	ENTSEC	IMPUR$
IMPURT:

	XITSEC

	.IIF NDF,$$INCL,$$STOP:	.END	START

