 	.SBTTL *********
	.SBTTL * MACXX *
	.SBTTL *********
;	MACXX.MAC	V02-12
	.MCALL .CLOSE,.MACS,.PRINT
	.MACS
	.IF DF	RSX11D
	.SBTTL	RSX11D "FEATURES"

; THE MACRO "GENREG" IS USED TO SPECIFY A REGISTER ROLL SYMBOL.
;

	ENTSEC	REGSEC
REGBAS:

	.MACRO	GENREG RNAME,VALUE
	ENTSEC	REGSEC
	.RAD50	/RNAME/
	.WORD	0
	.BYTE	DEFFLG+REGFLG,0
	.WORD	VALUE
	XITSEC
	.ENDM


	GENREG	R0,0
	GENREG	R1,1
	GENREG	R2,2
	GENREG	R3,3
	GENREG	R4,4
	GENREG	R5,5
	GENREG	SP,6
	GENREG	PC,7

	ENTSEC	REGSEC
REGTOP:
	XITSEC


; THE MACRO "GENSAT" IS USED TO GENERATE A SECTION ATTRIBUTE ROLL ENTRY.
;

	ENTSEC	SATSEC
SATBAS:

	.MACRO	GENSAT SAT,FLG,TYP
	ENTSEC	SATSEC
	.RAD50	/SAT/
	.BYTE	FLG,TYP
	XITSEC
	.ENDM

	GENSAT	ABS,CSTREL,1
	GENSAT	CON,CSTALO,1
	GENSAT	D,CSTTYP,-1
	GENSAT	GBL,CSTGBL,-1
	GENSAT	HGH,CSTMEM,-1
	GENSAT	I,CSTTYP,1
	GENSAT	LCL,CSTGBL,1
	GENSAT	LOW,CSTMEM,1
	GENSAT	OVR,CSTALO,-1
	GENSAT	REL,CSTREL,-1
	GENSAT	RO,CSTACC,-1
	GENSAT	RW,CSTACC,1

	ENTSEC	SATSEC
SATTOP:
	XITSEC

	.ENDC
	ENTSEC	EDTSEC
EDTBAS:
	.MACRO	GENEDT	MNE,SUBR,INIT
	ENTSEC	EDTSEC
ED.'MNE==	EDTTMP
.iif eq,edttmp,.error ;Too many GENEDT's, you have to get rid of one
EDTTMP=	EDTTMP+EDTTMP
	.GLOBL	ED.'MNE
	.RAD50	/MNE/
	.IF NB	SUBR
	.WORD	SUBR
	.IFF
	.WORD	CPOPJ
	.ENDC
	XITSEC
	.IIF NB	<INIT>,	EDINIT=	EDINIT!ED.'MNE
	.ENDM	GENEDT
EDTTMP=	1
	.IIF NDF EDINIT,	EDINIT=	0
	XITSEC

;THE MACRO "GENCND" IS USED TO SPECIFY CONDITIONAL
;ARGUMENTS.  IT TAKES TWO OR THREE ARGUMENTS:

;	1-	MNEMONIC
;	2-	SUBROUTINE TO BE CALLED
;	3-	IF NON-BLANK, COMPLEMENT CONDITION

	ENTSEC	CNDSEC
CNDBAS:
	.MACRO	GENCND	MNE,SUBR,TOGGLE	;GENERATE CONDITIONAL
	ENTSEC	CNDSEC
	.RAD50	/MNE/
	.IF B	<TOGGLE>
	.WORD	SUBR
	.IFF
	.WORD	SUBR+1
	.ENDC
	XITSEC
	.ENDM



;THE FOLLOWING SECTOR IS USED TO COLLECT BYTE STRINGS
;AND NEEDN'T BE LEFT AT AN EVEN LOCATION

	ENTSEC	<TXTBYT,D>

TMPCNT=	1			;SET FOR BIT SHIFTING
ERRMNE:	.IRPC	CHAR,< ABDEILMNOPQRTUZ>
	.IF IDN,<CHAR>,< >
	.ASCII	/W/
	.IFF
	.ASCII	/CHAR/
	.ENDC
ERR.'CHAR==	TMPCNT
TMPCNT=	TMPCNT+TMPCNT
	.ENDM

	XITSEC

	.GLOBL	SSRCH,SETXPR,SETDSP,CVTNUM,CRFREF,CRADIX,CLCFGS,CHSCAN
	.IIF ne,MACXX&.pdp11,	.GLOBL	OSRCH

	.SBTTL		ROLL DEFINITIONS

	ENTSEC	ROLBAS
ROLBAS::
	ENTSEC	ROLTOP
ROLTOP::
	ENTSEC	ROLSIZ
ROLSIZ::
	XITSEC

	.MACRO	GENROL	NAME,	BASE,	TOP,	SIZE
	ENTSEC	ROLBAS
NAME'ROL=	.-ROLBAS
	.GLOBL	NAME'ROL
	.WORD	BASE
	ENTSEC	ROLTOP
	.WORD	TOP
	ENTSEC	ROLSIZ
	.WORD	SIZE*2
	XITSEC
RS.'NAME=	SIZE
	.IIF GT	SIZE-MAXXMT,	MAXXMT=SIZE
	.ENDM	GENROL
;THESE ROLLS ARE ORDERED IN MEMORY
;LOWEST TO HIGHEST

	.IIF NDF MAXXMT,	MAXXMT=	0
	GENROL	STK,	 0,	0,2	;USER STACK
	GENROL	STN,	 0,	0,6	;STACK NAME
	GENROL	SYM,     0,     0,4	;SYMBOL TABLE
	.IF NDF	XMACRO
	GENROL	MAC,     0,     0,4	;MACRO ROLL
	GENROL	DMA,     0,     0,2	;DUMMY ARGUMENT ROLL
	.ENDC
	GENROL	CRF,	0,	0,2	;CREF DISABLE ROLL
	.IF NDF	XEDLSB
	GENROL	LSY,     0,     0,4	;LOCAL SYMBOL ROLL
	.ENDC
	GENROL	SEC,     0,     0,5	;SECTION ROLL
	GENROL	CPX,	 0,	0,4	;COMPLEX EXPRESSION ROLL (POLISH NOTATION)
	GENROL	COD,     0,     0,4	;CODE ROLL
	GENROL	LBN,	0,	0,2	;BINARY LIST CONTROL
	.IF NDF	XMACRO
	GENROL	MAB,     0,     0,BPMB/2
	GENROL	MAA,     0,     0,BPMB/2
	.ENDC

	GENROL	DUM,     0,     0,0	;DUMMY (SEPARATES VARIABLE FROM FIXED)

	GENROL	CND,CNDBAS,CNDTOP,2	;CONDITIONAL ARGUMENTS
	.IF NDF,XBAW
	GENROL	SWT,SWTBAS,SWTTOP,2	;COMMAND STRING SWITCHES
	.ENDC
	GENROL	EDT,EDTBAS,EDTTOP,2	;ENABL/DSABL
	GENROL	LCD,LCTBAS,LCTTOP,2	;LISTING CONTROL
	GENROL	SAT,SATBAS,SATTOP,2	;SECTION ATTRIBUTES
.if ne,macxx&..mz80
	GENROL	PST,PSTBAS,PSTTOP,8.	;PERMANENT SYMBOL TABLE
	GENROL	DIR,DIRBAS,DIRTOP,4	;Directive symbol table
.iff
	GENROL	PST,PSTBAS,PSTTOP,4	;PERMANENT SYMBOL TABLE
.endc
	.IF DF	RSX11D
	GENROL	REG,REGBAS,REGTOP,4
	.ENDC

.iif ne,macxx&.6502,xedcdr = 0		;don't support CDR if MAC65
.iif ne,macxx&<.6502!.68XX!.intel>,xedpic = 0	;don't support PIC if not MAC11
.iif ne,macxx&.6502,		GENEDT	MOS,,1		;MAC65 MOStech format
.IIF NDF, XEDCDR,		GENEDT	CDR,,1
.IIF ne, MACXX&..m69,		GENEDT	WRN,,1		;OPCODE WARNINGS
.IIF NDF, XEDAMA,		GENEDT	AMA,,1		;ABSOLUTE MODE ADDRESS
.IIF NDF, XEDPIC,		GENEDT	PIC,,1		;PIC MODE
  .IF NDF, XREL
  .IIF eq,      0,		GENEDT	ABS,SECINI,1
  .IFF
  .IIF NDF, XABS,		GENEDT	ABS,SECINI
  .ENDC
.IIF NDF, XEDFPT,		GENEDT	FPT,,1		;FLOATING PT TRUNCATION
.IIF NDF, XEDPNC,		GENEDT	PNC,PNCSET	;PUNCH CONTROL
.IIF NDF, XEDLC,		GENEDT	LC,,1		;LOWER CASE, .DSABLed
.IIF NDF, XEDLSB,		GENEDT	LSB,LSBTST,1	;LOCAL SYMBOL BLOCK
.IIF DF, RSX11D,		GENEDT	REG
.IIF ne, MACXX&<..m68!..m69>,		GENEDT	M68	;DEFAULT TO .ENABL M68
.IIF ne, MACXX&<.6502!.intel>,		GENEDT	M68,,1	;DEFAULT TO .DSABL M68
.IIF ne, MACXX&..m80,		GENEDT	M85	;default to .ENABL M85
.IIF ne, MACXX&..mz80,		GENEDT	Z80	;Z80 (as opposed to 8080)
.IIF ne, MACXX&.intel,		GENEDT	S2D,,1	;source to dest notation
.IIF eq, MACXX&..mro,		GENEDT	USD,,1	;UNSIGNED DIVISION (always)
.IIF NE,	1,		GENEDT	GBL,,1	;AUTO GLOBAL OF UNDEFS .DSABLed
.IIF ne, MACXX&<.pdp11!..mz80>,		GENEDT	CRF	;CREFS, DEF TO .ENABL

	.SBTTL ROLL handler call definitions

	.MACRO	SEARCH	ROLNUM	;BINARY SEARCH
	MOV	#ROLNUM,R0
	CALL	SEARCH
	.ENDM

	.MACRO	SCAN	ROLNUM	;LINEAR SCAN
	MOV	#ROLNUM,R0
	CALL	SCAN
	.ENDM

	.MACRO	SCANW	ROLNUM	;LINEAR SCAN, ONE WORD
	MOV	#ROLNUM,R0
	CALL	SCANW
	.ENDM

	.MACRO	NEXT	ROLNUM	;FETCH NEXT ENTRY
	MOV	#ROLNUM,R0
	CALL	NEXT
	.ENDM

	.MACRO	S.NEXT	ROLNUM	;change search context into next context
	MOV	#ROLNUM,R0
	CALL	S.NEXT
	.ENDM

.IF NE,MACXX&..MZ80
	.MACRO	SAME	ROLNUM=PSTROL	;FETCH NEXT ENTRY (OF SAME OPCODE)
	MOV	#ROLNUM,R0
	CALL	SAME
	.ENDM

.ENDC
	.MACRO	APPEND	ROLNUM	;APPEND TO END OF ROLL
	MOV	#ROLNUM,R0
	CALL	APPEND
	.ENDM

	.MACRO	ZAP	ROLNUM	;CLEAR ROLL
	MOV	#ROLNUM,R0
	CALL	ZAP
	.ENDM

	GENCAL	INSERT		;INSERT (MUST BE PRECEDED BY ONE 
				;OF THE ABOVE TO SET POINTERS)
	GENCAL	DELETE		;DELETE AN ENTRY. (MUST BE PRECEEDED BY
				;ONE OF THE ABOVE TO SET POINTERS)
	GENCAL	SETROL		;SAVE AND SET REGS FOR ABOVE

	.SBTTL Program initialization code

	ENTSEC	XCTPRG		;PROGRAM INITIALIZATION CODE
XCTPRG::
	MOV	#IMPURE,R0
1$:	CLR	(R0)+		;CLEAR IMPURE AREA
	CMP	#IMPURT,R0
	BHI	1$

	ENTSEC	XCTPAS		;PASS INITIALIZATION CODE
XCTPAS::
	MOV	#IMPPAS,R0
2$:	CLR	(R0)+		;CLEAR IMPURE PART
	CMP	#IMPPAT,R0
	BHI	2$

	ENTSEC	XCTLIN		;LINE INITIALIZATION CODE
XCTLIN::
	MOV	#IMPLIN,R0
3$:	CLR	(R0)+
	CMP	#IMPLIT,R0
	BHI	3$

	ENTSEC	IMPURE
IMPURE:
	ENTSEC	IMPPAS
IMPPAS:
	ENTSEC	IMPLIN
IMPLIN:
	XITSEC

	.SBTTL	ASSEMBLER PROPER


;DIRECTIVE FLAGS DEFINED IN PST

	.GLOBL	DFLCND,	DFLMAC,	DFLGEV
	.GLOBL	DFLGBM,	DFLSMC

	.GLOBL	PSTBAS,	PSTTOP,	WRDSYM
.iif df dirrol,	.GLOBL	DIRBAS, DIRTOP

	.SBTTL IMULI Integer multiply immeadiate macro

	.MACRO	IMULI	COUNT,ADDR
	.LIST	MEB
T.VAL=	COUNT

	.IF EQ	T.VAL
	CLR	ADDR
	.IFF
	.IF LT	T.VAL
T.VAL=	-T.VAL
	NEG	ADDR
	.ENDC

T.FLAG=	0
T.MASK=	040000
	.REPT	^D14
	.IF LE	T.MASK-T.VAL
	.IF NE	T.MASK&T.VAL
	.IF NE	T.MASK-T.VAL
	.IF EQ	T.FLAG
	MOV	ADDR,-(SP)
T.FLAG=	1
	.IFF
	.IF NE	T.MASK-1&T.VAL
	ADD	(SP),ADDR
	.IFF
	ADD	(SP)+,ADDR
T.FLAG=	0
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	ASL	ADDR
	.ENDC
T.MASK=	T.MASK/2
	.ENDR
	.IF NE	T.FLAG
	ADD	(SP)+,ADDR
	.ENDC
	.ENDC
	.NLIST	MEB
	.ENDM

	.SBTTL SYMBOL/CLCLOC Variables

	ENTSEC	IMPURE

PASS:	.BLKW
				;NEXT GROUP MUST STAY TOGETHER
	ENTSEC	IMPPAS

SYMBOL::.BLKW	2		;SYMBOL ACCUMULATOR
MODE::
FLAGS::	.BLKB	1		;FLAG BITS
SECTOR::.BLKB	1		;SYMBOL/EXPRESSION TYPE
VALUE::	.BLKW	1		;EXPRESSION VALUE
RELLVL::.BLKW	1
	.REPT	MAXXMT-<<.-SYMBOL>/2>	;END OF GROUPED DATA
	.BLKW
	.ENDR

.IF NE,MACXX&..MZ80
OLDSYM::.BLKW	2		;TEMPORARY SYMNAM SLOT
PSTUPD:	.BLKW	1		;HOLD SLOT FOR CURRENT PSTROL OFFSET
.XXCPU::.BLKW	1		;MODE BIT FOR CURRENT CPU (SET IN SAMCPU)
.ENDC	; MACZ80 ONLY
CLCNAM::.BLKW	2		;CURRENT LOCATION COUNTER SYMBOL
CLCFGS::.BLKB	1
CLCSEC::.BLKB	1
CLCLOC::.BLKW	1
CLCMAX::.BLKW	1

CHRPNT::.BLKW			;CHARACTER POINTER
SYMBEG::.BLKW			;POINTER TO START OF SYMBOL
ENDFLG::.BLKW
	.IF ne,MACXX&..m69

	.GLOBL	DPREG

DPREG:	.BLKW			;DIRECT PAGE POINTER
	.ENDC

	XITSEC			;RETURN TO NORMAL

	.SBTTL ASSEMBLER ENTRY

ASSEM:				;SET SYMBOL TABLES
	CALL	XCTPRG		;CLEAR CORE
	.IF NDF	XMACRO
	BIC	#BPMB-1,SYTTOP	;MACRO STORAGE MUST BE MODULO
	.ENDC
	MOV	#DUMROL,R1	;POINT TO SEPARATOR ROLL
1$:	MOV	SYTTOP,ROLBAS(R1)	;SET BASE
	MOV	SYTTOP,ROLTOP(R1)	;  AND TOP
	CLRB	ROLSIZ+1(R1)	;ZERO CURRENT SIZE
	SUB	#2,R1		;MOVE DOWN A ROLL
	BGE	1$		;LOOP 'TILL ROLL #0
	CALL	CLRLBF		;CLEAR LINE BUFFER
	RETURN

SYINIT:	ZAP	LBNROL		;CLEAR LISTING CONTROL ROLLS
	CLR	R3
	MOV	#$.LSTC,R1	;POINT TO LISTING CONTROLS
5$:	MOV	(R1)+,SYMBOL	;PASS IT TO ROLL UPDATE ROUTINE
	MOV	(R1)+,SYMBOL+2
	APPEND	LBNROL		;BOTH BIN AND BEX GET THE STUFF
	TST	(R1)		;END?
	BNE	5$		;NOPE. KEEP FILLING
	MOV	#$.LST,R2	;POINT TO LISTING CONTROL FIELD
	CALL	XMIT7		;MOVE IN 9 WORDS
	MOV	(R1)+,(R2)+
	MOV	(R1)+,(R2)+
	ZAP	CRFROL		;RESET .CROSS ROLL
.IF ne,MACXX&<.pdp11!..m69!.intel>	; assemblers with register name syntax
	SETXPR			;INIT XPRESSION REGS
	CLR	2(R1)		;ZAP LOWER SYMBOL
.IIF ne,macxx&.pdp11,	CLR	R3		;INIT VALUE
.IIF ne,macxx&..m69,	MOV	#1,R3		;INIT VALUE
	MOV	#RLBLS,R2	;POINT TO REGISTER LABELS
4$:	MOV	(R2)+,(R1) 	;PASS SYMBOL
	BEQ	3$		;DONE
	SSRCH			;SET POINTERS
.iif ne,macxx&.intel,	MOV	(R2)+,(R4)	;SET VALUE
.iif eq,macxx&.intel,	MOV	R3,(R4)		;PASS VALUE
	MOV	#DEFFLG!REGFLG,MODE	;SET MODE
	INSERT			;INSERT IT IN SYMBOL TABLE
.IIF ne,macxx&..m69,	ASL	R3		;NEXT VALUE
.IIF ne,macxx&.pdp11,	INC	R3		;NEXT VALUE
	BR	4$
3$:

	ENTSEC	DPURE
RLBLS:
	.IF ne,macxx&.pdp11
	.RAD50	/R0 /
	.RAD50	/R1 /
	.RAD50	/R2 /
	.RAD50	/R3 /
	.RAD50	/R4 /
	.RAD50	/R5 /
	.RAD50	/SP /
	.RAD50	/PC /
	.endc	;.pdp11
	.if ne,macxx&..m69
	.RAD50	/CCR/
	.RAD50	/A  /
	.RAD50	/B  /
	.RAD50	/DPR/
	.RAD50	/X  /
	.RAD50	/Y  /
	.RAD50	/S  /
	.RAD50	/U  /
	.RAD50	/PC /
	.RAD50	/D  /
	.endc	;..m69
	.if ne,macxx&..m80
	RC.... = 0.	; for filling in table entries
	RC.STD = 256.	; standard registers, <B,C,D,E,H,L,M,A>
	RC.IND = 512.	; indirect register pairs <BC,DE>
	RC.DPS = 1024.	; double reg pairs for std ops <BC,DE,HL,SP>
	RC.STK = 2048.	; double reg pairs for stack ops <BC,DE,HL,PSW>
	.WORD	^RB  ,0!<^C<RC.STD!RC.IND!RC.DPS!RC.STK>&-256.>
	.WORD	^RC  ,1!<^C<RC.STD!RC....!RC....!RC....>&-256.>
	.WORD	^RD  ,2!<^C<RC.STD!RC.IND!RC.DPS!RC.STK>&-256.>
	.WORD	^RE  ,3!<^C<RC.STD!RC....!RC....!RC....>&-256.>
	.WORD	^RH  ,4!<^C<RC.STD!RC....!RC.DPS!RC.STK>&-256.>
	.WORD	^RL  ,5!<^C<RC.STD!RC....!RC....!RC....>&-256.>
	.WORD	^RM  ,6!<^C<RC.STD!RC....!RC....!RC....>&-256.>
	.WORD	^RA  ,7!<^C<RC.STD!RC....!RC....!RC....>&-256.>
	.WORD	^RBC ,0!<^C<RC....!RC.IND!RC.DPS!RC.STK>&-256.>
	.WORD	^RDE ,2!<^C<RC....!RC.IND!RC.DPS!RC.STK>&-256.>
	.WORD	^RHL ,4!<^C<RC....!RC....!RC.DPS!RC.STK>&-256.>
	.WORD	^RSP ,6!<^C<RC....!RC....!RC.DPS!RC....>&-256.>
	.WORD	^RPSW,6!<^C<RC....!RC....!RC....!RC.STK>&-256.>
	.endc	;..m80
	.if ne,macxx&..mz80
	.MACRO	Z80REG RNAME,AM=0,VALUE=0
	.RAD50	/RNAME/
	.WORD	AM!VALUE
	.ENDM

	Z80REG	I	AM.I		; (8080 only, NO VALUE)
	Z80REG	B	AM.RR,0
	Z80REG	C	AM.C,1
	Z80REG	D	AM.RR,2
	Z80REG	E	AM.R,3
	Z80REG	H	AM.H,4
	Z80REG	L	AM.R,5
	Z80REG	M	AM.M,6		; (8080 only)
	Z80REG	A	AM.A,7
	Z80REG	BC	AM.BC,0		; (Z80 only)
	Z80REG	DE	AM.DE,2		; (Z80 only)
	Z80REG	HL	AM.HL,4
	Z80REG	SP	AM.SP,6
	Z80REG	IX	AM.IXY,0	; (Z80 only)
	Z80REG	IY	AM.IXY,1	; (Z80 only)
	Z80REG	AF	AM.AF,6		; (Z80 only)
	Z80REG	PSW	AM.PSW,6	; (8080 only)

	.endc	;..mz80
	.WORD	0
	XITSEC
	.ENDC		; assemblers with register name syntax
	RETURN

	.MACRO	LBNX	ID,LOC,LNTH,RDX
	.BYTE	ID,LOC,LNTH,RDX
	.ENDM

	ENTSEC	DPURE
	.RADIX	10
$.LSTC:
	.IF	eq,MACXX&.pdp11	;DEFAULT TO HEX
	LBNX	0,16,0,16
	LBNX	1,22,0,16
	LBNX	2,28,0,16
	LBNX	3,34,0,16
	.IFF
	LBNX	0,17,0,8	;OCTAL FMT
	LBNX	1,25,0,8
	LBNX	2,33,0,8
	.ENDC
	.WORD	0		;COMMENTS (ALSO TERMINATES ABOVE LIST)
	.WORD	41,41		;SOURCE
	.WORD	3,4,10		;SEQUENCE LOC,LNTH,RDX
	.IF eq,MACXX&.pdp11
	.WORD	10,4,16		;LOCATION COUNTER
	.IFF
	.WORD	9,0,8		;LOCATION COUNTER
	.ENDC

	.RADIX
	ENTSEC	IMPPAS
$.LST:
$.COM:	.BLKW
$.SRC0:	.BLKW
$.SRC1:	.BLKW
$.SEQ:	.BLKW	3
$.LCTR:	.BLKW	3	;LOCATION COUNTER PRINT FIELD

	XITSEC

	.SBTTL PASS1/PASS2 Dispatcher

	.GLOBL	SWT.S
MACP1:				;MACRO PASS 1
	CALL	XCTPAS
	CALL	SYINIT		;RESET SYMBOL TABLES AND LIST ROLLS
	MOV	#LST.KB*400,R0	;SET ERROR SLOT
	TSTB	IOFTBL+LSTCHN	;LISTING DEVICE?
	BEQ	10$		;  NO
	BIS	#LST.KB!100200,R0	;YES, ASSUME TELETYPE
	BIT	#IO.TTY,IOFTBL+LSTCHN	;TRUE?
	BNE	10$		;  YES
	ADD	#<LST.LP-LST.KB>*401,R0	;UPGRADE TO LP
	ADD	#<LST.KB*400>,R0	;ERRORS GO TO TTY TOO.
10$:	MOV	R0,LSTDEV	;SET FLAGS
	CALL	SETHDR		;SET UP HEADER
	BR	MACP2F

MACP2:				;MACRO PASS 2
	CALL	XCTPAS
	CALL	SYINIT		;INIT THE SYMBOL AND LIST ROLLS
.IF ne,MACXX&<..m69!.6502>
	MOV	ROLBAS+SYMROL,R4 ;POINT TO SYMBOL TABLE
	MOV	ROLTOP+SYMROL,R5 ;POINT TO TOP OF TABLE
10$:	CMP	R4,R5		;AT THE LIMIT YET?
	BHIS	MACP2F		;YEP, STOP ZAPPING	
	BIC	#FWDFLG,FLAGS-SYMBOL(R4) ;ZAP PASS 1 DEFINED FLAG
	ADD	#RS.SYM*2,R4	;UP TO NEXT ITEM
	BR	10$		;CONTINUE
	.ENDC
MACP2F:	CALL	SECINI		;INIT THE SECTOR ROLL
10$:	CALL	GETLIN		;GET THE NEXT INPUT LINE
;	BNE	20$		;  BRANCH IF EOF
	CALL	STMNT		;PROCESS THE STATEMENT
20$:	CALL	ENDLIN		;POLISH OFF LINE
	TST	ENDFLG		;END SEEN?
	BEQ	10$		;  NO, CONTINUE
	RETURN

	ENTSEC	DPURE
R50ABS:	.RAD50	/. ABS./
R50DOT:	.RAD50	/.     /
	XITSEC

	.SBTTL GETLIN Input processor

GETLIN:				;GET AN INPUT LINE
	SAVREG
GETL01:	CALL	XCTLIN		;INIT LINE-ORIENTED VARIABLES
	MOV	FFCNT,R0	;ANY RESERVED FF'S?
	BEQ	10$		;  NO
	ADD	R0,PAGNUM	;YES, UPDATE PAGE NUMBER
	MOV	#-1,PAGEXT
	CLR	FFCNT
	.IF NDF	XLCSEQ
	CLR	LINNUM		;INIT NEW CREF SEQUENCE
	CLR	SEQEND
	.ENDC
	TST	PASS
	BEQ	10$
	CLR	LPPCNT
10$:	MOV	#LINBUF,R2
	MOV	R2,LCBEGL	;SEAT UP BEGINNING
	MOV	#LINEND,LCENDL	;  AND END OF LINE MARKERS
	CALL	GETL20		;GET PHYSICAL LINE
	TST	R0		;TEST RESULT
	BLT	GETL01		;RE-TRY IF .LT. 0
	BGT	GETL09		;EXIT IF .GT. 0
				;FALL THROUGH IF .EQ. 0

GETL02:	ADD	R1,R4		;COMPUTE END
10$:	CLRB	(R4)		;FORM ASCIZ
	MOVB	-(R4),R5	;GET LAST CHAR
	CMP	R5,#CR		;IF > CR
	BHI	30$
	CMP	R5,#LF		;  OR < LF
	BLO	30$		;  MOVE ON
	CMP	R5,#FF		;FORM FEED?
	BNE	10$		;  NO, LOOP
	.IF NDF	XSML
	TST	SMLLVL		;SYSTEM MACRO?
	BNE	10$		;  YES, DON'T TALLY FF
	.ENDC
	INC	FFCNT		;COUNT THE PAGE
	BR	10$

20$:	MOVB	R5,(R2)+	;MOVE INTO LINBUF
30$:	MOVB	(R1)+,R5	;FETCH NEXT CHAR
	MOVB	CTTBL(R5),R0	;GET CHARACTERISTICS
	BEQ	50$		;QUESTIONABLE
	BIT	#CT.LC,R0	;LOWER CASE?
	BEQ	20$		;  NO
.IF NDF	XEDLC
	BIT	#ED.LC,EDMASK	;LOWER CASE ENABLED?
	BNE	40$		;  NO, CONVERT TO UPPER
	ADD	#240,R5		;YES, END UP WITH "200 + LC"
.ENDC
40$:	SUB	#40,R5		;CONVERT LOWER TO UPPER CASE
	BR	20$		;STORE

50$:	MOVB	R5,(R2)		;QUESTIONABLE, ASCIZ NULL?
	BEQ	GETL09		;  YES, ALL SET
	ERROR	I		;NO, ILLEGAL CHARACTER
	MOV	#200,R5		;STORE ZERO WITH FLAG BIT
	BR	20$

GETL09:	.IF NDF	XEDCDR
	MOVB	LINBUF+72.,CDRSAV	;SAVE COLUMN 73
	BIT	#ED.CDR,EDMASK	;CARD READER TYPE?
	BNE	10$		;  NO
	CLRB	LINBUF+72.	;YES, FORCE EOL
	.ENDC
10$:	MOV	#LINBUF,CHRPNT
	SETNB
	BNE	20$		;ALL SET IF NON-NULL LINE
	TST	FFCNT		;NULL, FORM FEED?
	BEQ	20$		;  NO
	JMP	GETL01		;YES, JUST BUMP PAGE COUNT

20$:	MOV	ENDFLG,R0	;RETURN WITH "ENDFLG" AS ARGUMENT
	RETURN

GETL20:
	.IF NDF	XSML
	TST	SMLLVL		;PROCESSING SYSTEM MACRO?
	BEQ	20$
	$READW	SML		;YES, READ THE NEXT LINE
	CLR	R0		;ASSUME OK
	BIT	#IO.EOF,IOFTBL+SMLCHN	;EOF?
	BEQ	10$		;  NO
	INC	R0		;YES, SET R0
	BIS	R0,ENDFLG	;  AND END FLAG
10$:	MOV	CNTTBL+SMLCHN,R1	;POINT TO COUNT
	MOV	@R1,R4
	CLR	@R1			;SET STOPPER
	MOV	BUFTBL+SMLCHN,R1	;POINT TO BUFFER
	RETURN
	.ENDC

20$:	.IF NDF	XMACRO
	MOV	MSBMRP,R1	;POINTING TO MACRO?
	BNE	GETL10		;  YES, PROCESS IT
	.ENDC
	CALL	GETPLI		;GET PHYSICAL LINE FROM EXEC
	TST	R0		;NORMAL?
	BLE	30$		;  YES
	ERROR	E		;EOF, ERROR
;	INC	ENDFLG		;FLAG IT
	.IF NDF XLCSEQ
	DEC	LINNUM		;COUNTER ACT THE LINE # INC BELOW.
	.ENDC
	MOV	R2,-(SP)	;SAVE LINE BUFFER @
	MOV	BUFTBL+SRCCHN,R2 ;POINT TO SOURCE BUFFER
	MOV	#.ENDREC,R1	;POINT TO ".END" RECORD
	CALL	MOVBYT		;COPY FAKE .END INTO LINE BUFFER
	MOV	#.ENDLEN,@CNTTBL+SRCCHN ;PASS BACK RECORD LENGTH
	MOV	(SP)+,R2	;RESTORE ADDRESS
	CLR	R0		;PRETEND WE DIDN'T GET EOF
30$:	BIT	#IO.ERR,IOFTBL+SRCCHN	;ERROR?
	BEQ	40$		;  NO
	ERROR	L		;YES, FLAG IT
40$:	MOV	CNTTBL+SRCCHN,R1	;POINT TO COUNT
	MOV	@R1,R4			;GET COUNT
	CLR	@R1			;SET STOPPER
	MOV	BUFTBL+SRCCHN,R1	;POINT TO INPUT BUFFER
	.IF NDF	XLCSEQ
	INC	LINNUM		;INCREMENT LINE COUNT
	.ENDC
	RETURN

	ENTSEC TXTBYT
.ENDREC: .ASCIZ \.END ;<-- Didn't you forget something?\<cr><lf>
.ENDLEN = .-.ENDREC-1
	XITSEC

	.IF NDF	XMACRO
GETL10:	CALL	50$		;MOVE A CHARACTER
	BGT	GETL10		;LOOP IF GT ZERO
	BEQ	40$		;END IF ZERO
	MOVB	-(R2),R0	;TERMINATOR, BACK UP POINTER
	CMP	R0,#MT.MAX	;END OF TYPE?
	BLOS	110$		;  YES
	MOV	R1,-(SP)	;REMEMBER READ POINTER
	MOV	R2,R3		;  AND WRITE POINTER
	MOV	MSBARG,R1	;GET POINTER TO ARG BLOCK
	TST	(R1)+		;SKIP LINK
	NEG	R0		;ASSUME MACRO (R0 > 0)
	CMP	MSBTYP,#MT.MAC	;TRUE?
	BEQ	10$		;  YES, USE IT
	MOV	MSBCNT,R0	;GET ARG NUMBER (REPT COUNT)
10$:	MOV	(R1)+,R3	;GET LINK TO NEXT ARG
	DEC	R0		;COUNT IT
	BLE	20$		;NO MORE
	MOV	R3,R1		;POINT TO NEXT ARG
	BEQ	30$		;NO ARG AVAILABLE
	BR	10$		;CONTINUE.
20$:	CALL	50$		;GET TEXT
	BGT	20$		;CONTINUE UNTIL END OF TEXT
	TSTB	-(R2)		;BACK UP POINTER
30$:	MOV	(SP)+,R1	;RESET READ POINTER
	BR	GETL10		;END OF ARGUMENT SUBSTITUTION

40$:	MOV	R1,MSBMRP	;END OF LINE, SAVE POINTER
	BIS	#LC.ME,LCFLAG	;FLAG AS MACRO EXPANSION
	MOV	#1,R0		;EXIT GETLIN ROUTINE
	RETURN

50$:	BIT	#BPMB-1,R1	;MACRO, END OF BLOCK?
	BNE	60$		;  NO
	MOV	-BPMB(R1),R1	;YES, POINT TO NEXT BLOCK
	TST	(R1)+		;MOVE PAST LINK
60$:	CMP	R2,#LINBUF+SRCLEN	;OVERFLOW?
	BLOS	70$		;  NO
	ERROR	L		;YES, FLAG ERROR
	TSTB	-(R2)		;  AND MOVE POINTER BACK
70$:	MOVB	(R1)+,(R2)+	;GET THE NEXT CHAR
	BLE	100$		;IF ITS 0 OR MINUS, THEN LEAVE IT ALONE
	MOVB	-1(R2),R0	;GET THE CHAR (ALWAYS A + BYTE)
	BITB	CTTBL(R0),#CT.LC ;LOWER CASE?
	BEQ	90$		;  NO
.IF NDF	XEDLC
	BIT	#ED.LC,EDMASK	;LOWER CASE ENABLED?
	BNE	80$		;  NO, CONVERT TO UPPER
	ADD	#240,R0		;YES, END UP WITH "200 + LC"
.ENDC
80$:	SUB	#40,R0		;CONVERT LOWER TO UPPER CASE
	MOVB	R0,-1(R2)	;PASS CHAR
90$:	CCC			;BE SURE N AND Z ARE CLEAR
100$:	RETURN

110$:	CALL	ENDMAC		;CLOSE MACRO
	MOV	#-1,R0		;RE-PROCESS LINE
	RETURN
	.ENDC

	ENTSEC	IMPPAS
LPPCNT:	.BLKW	1		;FORCE NEW PAGE WHEN NEGATIVE
FFCNT:	.BLKW	1		;UNPROCESSED FF COUNT
PAGNUM:	.BLKW	1		;PAGE NUMBER
PAGEXT:	.BLKW	1		;PAGE NUMBER EXTENSION
	.IF NDF	XLCSEQ
LINNUM:	.BLKW	2		;CREF LINE NUMBER
SEQEND:	.BLKW	1
	.ENDC
SRCCNT:	.BLKW	2		;TOTAL  STATEMENT COUNTER

	XITSEC

	.SBTTL ENDLIN End of line processor

	.GLOBL	ENDLIN,SRCCNT

ENDLIN:				;END OF LINE PROCESSOR
	SAVREG
	SEC
	ADC	SRCCNT		;COUNT TOTAL  TIMES THRU HERE
	ADC	SRCCNT+2
	CLR	ROLUPD		;SET TO FETCH FROM CODE ROLL
	TSTB	CTTBL(R5)	;EOL OR SEMI-COLON?
	BLE	10$		;  YES
	ERROR	Q
10$:	.IF NDF	XEDCDR
	MOVB	CDRSAV,LINBUF+72.	;REPLACE BORROWED CHAR
	.ENDC
	MOV	PASS,-(SP)	;PASS 1?
	BEQ	80$		;  YES
	MOV	LSTDEV,(SP)	;INIT LISTING FLAG
	MOV	ERRBTS,SERRS	;ANY ERRORS?
	BNE	60$		;  YES, GO DIRECTLY, DO NOT COLLECT, ETC.
	TSTB	(SP)		;ANY LISTING DEVICE?
	BEQ	80$		;  NO
	BIT	#LC.LD,LCFLAG	;LISTING DIRECTIVE?
	BNE	50$		;  YES
	TST	LCLVL		;TEST OVER-UNDER RIDE
	BLT	50$		;IF <0, LIST ONLY IF ERRORS
	BGT	70$		;IF >0, LIST UNCONDITIONALLY
	BIT	#LC.COM,LCMASK	;COMMENT SUPPRESSION?
	BEQ	20$		;  NO
	MOV	CHRPNT,LCENDL	;YES, ASSUME WE'RE SITTING AT COMMENT
20$:	BIT	#LC.SRC,LCMASK	;LINE SUPPRESSION?
	BEQ	30$		;  NO
	MOV	#LINBUF,LCENDL	;YES, POINT TO START OF BUFFER
30$:
	.IF NDF	XMACRO
	TSTB	ROLSIZ+CODROL+1	;ANYTHING IN CODE ROLL?
	BEQ	40$		;  NO
	BIT	#LC.MEB,LCMASK	;MACRO BINARY EXPANSION?
	BNE	40$		;  NO
	BIC	#LC.ME,LCFLAG	;YES, IGNORE ME FLAG
	.ENDC
40$:	BIT	LCMASK,LCFLAG	;ANYTHING SUPPRESSED?
	BEQ	80$		;  NO, USE CURRENT FLAGS
50$:	CLR	(SP)		;YES, CLEAR LISTING MODE
	BR	80$

60$:	SWAB	(SP)		;ERROR, SET TO ERROR MODE
	.IF NDF	XLCSEQ
	.IF NDF	XLCTTM
	BIT	#LC.TTM,LCMASK	;TELETYPE MODE?
	BNE	70$		;  NO, BYPASS EXTRA LINE
	.ENDC
	CALL	FLIQUE		;FLUSH THE QUE
	MOV	#STARS,R1	;"******"
	MOV	#OCTBUF,R2
	MOVBYT			;MOVE INTO OCTAL BUFFER
	MOVB	#SPACE,(R2)+
	CALL	TSTERR		;SET ERRORS
	CLRB	(R2)		;FORM ASCIZ
	MOVB	(SP),LSTREQ
	PUTLIN	#OCTBUF		;DRAW THE USER'S ATTENTION
	.ENDC
70$:	MOV	#LINBUF,LCBEGL	;LIST ENTIRE LINE
	MOV	#LINEND,LCENDL
80$:	CALL	PCROLL		;PROCESS ENTRY ON CODE ROLL

	ENTSEC	IMPLIN
SERRS:	.BLKW
	XITSEC

ENDL10:	MOVB	(SP),LSTREQ	;ANYTHING REQUESTED?
	BEQ	ENDL20		;  NO
	CLRB	@LCENDL		;SET ASCIZ TERMINATOR
	TST	LCLVL		;.LIST > 0?
	BGT	10$		;YES. GIVE 'EM  EVERYTHING
	BIT	#LC.BYT,LCMASK+2	;QUE'D LINES?
	BEQ	10$		;NO. CONTINUE
	TST	SERRS		;ANY ERRORS?
	BNE	10$		;YES. GIVE 'EM EVERYTHING
	TST	MACLVL		;IN A MACRO?
	BNE	ENDL40		;YES.  DO SPECIAL PROCESSING.
10$:	CALL	FLIQUE		;FLUSH  THE LINE QUE
	CALL	E.SEQ		;PUT IN SEQUENCE #
	MOV	#OCTBUF,R2	;POINT TO LINE BUFFER
	CALL	TSTERR		;PUT  IN ERRORS
	CALL	E.LOC		;PUT IN LOCATION COUNTER
	CALL	E.SRC		;PUT IN SOURCE
	CLR	LFMT		;0 => FORMAT POINTER
20$:	TST	PF1		;ANYTHING TO PRINT?
	BEQ	40$		;NOPE. JUST EXIT
30$:	CALL	E.LBN		;UNPACK OBJECT CODE
	BEQ	50$		;NO FORMAT
	INC	LFMT		;NEXT FORMAT
	CALL	PCROLL		;GET NEXT ENTRY FROM CODROLL
	BNE	20$		;STUFF LEFT
40$:	PUTLIN	#OCTBUF		;PRINT LINE
	CALL	CLRLBF		;ZAP LINE BUFFER
	BR	ENDL30		;TIDY UP AND EXIT
50$:	PUTLIN	#OCTBUF		;PRINT LINE
	CALL	CLRLBF		;CLEAR ALL
	BIT	#LC.BEX,LCMASK	;SUPPRESS BEX?
	BNE	ENDL20		;YES. JUST EXIT
	CLRB	(R0)		;ZAP SOURCE
	CALL	E.LOC		;UNPACK LOCATION FIELD
	CLR	LFMT		;RESET FORMAT
	MOVB	(SP),LSTREQ	;RESTORE LIST CONTROL
	BR	30$		;CONTINUE
	.PAGE
ENDL30:	TST	(SP)+		;PRUNE LISTING FLAG
	ZAP	CODROL		;CLEAR THE CODE ROLL
	MOV	CLCLOC,R0
	.IF DF	YPHASE
	SUB	PHAOFF,R0
	.ENDC
	.IF eq,MACXX&.pdp11
	TST	VCTFLG		;WAS THIS LINE A '.VCTRS'?
	BNE	20$		;YEP. IGNORE LIMIT TEST
	.IFTF
	CMP	R0,CLCMAX	;NEW HIGH FOR SECTOR?
	BLOS	10$		;  NO.
	MOV	R0,CLCMAX	;YES, SET IT
10$:	RETURN
	.IFT
20$:	CLR	VCTFLG
	MOV	#CLCNAM,R2
	MOV	#CLCSAV,R1
	JMP	XMIT5		;RESTORE CLC STUFF AND EXIT

	ENTSEC	IMPURE
VCTFLG:	.BLKW	1		;FLAG TO INDICATE .VCTRS STATMENT
CLCSAV:	.BLKW	5		;SAVE SPACE FOR OLD CLCLOC
	XITSEC
	.ENDC

ENDL20:	TST	ROLUPD		;ANY OBJECT?
	BEQ	ENDL30		;NO. EXIT
	CALL	PCROLL		;PROCESS OBJECT
	BNE	ENDL20		;CONTINUE
	BR	ENDL30		;EXIT

ENDL40:	CMP	LINNUM,LINNUM+2	;LINE #'S MATCH?
	BEQ	20$		;YES. IGNORE SOURCE
	CALL	FLIQUE		;DUMP PREVIOUS LINE
	CALL	E.SEQ		;UNPACK SEQUENCE #
	MOV	#LINQUE,R2	;QUE SOURCE FOR LATER
	MOV	LCBEGL,R1
	MOV	CHRPNT,R0
	SUB	#LINBUF,R0
	ADD	R2,R0
	MOV	R0,E.COME	;SAVE POINTER TO COMMENTS FIELD
10$:	MOVB	(R1)+,(R2)+	;QUE SOURCE
	BNE	10$
	MOV	LSTREQ,E.LRQ	;PASS ENTRY REQ FLAGS
20$:	MOV	SP,E.QUE	;SET QUE NOT EMPTY
30$:	TST	ROLUPD		;ANY OBJECT CODE?
	BEQ	ENDL30		;NO. JUST EXIT
	MOV	E.QF,LFMT	;GET FORMAT #
	BNE	40$		;NOT THE FIRST
	CALL	E.LOC		;PUT IN LOCATION COUNTER
	BR	60$
40$:	MOVB	E.CLC+1,R0	;DO CLC TEST. GET SECTOR
	MOVB	PF0+1,R1	;GET CURRENT SECTOR
	SUB	R1,R0		;COMPARE
	BIC	#-64.,R0	;MATCH?
	BNE	50$		;NOPE
	CMP	PF0+2,E.CLC+2	;VALUES MATCH?
	BEQ	60$		;YES.
50$:	BIT	#LC.BIN,LCMASK	;BINARY SUPPRESSED?
	BNE	60$		;YES
	CALL	FLIQUE		;NO. FLUSH CURRENT QUE
	BR	20$		;AND CONTINUE
60$:	MOV	CLCFGS,E.CLC	;COPY UPDATED PC TO SAVE AREA
	MOV	CLCLOC,E.CLC+2
	CALL	E.LBN		;UNPACK BINARY
	BNE	70$		;ROLL NOT EMPTY.
	TST	LFMT		;ROL EMPTY?
	BEQ	80$		;YES. JUST DUMP CODROL
	BR	50$		;CONTINUE
70$:	INC	E.QF		;UPDATE THIS FOR NEXT TIME
	INC	LFMT		;AND THIS FOR THIS TIME
80$:	CALL	PCROLL		;GET NEXT BINARY
	BNE	40$		;CONTINUE
	BR	ENDL30		;EXIT
	.PAGE
FLIQUE:	TST	E.QUE		;ALREADY EMPTY?
	BEQ	20$		;YES. JUST EXIT
	MOV	R1,-(SP)	;SAVE SOME STUFF
	MOV	LSTREQ,-(SP)
	MOV	LPPCNT,-(SP)
	MOVB	E.LRQ,LSTREQ
	MOV	E.LPP,LPPCNT
	MOV	CHRPNT,-(SP)	;SAVE COMMENTS POINTER
	MOV	E.COME,CHRPNT	;POINT TO COMMENTS IN LINE QUE
	CALL	E.SRCQ		;UNPACK QUE'D SOURCE
	MOV	(SP)+,CHRPNT	;RESTORE CURRENT POINTER
	CLRB	LINQUE		;ZAP QUE'D SOURCE IN CASE OF RE-ENTRY
	PUTLIN	#OCTBUF		;PRINT BUFFER
	TST	(SP)+		;TOP OF FORM REQUESTED?
	BNE	10$		;NOPE
	TST	E.LPP		;DID WE PASS TOP  OF FORM?
	BEQ	10$		;YES.
	CLR	LPPCNT		;RESET THIS
10$:	MOV	(SP)+,LSTREQ	;RESTORE THIS
	MOV	(SP)+,R1	;RESTORE R1
20$:	CALL	CLRLBF		;EMPTY LISTING BUFFER
	CLR	E.QF		;RESET FORMAT #
	CLR	E.QUE		;SET QUE EMPTY
	MOV	LPPCNT,E.LPP	;SAVE A COPY OF THIS FOR NEXT TIME
	RETURN			;EXIT

CLRLBF:	MOV	#OCTBUF,R0
10$:	MOV	#SPACE*400+SPACE,(R0)+
	CMP	R0,#LINBUF	;END?
	BLO	10$		;CONTINUE
	RETURN
	.PAGE
E.SEQ:	BIT	#LC.SEQ,LCMASK	;LIST SEQ #?
	BNE	10$		;NOPE
	MOV	#LINNUM,R1	;POINT TO LINE NUMBER  STUFF
	MOV	(R1)+,R0	;GET CURRENT LINE NUMBER
	CMP	R0,(R1)		;MATCH PREVIOUS ONE?
	BEQ	10$		;YEP. DON'T PRINT
	MOV	R0,(R1)		;ELSE REMEMBER IT
	MOV	#$.SGN,R1	;POINT TO PARAMETER FIELD
	MOV	#$.SEQ+4,R2	;POINT TO ARGUMENTS
	CLR	(R1)		;NO SIGN
	MOV	#-1,-(R1)	;SUPPRESS LEADING ZEROES
	MOV	(R2),-(R1)	;PASS RADIX
	MOV	-(R2),-(R1)	;PASS LENGTH
	MOV	-(R2),R2	;GET LOCATION
	ADD	#OCTBUF-1,R2	;INDEX INTO LINE BUFFER
	MOV	#PF2+2,R1	;POINT TO WORK SPACE
	MOV	R0,(R1)		;PASS VALUE
	CLR	-(R1)		;SET WORD MODE
	CALL	SETWRD		;PRINT IT
	MOV	CPYLVL,R0	;'INCLUDE' INDICATION
	MOVB	INCCHR(R0),(R2)	;PASS INDICATOR
10$:	RETURN			;EXIT

	ENTSEC	TXTBYT
INCCHR:	.ASCII	/ +#%$&@/
	XITSEC

E.LOC:	BIT	#LC.LOC,LCMASK	;LIST LOCATION FIELD?
	BNE	10$		;NOPE
	MOV	#PF0,R1		;POINT TO LOCATION FIELD STUFF
	TST	(R1)		;ANYTHING TO PRINT?
	BEQ	10$		;NO. JUST EXIT
	MOV	#$.LCTR,R0	;POINT TO LOC CTR FIELD DEFINITIONS
	MOV	(R0)+,R2	;GET LOCATION
	ADD	#OCTBUF-1,R2
	MOV	#$.LNTH,R1	;POINT TO SETWRD PARAMETER SPACE
	MOV	(R0)+,(R1)+	;SET LENGTH
	MOV	(R0)+,(R1)+	;SET RADIX
	CLR	(R1)		;DON'T SUPPRESS LEADING ZEROES
	MOV	#PF0,R1		;RESET POINTER
	CALL	SETWRD		;PRINT IT
10$:	RETURN
	.PAGE
	.ENABL	LSB
E.LBN::	MOV	#LBNROL,R0
	BIT	#LC.BIN,LCMASK	;BINARY SUPPRESSED?
	BEQ	20$		;NO. PROCEED
10$:	MOV	SP,R0		;SET NON-ZERO EXIT
	RETURN
20$:	TST	PF1		;ANYTHING TO PRINT?
	BEQ	10$		;NO. JUST EXIT
30$:	MOV	ROLBAS(R0),R1	;GET BASE

40$:	CMPB	LFMT,(R1)	;MATCH?
	BEQ	50$		;YES, R1=ADDRESS OF PRINT CONTROL BYTES
	ADD	#RS.LBN*2,R1	;BUMP TO NEXT ENTRY
	CMP	R1,ROLTOP(R0)	;AT LIMIT?
	BLO	40$		;NOPE, KEEP LOOKING
	CLR	R0		;YES, EXIT .EQ.
	RETURN

50$:	INC	R1		;SKIP ID BYTE
	CLR	R2		;GET LOCATION
	BISB	(R1)+,R2
	BEQ	10$		;NO LOCATION DATA. SKIP IT
	ADD	#OCTBUF-1,R2	;COMPUTE SPOT IN LINE BUFFER
	MOVB	(R1)+,$.LNTH	;PASS LENGTH CODE
	MOVB	(R1),R0		;GET RADIX, LZS AND SIGN BITS
	MOV	R0,R1		;A COPY TO R1
	BIC	#-32.,R0	;ZAP ALL  BUT RADIX BITS
	MOV	R0,$.RDX	;PASS THEM
	MOV	R1,$.LZS	;LEADING ZERO SUPPRESS CODE
	ASLB	R1		;GET SIGN BIT
	MOVB	R1,R1		;SXT IT
	MOV	R1,$.SGN	;PASS IT
	MOV	#PF1,R1		;SET R1
	CALL	SETWDB		;PRINT IT
	MOV	(R1),R0
	BIT	#37400+CPXFLG!RELFLG!GLBFLG,R0	;RELATIVE OR GLOBAL?
	BEQ	10$		;NOPE
	MOVB	#'X,(R2)	;SUFFIX A 'X' FOR COMPLEX
	BIT	#CPXFLG,(R1)	;COMPLEX?
	BNE	10$		;YES
	MOVB	#'',(R2)	;SUFFIX A ' FOR RELATIVE
	BIT	#GLBFLG,(R1)	;GLOBL?
	BEQ	10$		;NOPE
	MOVB	#'G,(R2)	;YEP. SUFFIX A 'G'
.IF df,dfgflg
	BIT	#DFGFLG,(R1)	;AUTO GLOBAL?
	BEQ	10$		;NOPE
	MOVB	#'E,(R2)	;YEP, INDICATE EXTERNAL GLOBAL
.endc
	BR	10$		;CONTINUE
	.DSABL	LSB

	.PAGE
	.ENABL	LSB
E.SRCQ:	MOV	#LINQUE,R1
	BR	10$
E.SRC:	MOV	LCBEGL,R1
10$:	MOV	R3,-(SP)	;SAVE R3
	BIT	#LC.SRC,LCMASK	;.NLIST SRC?
	BNE	90$		;YES
	MOV	$.SRC0,R2	;GET SOURCE TARGET
	ADD	#OCTBUF-1,R2	;POINT TO SOURCE LOCATION
	MOV	R2,R3		;INIT R3 FOR LATER
	CMPB	#73,(R1)	;SEMI-COLON?
	BEQ	70$		;YES. WHOLE LINE IS COMMENT
20$:	CLR	R0		;TAB INDEX
30$:	MOVB	(R1)+,R5	;GET A SOURCE BYTE
	BEQ	50$		;EOL
	CMP	R1,CHRPNT	;AT COMMENTS?
	BHI	60$		;YES
	CMP	R5,#TAB		;TAB CODE?
	BNE	40$		;NOPE
	ADD	#8.,R2		;COMPUTE R2=R2+8-R0
	BIC	#-8.,R0		;TAB COUNT MODULO 8
	SUB	R0,R2
	BR	20$
40$:	INC	R0		;TAB IT
50$:	MOVB	R5,(R2)+	;PASS BYTE
	BEQ	90$		;EOL. EXIT
	MOV	R2,R3		;KEEP R3 UPDATED
	BR	30$
60$:	DEC	R1		;BACK UP
	MOV	$.COM,R0	;POINT TO WHERE COMMENTS MUST GO
	BEQ	70$		;LEAVE THEM WHERE THEY ARE
	ADD	#OCTBUF-1,R0
	MOV	R3,R2		;USE OLD R2
	CMP	R0,R2		;ARE WE ALREADY INTO COMMENTS FIELD?
	BLOS	70$		;YES. LEAVE THEM AS THEY ARE
	MOV	R0,R2		;ELSE MOVE COMMENTS
70$:	CMP	R2,#LINBUF-1	;CAN'T OVERRUN SOURCE LINE
	BLO	80$		;ITS OK
	CLRB	(R1)		;TERMINATE LINE
80$:	MOVB	(R1)+,(R2)+	;COPY COMMENTS
	BNE	70$
90$:	MOV	$.SRC1,$.SRC0	;PASS QUE POINTER
	MOV	(SP)+,R3	;RESTORE R3
	RETURN
	.DSABL	LSB
	.PAGE
TSTERR:				;TEST AND PROCESS ERRORS
	MOV	ERRBTS,R0	;ANY ERRORS?
	BEQ	TSTER9		;  NO
	ENTOVR	9
	BIT	#ERR.,R0	;YES, ".PRINT"?
	BEQ	10$		;NO W ERRORS ANYWAY
	INC	WRNCNT		;BUMP WARNING COUNT
	BR	20$
10$:	INC	ERRCNT		;BUMP ERROR COUNT
20$:	MOV	#ERRMNE-1,R1
30$:	TSTB	(R1)+		;MOVE CHAR PNTR AND CLEAR CARRY
	ROR	ERRBTS		;ROTATE ERROR BITS
	BCC	40$
	MOVB	(R1),(R2)+
	.IF NDF	XCREF
	MOVB	(R1),R0		;FETCH CHARACTER
	TSTR50			;CONVERT TO RAD50
	CALL	MULR50		;LEFT JUSTIFY
	CALL	MULR50
	MOV	R0,SYMBOL	;STORE
	CLR	SYMBOL+2
	MOV	#ERRROL,ROLNDX	;PREPARE TO CREF
	CRFREF			;DO SO
	.ENDC
	BR	30$

40$:	BNE	30$
	XITOVR	INLINE
TSTER9:	RETURN

	ENTSEC	IMPURE
ERRCNT:	.BLKW			;ERROR COUNTER
WRNCNT:	.BLKW			;WARNING COUNTER

	ENTSEC	IMPLIN
ERRBTS:	.BLKW			;ERROR FLAGS
	XITSEC

	.IF NDF	XEDCDR
	ENTSEC	IMPURE
CDRSAV:	.BLKW			;SAVED CHAR FROM CARD FORMAT
	.ENDC

	ENTSEC	IMPURE

OCTBUF:
	.BLKB	OCTLEN+LINLEN
LINBUF:	.BLKW	LINLEN/2
LINEND:	.BLKW	1
LINQUE::.BLKB	LINLEN

E.QUE:	.BLKW			;LINE QUE ACTIVE
E.COME:	.BLKW
E.LPP:	.BLKW
E.LRQ:	.BLKW
E.CLC:	.BLKW 2
E.QF:	.BLKW
	ENTSEC	IMPLIN
LFMT:	.BLKW
	XITSEC

	.SBTTL	STATEMENT PROCESSOR
	.ENABL LSB

STMNT:
	TST	CNDWRD		;IN CONDITIONAL?
	BNE	70$		;  YES, BRANCH IF SUPPRESSED
	GETSYM
	BEQ	40$
	CMP	R5,#CH.COL	; ":"
	BEQ	LABEL
	CMP	R5,#CH.EQU	; "="
	BNE	10$		;  NO
	JMP	ASGMT		;YES, PROCESS IT

10$:	.IF NDF	XMACRO
	MSRCH
	BEQ	20$
	CRFREF
	JMP	MACROC		;MACRO CALL
	.ENDC

20$:	OSRCH
	BEQ	60$
.if ne macxx&..mz80
	TSTB	MODE		; DIRECTIVE?
	BPL	28$		; YES, SO IT MUST BE VALID.
	CALL	SAMCPU		; MAKE SURE IT IS FOR THE CURRENT CPU
	BEQ	60$		; NO ENTRIES FOR THIS CPU
28$:				; NOW CONTINUE WITH THE "NORMAL" THING
.endc	; z80 (.vs. 8080)
	CRFREF
30$:	JMP	PROPC		;PROCESS OP CODE

40$:
.IF NDF	XEDLSB
	MOV	#10.,R2		;NOT SYMBOL, PERHAPS LOCAL SYMBOL?
	CVTNUM
	BEQ	60$		;  NO
	CMP	R5,#CH.DOL	;NUMBER, TERMINATED BY "$"?
	BNE	60$		;  NO
	GETNB
	CMP	R5,#CH.COL
	BNE	60$
.IF NDF	RSX11D
;.IF	ne,MACXX&.pdp11
;	MOV	CLCLOC,R0
;	SUB	LSYBAS,R0	;COMPUTE LOCAL OFFSET
;	BIT	#177400,R0	;IN RANGE
;	BEQ	50$		;  YES
;	ERROR	A		;NO, ERROR
;.ENDC
50$:	LSRCH			;YES, DO A LOCAL SYMBOL SEARCH
	BR	LABELF		;EXIT THROUGH LABEL PROCESSOR
.ENDC
.ENDC

60$:	SETSYM			;RESET CHAR POINTER AND FLAGS
	TSTB	CTTBL(R5)
	BLE	100$		;NULL IF END OF LINE
FAKWRD:	MOV	#WRDSYM,R1	;NEITHER, FUDGE ".WORD" DIRECTIVE
FAKBYT:	MOV	#SYMBOL,R2
	CALL	XMIT4		;MOVE PST ENTRY TO "SYMBOL"
	BR	30$

70$:	CALL	SETCLI		;UNSAT CONDITIONAL, TEST DIRECTIVE
	BMI	90$		;  BRANCH IF EOF
	BIT	#DFLEND,R0	;.END DIRECTIVE?
	BEQ	80$		;NOPE
	CLR	CNDLVL		;ZAP CONDITIONAL LEVEL
	CLR	CNDWRD		;AND CURRENT CODITIONAL MASK
	ERROR	P		;SAY THERE'S AN IMBALANCE IN .ENDC'S
	JMP	PROPC		;GO BACK AND PROCESS STATEMENT

80$:	BIT	#DFLCND,R0	;CONDITIONAL?
	BNE	30$		;  YES, PROCESS IT
	BIS	#LC.CND,LCFLAG	;MARK AS UNSAT CONDITIONAL
90$:	CLR	R5
100$:	RETURN			;IGNORE LINE

	.DSABL LSB
	.GLOBL FAKWRD

SETCLI:
	ENTOVR	5
10$:	GETSYM			;TRY FOR SYMBOL
.IF NDF	XEDLSB
	BNE	30$		;BRANCH IF FOUND
	BITB	#CT.NUM,CTTBL(R5)	;PERHAPS A LOCAL?
	BEQ	50$		;  NO
20$:	GETCHR			;PERHAPS, TEST NEXT
	BITB	#CT.ALP!CT.NUM,CTTBL(R5)	;ALPHA/NUMERIC?
	BNE	20$		;  YES, TRY AGAIN
	SETNB			;NO, BYPASS ANY BLANKS
.IFF
	BEQ	50$		;  EXIT IF NO SYMBOL
.ENDC
30$:	CMP	R5,#CH.EQU	;ASSIGNMENT (=)?
	BEQ	50$		;  YES, IGNORE THIS LINE
	CMP	R5,#CH.COL	;LABEL (:)?
	BNE	40$		;  NO
	GETNB			;YES, BYPASS COLON
	BR	10$		;  AND CONTINUE

40$:	OSRCH			;TRY FOR OP-CODE
	MOV	MODE,R0		;MODE TO R0
	BPL	60$		;BRANCH IF DIRECTIVE
50$:	CLR	R0		;FALSE
60$:	RETURN

	XITOVR

LABEL:				;LABEL PROCESSOR
	.ENABL	LSB
	CMP	SYMBOL,R50DOT	;PERIOD?
	BEQ	90$		;  YES, ERROR
.IF NDF	XEDLSB
	CALL	LSBSET		;FLAG START OF NEW LOCAL SYMBOL BLOCK
.ENDC
	SSRCH			;NO, SEARCH THE SYMBOL TABLE
	CRFDEF
LABELF:	SETXPR			;SET EXPRESSION REGISTERS
	GETNB			;BYPASS COLON
	CMP	R5,#CH.COL
	BNE	10$
	BIS	#GLBFLG,(R3)	;SET GLOBAL
	GETNB
10$:
	BIT	#DEFFLG,(R3)	;ALREADY DEFINED?
	BNE	30$		;  YES
	MOV	CLCFGS,R0	;NO, GET CURRENT LOCATION FLAGS & SECTOR
.IF ne,MACXX&.pdp11
	BIC	#^C<RELFLG>&377,R0	;CLEAR ALL BUT REL FLAG
	BIS	#DEFFLG!LBLFLG,R0	;FLAG AS LABEL
.IFF
	BIC	#^C<RELFLG!BSEFLG>&377,R0	;CLEAR ALL BUT BSE AND REL
.IF eq,MACXX&<..m69!.6502>
	BNE	20$			;.CSECT OR .BSECT
	TSTB	CLCLOC+1		;.ASECT
	BNE	20$			;BUT OUT OF RANGE
	BIS	#BSEFLG,R0		;SET BASE PAGE ADDRESS
20$:	BIS	#DEFFLG!LBLFLG,R0	;FLAG AS LABEL
.IFF
	BIS	#DEFFLG!LBLFLG!FWDFLG,R0 ;FLAG AS LABEL,DEFINED PASS 1
.ENDC
.ENDC
	BIS	R0,(R3)		;SET MODE
	MOV	CLCLOC,(R4)	;  AND CURRENT LOCATION
	BR	80$		;INSERT

30$:	BIT	#LBLFLG,(R3)	;DEFINED, AS LABEL?
	BEQ	50$		;NO
	CMP	CLCLOC,(R4)	;HAS ANYBODY MOVED?
	BNE	40$		;  YES
	CMPB	CLCSEC,(R2)	;SAME SECTOR?
	BEQ	60$		;  YES, OK
40$:	TST	PASS		;IS THIS PASS ONE?
	BEQ	50$		;YES, TRUE MULTIPLE DEFINITION
	BIT	#MDFFLG,(R3)	;DID PASS 1 FIND MULTIPLE DEFINITION?
	BNE	70$		;YES,GIVE M ERROR
	ERROR	P		;NO ,IT IS A PHASE ERROR
	BR	80$		;DON'T SAY M ERROR

50$:	BIS	#MDFFLG,(R3)	;AND SET TO MULTIPLY DEFINED
60$:	BIT	#MDFFLG,(R3)	;TEST IF MULTIPLY DEFINED
	BEQ	80$
70$:	ERROR	M		;SET M ERROR IF SO
80$:
.IF ne,MACXX&<..m69!.6502>
	BIS	#FWDFLG,FLAGS	;MAKE SURE THE PASS 1 FLAG IS SET
.ENDC
	INSERT			;INSERT/UPDATE
	SETPF0			;BE SURE TO PRINT LOCATION FIELD
	BR	100$

90$:	ERROR	Q
100$:	MOV	CHRPNT,LBLEND	;MARK END OF LABEL
.IF DF	RSX11D
	CLR	DFGTMP
	ENTSEC	IMPURE
DFGTMP:	.BLKW
	XITSEC
.ENDC
	JMP	STMNT		;TRY FOR MORE

	.DSABL	LSB

	.SBTTL	ASSIGNMENT PROCESSOR

ASGMT:
	ENTOVR	2
	GETNB			;BYPASS "="
	CLR	-(SP)		;GET SOME SPACE FOR FLAGS
	CMP	R5,#CH.EQU	;DOUBLE =?
	BNE	10$		;NO
.IF DF RSX11D
	BIS	#DFGFLG,DFGTMP
.IFTF
	BIS	#GLBFLG,(SP)	;YES, SET GLOBAL FLAG
	GETNB			;SKIP OVER SECOND =
10$:
	MOV	#SYMBOL+4,R1	;SET MIX-MASTER REGISTER
	MOV	-(R1),-(SP)	;STACK SYMBOL
	MOV	-(R1),-(SP)
	RELEXP			;GET NON-EXTERNAL EXPRESSION
	MOV	(SP)+,(R1)+	;RESTORE SYMBOL
	MOV	(SP)+,(R1)+
	BIS	(SP)+,MODE	;SET GLOBAL MODE AND PURGE STACK
	BIT	#ERR.U,ERRBTS	;ANY UNDEFINED'S?
	BNE	ASGMTX		;  YES, DON'T DEFINE
ASGMTF:	SETXPR			;SET EXPRESSION REGISTERS
	SETPF1			;SET LISTING FIELD
	bic	#glbflg,pf1	;reset the global flag
	BIT	#ERR.A,ERRBTS	;ANY ADDRESSING ERRORS?
	BNE	ASGMTX		;YES
.IF ne,MACXX&<..m69!.6502>
	BIS	#DEFFLG!FWDFLG,(R3)	;FLAG IT DEFINED
.IFF
	BIS	#DEFFLG,(R3)	;FLAG AS DEFINED
.ENDC
	MOV	(R3),-(SP)	;STACK MODE
	MOV	(R4),-(SP)	;STACK VALUE
	SSRCH			;SEARCH SYMBOL TABLE
	MOV	(SP)+,(R4)	;RESTORE VALUE
.IFT
	BIT	#DFGFLG,(R3)
	BEQ	10$
	BIC	#DFGFLG!GLBFLG,(R3)
10$:
.IFTF
	BIC	#^C<GLBFLG>,(R3)	;ZAP ALL BUT GLOBAL FLAG
	BIS	(SP)+,(R3)	;GIVE IT NEW CHARACTERISTICS
	CMP	(R1),R50DOT	;MESSING WITH THE PC?
	BEQ	20$		;  YES
.IFT
	BIS	#DFGFLG,(R3)
.IFTF
	INSERT			;INSERT NEW VALUE
	BR	ASGMTX

20$:	CMPB	(R2),CLCSEC	;SAME SECTOR?
	BEQ	30$		;YEP, OK AS IS
	MOV	(R3),R0		;GET EXPRESSION'S FLAGS
	BIS	CLCFGS,R0	;MIX THEM
	BIT	#RELFLG,R0	;ARE THEY BOTH ABS?
	BNE	40$		;NOPE, ERROR
	BIT	#CSTALO,CLCFGS	;IS THIS SECTION ABS,OVR?
	BEQ	40$		;NOPE, CAN'T DO THIS THEN
30$:	MOV	(R4),CLCLOC	;YES, SET NEW LOCATION
	BR	ASGMTX

40$:	ERROR	M
ASGMTX:	CRFDEF
.IFT
	CLR	DFGTMP
.ENDC
	RETURN

	XITOVR

	.SBTTL	OP CODE PROCESSOR

	.MACRO	PUSH ARG
	.IRP	XX,<ARG>
	MOV	XX,-(SP)
	.ENDR
	.ENDM

	.MACRO	PULL ARG
	.IRP	XX,<ARG>
	MOV	(SP)+,XX
	.ENDR
	.ENDM

PROPC:				;PROCESS OP CODE
.IF eq,MACXX&.pdp11
	MOV	#MODE,R4	;POINT TO MODE
	MOV	(R4),R1		;LEAVE RESULT IN R1
	CLRB	CRFDFL+1	;CLEAR CREF MARKERS
	CLR	(R4)+		;RESET
	PUSH	R1		;BUT SAVE IT ON STACK
	MOV	#CLCLOC,R2	;POINT R2 TO LOCATION COUNTER
10$:	TST	R1		;OPCODE?
	BPL	20$		;NO. MUST BE DIRECTIVE.
	JMP	OPCODE		;EXIT TO OPCODE PROCESSOR
20$:	BIT	#DFLGBM,R1	;BYTE MODE DIRECTIVE?
	BEQ	30$
	INC	BYTMOD		;YEP. SET TO BYTE MODE
30$:	PULL	R1		;PRUNE STACK
	PUSH	(R4)		;GET DIRECTIVE ADDRESS
	CLR	(R4)		;RESET IT
	CLR	R3		;CLEAR FOR DIRECTIVE ROUTINES.
	JMPOVR	(SP)+		;EXIT TO DIRECTIVE ROUTINE
.IFF
	MOV	#MODE,R4	;POINT TO MODE
	MOV	(R4),R1		;LEAVE RESULT IN R1
	CLR	(R4)+		;SET TO ZERO, POINT TO VALUE
	MOV	#CLCLOC,R2	;POINT R2 TO LOCATION COUNTER
	BIT	#100000+DFLGEV,R1	;OP CODE OR EVEN DIRECTIVE?
	BEQ	10$		;  NO
	BIT	#1,(R2)		;YES, CURRENTLY EVEN?
	BEQ	10$		;  YES
	INC	(R2)		;NO, MAKE IT EVEN
	ERROR	B		;  AND FLAG ERROR
10$:	BIT	#DFLGBM,R1	;BYTE MODE DIRECTIVE?
	BEQ	30$		;  NO
	INC	BYTMOD		;YES, SET FLAG
30$:	TST	R1		;OP-CODE?
	BMI	40$		;  YES
	MOV	(R4),-(SP)	;NO, DIRECTIVE.
	CLR	(R4)		;CLEAR VALUE
	CLR	R3		;START WITH R3=0
	JMPOVR	(SP)+		;GO TO PROPER HANDLER

40$:	MOV	#077776,PCRCNT	;LIST LOCATION OF FIRST WORD ONLY
	STCODE			;STUFF BASIC VALUE
.IF NDF	XCREF
	MOVB	R1,CRFDFL+1	;SET "*" CREF MARKERS
.IFTF
	SWAB	R1
	BIC	#177600,R1	;CLEAR HIGH ORDER BITS
	MOV	R1,OPCLAS	;SAVE CLASS
	ASL	R1
	ASL	R1		;FOUR BYTES PER TABLE ENTRY
	CLR	-(SP)		;SET A STOPPER
	MOV	OPJTBL+2(R1),-(SP)	;STACK SECOND ARG
	BNE	50$		;BRANCH IF TWO ARGS
	TST	(SP)+		;ONE ARG, PRUNE TERMINATOR
50$:	MOV	OPJTBL(R1),R1	;SET THE FIRST ARGUMENT
	BEQ	80$		;BRANCH IF NO ARGS
60$:	MOV	R1,-(SP)	;SAVE A COPY OF THE ARG
	SWAB	(SP)		;SHIFT COUNT TO RIGHT HALF
	BIC	#177400,R1	;ISOLATE LOW BYTE
	TSTARG			;COMMA TEST
	CLR	R0		;FUNCTION REGISTER
	CALL	OPJBAS(R1)	;CALL PROPER ROUTINE
.IFT
	ROLB	CRFDFL+1	;MOVE SECOND FIELD BIT
.ENDC
	.PAGE
70$:	ASL	R0		;SHIFT RESULT
	DECB	(SP)		;COUNT IN SP, RH
	BGE	70$
	ROR	R0		;WE WENT ONE TOO MANY
	MOV	ROLBAS+CODROL,R1
	BIS	R0,6(R1)	;SET EXPRESSION BITS
	TST	(SP)+		;PRUNE WORK ENTRY
80$:	MOV	(SP)+,R1	;GET NEXT ARG FROM STACK
	BNE	60$		;BRANCH IF NOT TERMINATOR

.IF NDF	XZERR
	MOV	ROLBAS+CODROL,R1
	MOV	6(R1),R0	;SET FOR "Z" ERROR TESTS
	MOV	R0,R1
	BIC	#000007,R1
	CMP	#000120,R1	;  JMP (R)+
	BEQ	100$
	BIC	#000700,R1
	CMP	#004020,R1	;  JSR  X,(R1)+
	BEQ	100$
	MOV	R0,R1
	BIT	#007000,R1	;FIRST ARG TYPE 0?
	BNE	110$		;  NO, OK
	BIC	#100777,R1
	BEQ	110$
	CMP	#070000,R1	;DOUBLE ADDRESS TYPE?
	BEQ	110$		;  NO
	MOV	R0,R1
	BIC	#170017,R1
	CMP	#000760,R1	;  MOV PC,[@]X(R)
	BEQ	100$
	BIC	#177717,R1
	CMP	#000020,R1	;  (R)+
	BEQ	90$
	CMP	#000040,R1	;  -(R)
	BNE	110$
90$:	MOV	R0,R1
	ROL	R1
	ROL	R1
	SWAB	R1
	SUB	R0,R1
	BIT	#000007,R1	;  R1=R2
	BNE	110$
100$:	ERROR	Z
110$:
.ENDC

CPOPJ:	RETURN
	.PAGE
	.MACRO	GENOPJ	NUMBER,SUBR1,SC1,SUBR2,SC2	;OP CODE JUMP TABLE
	.GLOBL	OPCL'NUMBER
OPCL'NUMBER=	<.-OPJTBL>/4
	.IIF NB <SUBR1>,	.BYTE	SUBR1-OPJBAS
	.IIF  B <SUBR1>,	.BYTE	0
	.BYTE	SC1+0
	.IIF NB <SUBR2>,	.BYTE	SUBR2-OPJBAS
	.IIF  B <SUBR2>,	.BYTE	0
	.BYTE	SC2+0
	.ENDM

	ENTSEC	DPURE
OPJTBL:				;OP CODE JUMP TABLE
	GENOPJ	00
	GENOPJ	01,	AEXP
	GENOPJ	02,	AEXP,	6,	AEXP
	GENOPJ	03,	REGEXP
	GENOPJ	04,	BROP
	GENOPJ	05,	REGEXP,	6,	AEXP
	GENOPJ	06,	TRAPOP

.IF NDF	X45
	GENOPJ	07,	AEXP,	0,	REGEXP,	6
	GENOPJ	08,	REGEXP,	6,	SOBOP
	GENOPJ	09,	AEXP,	0,	REGEXP,	6
	GENOPJ	10,	MARKOP
	GENOPJ	11,	AEXP,	0,	DRGEXP,	6
	GENOPJ	12,	DRGEXP,	6,	AEXP,	0
	GENOPJ	13,	SPLOP
	GENOPJ	14,	AEXP,	0,	DRGEXP,	6
.ENDC


	ENTSEC	IMPLIN
OPCLAS:	.BLKW			;OP CODE CLASS
	XITSEC
	.PAGE
OPJBAS:				;INDEX BASE FOR FOLLOWING ROUTINES
	RETURN


REGEXP:				;REGISTER EXPRESSION
	ABSEXP			;EVALUATE ABSOLUTE
	BIT	#177770,R0	;ANY OVERFLOW?
	BEQ	10$		;  NO
	ERROR	R		;YES, FLAG ERROR
	BIC	#177770,R0	;CLEAR OVERFLOW
10$:	RETURN

BROP:				;BRANCH DISPLACEMENT TYPE
	RELEXP
	CMPB	SECTOR,CLCSEC
	BNE	10$
	SUB	CLCLOC,R0
	ASR	R0
	BCS	10$
	DEC	R0
	MOVB	R0,R3		;EXTEND SIGN
	CMP	R0,R3		;PROPER?
	BEQ	20$		;  YES
10$:	ERROR	A
	MOV	#000377,R0
20$:	BIC	#177400,R0	;CLEAR POSSIBLE HIGH BITS
	RETURN

TRAPOP:				;TRAP TYPE
	ENTOVR	2
	SETXPR			;SET EXPRESSION REGISTERS
	MOV	(R4),-(SP)	;SAVE THE VALUE
	EXPR			;EVALUATE THE EXPRESSION (NULL OK)
	INC	BYTMOD		;TREAT AS BYTE
	SETIMM
	CMPB	(R2),#200	;ABSOLUTE?
	BNE	10$		;  NO
	TST	(SP)+		;YES, PRUNE STACK
	MOV	(R4),R0		;VALUE TO MERGE
	RETURN

10$:	ZAP	CODROL		;CLEAR CODE ROLL
	STCODE			;STORE ADDRESS
	MOV	#100000,(R3)	;SET FOR ABSOLUTE BYTE
	SWAB	(SP)
	MOV	(SP)+,(R4)	;SET ORIGIONAL VALUE
	STCODE
	CLR	R0
	RETURN
	XITOVR
	.PAGE
.IF NDF	X45

DRGEXP:				;DOUBLE REGISTER EXPRESSION
	CALL	REGEXP		;EVALUATE NORMAL
	MOV	#177774,R3	;TEST FOR OVERFLOW
	BR	MASKR3

SOBOP:				;SOB OPERATOR
	CALL	BROP		;FREE-LOAD OFF BRANCH OPERATOR
	MOVB	R0,R0		;EXTEND SIGN
	NEG	R0		;POSITIVE FOR BACKWARDS
	BR	MASKB6		;MASK TO SIX BITS

SPLOP:				;SPL TYPE
	ABSEXP
	MOV	#177770,R3	;ONLY THREE BITS ALLOWED
	BR	MASKR3

MARKOP:				;MARK OPERATOR
	ABSEXP			;EVALUATE ABSOLUTE
MASKB6:	MOV	#177700,R3	;SET TO MASK HIGH ORDER
MASKR3:	BIT	R3,R0		;OVERFLOW?
	BEQ	10$		;  NO
	ERROR	T		;YES, FLAG TRUNCATION ERROR
	BIC	R3,R0		;CLEAR EXCESS
10$:	RETURN

.ENDC
	.PAGE
AEXP:	SAVREG			;ADDRESS EXPRESSION EVALUATION
	SETXPR			;  AND SET "EXPRESSION" TYPE
	INC	EXPFLG
	CLR	-(SP)		;ACCUMULATE ON TOP OF STACK
AEXP02:	CHSCAN	AEXTBL		;TEST FOR OPERATOR
	BEQ	AEXP22		;  NO
	JMP	(R0)		;YES, GO TO IT

	ENTSEC	DPURE
AEXTBL:				;ADDRESS EXPRESSION TABLE
	GCHTBL	CH.IND,	AEXP03	;  "@"
	GCHTBL	CH.HSH,	AEXP06	;  "#"
	GCHTBL	CH.SUB,	AEXP10	;  "-"
	GCHTBL	CH.LP,	AEXP12	;  "("
	.WORD	0		;TERMINATOR
	XITSEC

AEXP03:	TST	(SP)		;"@", SECOND TIME AROUND?
	BEQ	10$		;  NO
	ERROR	Q		;  YES
10$:	BIS	#AM.DEF,(SP)	;SET IT
	BR	AEXP02

AEXP06:				;LITERAL (#)
.IF NDF	XFLTG
	CMP	#OPCL11,OPCLAS	;CLASS 11?
	BNE	10$		;  NO
	CALL	FLTG1W		;YES, TRY FOR ONE-WORD FLOATING
	BNE	20$		;BRANCH IF OK
.ENDC
10$:	GLBEXP			;EVALUATE EXPRESSION
20$:	BIS	#AM.IMM,(SP)	;SET BITS
	BR	AEXP32		;USE COMMON EXIT

AEXP10:				;AUTO-DECREMENT (-)
	CMP	R5,#CH.LP	;FOLLOWED BY "("?
	BNE	AEXP20		;  NOT A CHANCE
	CALL	AEXPLP		;PROCESS PARENS
	BIS	#AM.DEC,(SP)
	BR	AEXP36

AEXP12:				; "("
	CALL	AEXPL1		;EVALUATE REGISTER
	CMP	R5,#CH.ADD	;AUTO-INCREMENT (+)?
	BNE	10$		;  NO
	GETNB			;YES, POLISH IT OFF
	BIS	#AM.INC,(SP)	;SET BITS
	BR	AEXP36

10$:	BIT	#AM.DEF,(SP)	;INDIRECT SEEN?
	BNE	20$		;  YES
	BIS	#AM.DEF,(SP)	;NO, SET BIT
	BR	AEXP36

20$:	CLR	(R3)		;MODE
	CLR	(R4)		;  AND VALUE
	BR	AEXP30
	.PAGE
AEXP20:	SETSYM			;AUTO-DEC FAILURE, POINT TO -
AEXP22:	GLBEXP			;GET AN EXPRESSION
	CMP	R5,#CH.LP	;INDEXED?
	BEQ	40$		;  YES
	BIT	#REGFLG,(R3)	;FLAGS
	BNE	AEXP36
.IF NDF	XEDPIC!XEDAMA
	TST	(SP)
	BNE	30$
.IF NDF	XEDPIC
	BIT	#ED.PIC,EDMASK
	BNE	10$
	BIT	#GLBFLG,(R3)
	BNE	20$
	CMPB	(R2),CLCSEC
	BEQ	30$
	BR	20$
10$:
.ENDC
.IF NDF	XEDAMA
	BIT	#ED.AMA,EDMASK	;ABSOLUTE MODE REQUESTED?
	BNE	30$		;  NO
.ENDC
20$:	BIS	#AM.IMM!AM.DEF,(SP)	;OK, SET ABS MODE
	BR	AEXP32
.ENDC

30$:	BIS	#AM.REL,(SP)	;NO
	SETDSP			;SET DISPLACEMENT
	BR	AEXP34

40$:	BIT	#REGFLG,(R3)	;FLAGS
	BEQ	50$
	ERROR	R
	BIC	#REGFLG,(R3)	;FLAGS
50$:	MOV	(R1)+,-(SP)	;STACK CURRENT VALUE
	MOV	(R1)+,-(SP)
	MOV	(R1)+,-(SP)
	MOV	(R1)+,-(SP)
	CALL	AEXPLP		;PROCESS INDEX
	MOV	(SP)+,-(R1)	;RESTORE
	MOV	(SP)+,-(R1)
	MOV	(SP)+,-(R1)
	MOV	(SP)+,-(R1)
AEXP30:	BIS	R0,(SP)
	BIS	#AM.NDX,(SP)
AEXP32:	SETIMM
AEXP34:	STCODE
	CLR	R0
AEXP36:	BIS	(SP)+,R0
	RETURN
	.PAGE
AEXPLP:				;AEXP PAREN PROCESSOR
	GETNB			;BYPASS PAREN
AEXPL1:	CALL	REGEXP		;GET A REGISTER EXPRESSION
	CMP	R5,#CH.RP	;HAPPY ENDING ")"?
	BNE	10$		;  NO
	JMP	GETNB		;YES, BYPASS AND EXIT

10$:	ERROR	Q		;NO
	RETURN

.ENDC		;ne,MACXX&.pdp11	(near PROPC:)

	ENTSEC	IMPLIN
BYTMOD::.BLKW			;BYTE MODE IF NON-ZERO
	XITSEC

	.SBTTL	DIRECTIVES
	SETOVR	3
	.IF NDF	XREL

	.SBTTL GLOBL/GLOBB Psuedo-ops
.IF eq,MACXX&.pdp11

GLOBB::			;BASE PAGE GLOBL HANDLER
.IF ne,MACXX&<..m69!.6502>
	MOV	#GLBFLG!BSEFLG!FWDFLG,GLBLFG
.IFF
	MOV	#GLBFLG!BSEFLG,GLBLFG	;INITIALISE TO BASE AND GLOBL
.ENDC
	BR	GLBCOM
.ENDC
GLOBL::				;GLOBAL HANDLER
	MOV	#GLBFLG,(PC)+	;INITIALISE TO JUST GLOBL
GLBLFG:	.WORD	GLBFLG
GLBCOM:
10$:	GSARG			;GET A SYMBOL
	bne	20$		;got one
	cmpb	r5,#',		;blank arg?
	beq	10$		;yep, keep looking
	return			;nope, we're done then

20$:	SSRCH			;NO, SEARCH USER SYMBOL TABLE
.IF ne,MACXX&<..m69!.6502>
	BEQ	30$		;NOT IN SYMROL YET
	XOR	#FWDFLG,FLAGS	;FLIP FWDFLG BACK TO ITS ORIGINAL VALUE
30$:
.ENDC
.IIF DF RSX11D,	BIC	#DFGFLG,FLAGS
.IF ne,MACXX&.pdp11
	BIT	#REGFLG,FLAGS	;REGISTER TYPE?
	BNE	40$		;YEP, DISALLOW
.IFTF
	BIS	GLBLFG,FLAGS	;NO, FLAG AS GLOBL
	INSERT			;UPDATE/INSERT
	CRFDEF
	BR	10$

.IFT
40$:	ERROR	R
	BR	10$
.ENDC
.ENDC


	.SBTTL .END
	.GLOBL	END,CPYLVL

END:				;TEMP END DIRECTIVE
	EXPR			;EVALUATE THE EXPRESSION
	BNE	10$		;  BRANCH IF NON-NULL
	INC	(R4)		;NULL, MAKE IT A ONE
10$:	CALL	ZAPCPX		;ZAP THE COMLEX ROLL
	RELTST			;NO GLOBALS ALLOWED
	TST	CPYLVL		;INCLUDE MODE?
	BEQ	20$		;NO
	ERROR	< >		;WARNING
	RETURN			;AND IGNORE .END
20$:	INC	ENDFLG
	SETIMM			;FILL OUT BLOCK
	SETPF1			;LIST FIELD 1
	TST	CNDLVL		;IN A CONDITIONAL?
	BEQ	30$		;NOPE, OK THEN
	ERROR	P		;GIVE 'EM AN ERROR
30$:	MOV	#SYMBOL,R1
	MOV	#ENDVEC,R2
	JMP	XMIT4		;MOVE TO END VECTOR

	XITOVR

	ENTSEC	IMPURE
ENDVEC:	.BLKW	4		;END VECTOR STORAGE

	ENTSEC	XCTPRG
	INC	ENDVEC+6	;DEFAULT TO NO END VECTOR

	XITSEC

	.SBTTL ASECT/BSECT/CSECT/PSECT Section controls
	.IF NDF	XREL
;+
; DIRECTIVES .SAVE AND .RESTORE
; R3 = 0 IF .SAVE, R3 = 1 IF .RESTORE
;-
RESTO::	INC	R3
SAVE::	MOV	SECSP,R0	;GET SECTOR STACK POINTER
	BNE	10$		;BRANCH IF INITIALIZED
	MOV	#SECSTK,R0	;ELSE DO SO
10$:	TST	R3		;TEST IF .RESTORE
	BNE	20$		;BRANCH IF SO
	CMP	R0,#SECSTT	;TEST IF STACK FULL
	BEQ	40$		;ERROR IF YES
	MOVB	CLCSEC,(R0)+	;SET WORD IN STACK TO CURRENT SECTOR NUMBER
	CLRB	(R0)+
	MOV	CLCLOC,(R0)+	;STACK THE CURRENT LOCATION COUNTER
	MOV	R0,SECSP	;UPDATE STACK POINTER
	RETURN			;DONE, EXIT STMNT ROUTINE

20$:	CMP	R0,#SECSTK	;ANYTHING IN STACK?
	BEQ	40$		;NO, ERROR
	MOV	-(R0),R3	;PICK UP OLD LOCATION COUNTER
	MOV	-(R0),R4	;GET PREV SECTOR NUMBER
	MOV	R0,SECSP	;UPDATE STACK POINTER
	CALL	SETMAX		;CLOSE OUT CURRENT PSECT
	CLR	ROLUPD		;START AT BEGINNING OF SECTOR LIST
30$:	NEXT	SECROL		;GET NEXT SECTOR
	DEC	R4		;TEST IF HAVE THE SECTOR
	BPL	30$		;ITERATE IF NO
	MOV	R3,VALUE	;NOW SET THE TO THE OLD LOC COUNTER
	JMP	PSECTG		;SET TO THE FORMER PSECT NOW

40$:	ERROR	A		;SET ERROR FLAG
	RETURN			;AND EXIT

	ENTSEC	IMPURE
SECSP:	.BLKW	1		;SECTOR .SAVE/.RESTORE STACK POINTER
SECSTK:	.BLKW	20*2		;SECTOR STACK (16. ENTRIES)
SECSTT:				;REF LABEL FOR SECTOR STACK LIMIT
	XITSEC

.IF eq,MACXX&.pdp11
BSECT::	CALL	SETMAX		;CLEAN UP SECTOR
	GETSYM			;GET SYMBOL
	MOV	R50BSE,SYMBOL
	MOV	#CSTBSE!CSTREL,R3	;INIT FLAGS
	MOV	R0,SYMBOL+2
	BEQ	CSECTF		;CONCAT
	BIS	#CSTALO,R3	;ELSE OVERLAID
	BR	CSECTF		;COMMON EXIT

R50BSE:	.RAD50	/. B/

.ENDC
ASECT::	CALL	SETMAX		;CLOSE OUT CURRENT SECTION
ASECTF:	MOV	R50ABS,SYMBOL	;SET DEFAULT ABS SECTION NAME
	MOV	R50ABS+2,SYMBOL+2;
	MOV	#ASTFLG,R3	;GET DEFAULT FLAGS
	BR	CSECTF		;

CSECT::	CALL	SETMAX		;CLOSE OUT CURRENT SECTION
	MOV	#CSTFLG,R3	;GET DEFAULT FLAGS
	TSTARG			;ANY NAME?
	BEQ	10$		;IF EQ NO
	BIS	#CSTALO,R3	;SET OVERLAID
10$:	GETSYM			;GET SECTION NAME

CSECTF:	SCAN	SECROL		;SCAN FOR A MATCH
	BNE	CSECTX		;IF NE MATCH FOUND
	MOVB	R3,MODE		;SET MODE FLAGS
	MOVB	ROLSIZ+1+SECROL,SECTOR;SET SECTOR
	BR	PSECTF		;

PSECT::	CALL	SETMAX		;CLOSE OUT CURRENT SECTION
	TSTARG			;TEST FOR ARGUMENT (SET UP)
	INC	ARGCNT		;INCREMENT ARGUMENT COUNT
	GETSYM			;GET SECTION NAME
	SCAN	SECROL		;SCAN FOR MATCH
	BNE	10$		;IF NE FOUND MATCH
	MOVB	#PSTFLG,MODE	;SET DEFAULT MODE FLAGS
	MOVB	ROLSIZ+1+SECROL,SECTOR;SET SECTOR
10$:	MOV	#SYMBOL+12,R3	;GET SET TO STACK SECTION
	.REPT	5
	MOV	-(R3),-(SP)	;STACK SECTION
	.ENDR
20$:	TSTARG			;ANY MORE ARGUMENTS?
	BEQ	30$		;IF EQ NO
	GETSYM			;GET ATTRIBUTE SYMBOL
	SCANW	SATROL		;SCAN FOR A MATCH
	BEQ	PSECTA		;IF EQ ERROR
	MOV	#SYMBOL+2,R0	;GET ADDRESS OF ARGUMENT WORD
	BICB	(R0),4(SP)	;ASSUME BIT IS TO BE CLEARED
	TST	(R0)		;CLEAR OR SET?
	BPL	20$		;IF PL CLEAR
	BISB	(R0),4(SP)	;SET BIT
	BR	20$		;GO AGAIN

30$:	MOV	(SP)+,(R3)+	;RESTORE SECTION NAME
	MOV	(SP)+,(R3)+	;
	SCAN	SECROL		;SCAN SECTOR ROLL
	MOV	(SP)+,(R3)+	;RESTORE SECTION ATTRIBUTES
	MOV	(SP)+,(R3)+	;
	MOV	(SP)+,(R3)+	;

PSECTF:	INSERT			;INSERT SECTION

CSECTX:	SETPF1
	CRFREF
PSECTG:	MOV	#SYMBOL,R1
	MOV	#CLCNAM,R2
	CALL	XMIT5
	JMP	LSBSET		;SET NEW LOCAL SYMBOL BASE

PSECTA:	ADD	#5*2,SP		;CLEAN STACK
	ERROR	A		;SET ERROR FLAG
	RETURN			;

	.MACRO SAT NAME,BIT,POL
	.RAD50	/NAME/
	.BYTE BIT,POL&128.
	.ENDM

.IF eq,MACXX&.pdp11
SATBAS:	SAT ABS,CSTREL,0
	SAT REL,CSTREL,-1
	SAT CON,CSTALO,0
	SAT OVR,CSTALO,-1
	SAT BSE,CSTBSE,-1
SATTOP:
.IFF
SATBAS::			;REF LABEL
	SAT	ABS,CSTREL,0
	SAT	CON,CSTALO,0
	SAT	D,CSTTYP,-1
	SAT	GBL,CSTGBL,-1
	SAT	HGH,CSTMEM,-1
	SAT	I,CSTTYP,0
	SAT	LCL,CSTGBL,0
	SAT	LOW,CSTMEM,0
	SAT	OVR,CSTALO,-1
	SAT	REL,CSTREL,-1
	SAT	RO,CSTACC,-1
	SAT	RW,CSTACC,0
SATTOP::			;REF LABEL
.ENDC
.ENDC		;XREL

	.IF DF	YPHASE
	.GLOBL	PHASE,	DEPHA
PHASE:	RELEXP
	CMPB	SECTOR,CLCSEC
	BNE	10$
	MOV	R0,PHAOFF
	SUB	CLCLOC,PHAOFF
	MOV	R0,CLCLOC
	RETURN

10$:	ERROR	A
	RETURN

DEPHA:	SUB	PHAOFF,CLCLOC
	CLR	PHAOFF
	RETURN

	ENTSEC	IMPPAS
PHAOFF:	.BLKW
	XITSEC
	.ENDC	;YPHASE

	.SBTTL SECINI Initialise ASECT and blank CSECT

SECINI:	ENTOVR	3
	.IF NDF	XREL
	CALL	ASECTF		;MOVE ONTO ROLL
	CLR	SYMBOL		;DITTO FOR BLANK CSECT
	CLR	SYMBOL+2
	MOV	#CSTFLG,R3	;INIT FOR CSECT
	.IF NDF	XEDABS
	BIT	#ED.ABS,EDMASK	;ABS MODE?
	BNE	CSECTF		;  NO
	RETURN
	.IFF
	BR	CSECTF
	.ENDC			;XEDABS

	.IFF
	BIT	#ED.ABS,EDMASK
	BEQ	10$
	ERROR	A
	BIC	#ED.ABS,EDMASK
10$:	RETURN

	.ENDC			;XREL

	XITOVR

	.SBTTL SETMAX Max out a section before changing to a new one

	.IF NDF	XREL

SETMAX:				;SET MAX AND ENTER ONTO ROLL
	ENTOVR	3
	SAVREG			;PLAY IT SAFE
	MOV	#CLCNAM,R1
	MOV	#SYMBOL,R2
	CALL	XMIT2		;MOVE NAME TO SYMBOL
	SCAN	SECROL		;SCAN SECTOR ROLL
	CALL	XMIT3		;SET REMAINDER OF ENTRIES
	JMP	INSERT		;UPDATE ROLL AND EXIT
	XITOVR


	.SBTTL .LIMIT Psuedo-op
	.GLOBL	LIMIT

	SETOVR	9
LIMIT:	CALL	OBJDMP
	CLR	(R4)		;CLEAR VALUE
	MOV	#RLDT11*400,-(R4)	;SET RLD TYPE
	STCODE
	CLR	(R4)
	JMP	STCODE
	XITOVR

	.ENDC

	.SBTTL .TITLE
	.GLOBL	TITLE,	SBTTL,	IDENT

SETHDR:				;ONCE-ONLY DEFAULT SETTER
	ENTOVR	9
	MOV	#DEFTTL,CHRPNT	;POINT TO DEFAULT
	SETCHR			;MAKE IT LOOK LIKE THE REAL THING

TITLE:
	GETSYM			;GET A SYMBOL
	BNE	10$		;  ERROR IF NULL
	ERROR	A
	RETURN

10$:	MOV	R0,PRGTTL	;MOVE INTO STORAGE
	MOV	SYMBOL+2,PRGTTL+2
	CALL	SETSYM		;POINT TO START OF TITLE
	MOV	#TTLBUF,R2	;POINT TO BUFFER
	MOVB	#FF,(R2)+	;STORE PAGE EJECT
	CLR	R3		;CLEAR POSITION CONTER
20$:	MOVB	R5,(R2)		;PLUNK THE NEXT CHAR IN THE BUFFER
	BEQ	50$		;BRANCH IF END
	CMP	R5,#TAB		;A TAB?
	BNE	30$		;  NO
	BIS	#7,R3		;YES, COMPENSATE
30$:	INC	R3		;UPDATE POSITION COUNTER
	CMP	R3,#TTLLEN	;WITHIN BOUNDS?
	BHIS	40$		;  NO
	TSTB	(R2)+		;YES, MOVE POINTER
40$:	GETCHR			;GET THE NEXT CHARACTER
	BNE	20$		;LOOP IF NOT END
50$:	MOVB	#TAB,(R2)+	;SET SEPARATOR
	MOV	#HDRTTL,R1
	MOVBYT			;SET VERSION NUMBER, ETC.
	.IF NDF	XTIME
	MOV	#DATTIM,R1
	MOVBYT			;DATE AND TIME
	.ENDC
	MOV	R2,TTLBRK	;REMEMBER BREAK POINT
	RETURN

	ENTSEC	TXTBYT
DEFTTL:	.ASCIZ	/.MAIN./	;DEFAULT TITLE

	ENTSEC	IMPURE
TTLBRK:	.BLKW			;BREAK LOCATION
TTLBUF:	.BLKB	TTLLEN-1!7+1+1	;MODULO TAB + FF
	.BLKB	20.		;INTRO MSG
	.IIF NDF XTIME,	.BLKB	20.	;TIME & DATE
	.BLKB	20.		;PAGE NUMBER
	.EVEN
	XITSEC

	XITOVR

	.SBTTL .SBTTL
	SETOVR	2
	.GLOBL	SETCHR,INCFLG

SBTTL:				;SUB-TITLE DIRECTIVE
	MOV	#STLBUF,R2	;POINT TO SUB-TITLE BUFFER
	TST	PASS		;PASS ONE?
	BEQ	20$		;  YES
	TST	INCFLG		;DOING AN .INCLUDE?
	BNE	80$		;YES. EXIT
10$:	MOVB	R5,(R2)+	;MOVE CHARACTER IN
	BEQ	80$		;  BRANCH IF END
	GETCHR			;GET THE NEXT CHARACTER
	CMP	R2,#STLBUF+STLLEN-1	;TEST FOR END
	BLO	10$
	TSTB	-(R2)		;POLISH OFF LINE
	BR	10$

20$:	BIT	#LC.TOC,LCMASK
	BNE	80$
	TSTB	LSTDEV		;ANY LISTING DEVICE?
	BEQ	80$		;  NO, EXIT
	MOV	#TOCTXT,R1
	MOVBYT			;SET TABLE OF CONTENTS
	TST	INCFLG		;DOING A .INCLUDE?
	BNE	40$		;YEP. DON'T SKIP THE ".INCLUDE"
	CALL	SETSYM		;POINT TO ".SBTTL"
30$:	GETR50			;GET RADIX-50 CHAR
	BGT	30$		;STOP AT FIRST TERMINATOR
40$:	MOV	CHRPNT,R2	;SET POINTER
	.IF NDF	XLCSEQ
	MOV	LINNUM,R0
	CALL	50$
	MOVB	#CH.SUB,-(R2)
	.IFF
	MOVB	#TAB,-(R2)
	.ENDC
	MOV	PAGNUM,R0
	CALL	50$
	MOVB	#SPACE,-(R2)
	PUTLP	R2		;OUTPUT
	RETURN
	.PAGE
50$:	MOV	#3,R4
60$:	MOVB	#SPACE,-(R2)
	MOV	R0,R1
	BEQ	70$
	CLR	R0
	DIV	#^D10,R0
	ADD	#DIG.0,R1
	MOVB	R1,(R2)
70$:	SOB	R4,60$
80$:	RETURN
	XITOVR

	ENTSEC	TXTBYT
TOCTXT:	.ASCIZ	/TABLE OF CONTENTS/

	ENTSEC	IMPPAS
STLBUF:	.BLKW	<STLLEN+2>/2	;SUB-TITLE BUFFER

	ENTSEC	IMPLIN
INCFLG:	.BLKW

	XITSEC

	.SBTTL .IDENT
	SETOVR	3

IDENT:				;IDENT DIRECTIVE
	CALL	RAD50		;TREAT AS RAD50
	CLR	ROLUPD		;POINT TO START OF CODE-ROLL
	MOV	#PRGIDN,R2	;  AND TO IDENT BLOCK
10$:	NEXT	CODROL		;GET NEXT ITEM
	MOV	VALUE,(R2)+	;STORE IT
	CMP	R2,#PRGIDN+4	;PROCESSED TWO WORDS?
	BLO	10$		;  NO
	.IF NDF	XREL
	MOV	#GSDT06,(R2)+	;YES, SET GSD TYPE
	.ENDC
	ZAP	CODROL		;CLEAR CODE ROLL
	RETURN
	XITOVR

	ENTSEC	IMPURE
PRGTTL:	.BLKW	4
PRGIDN:	.BLKW	4		;IDENT BLOCK
	XITSEC

	.SBTTL .PRINT/.WARN/.ERROR
	.GLOBL	PRINT,	ERROR,	WARN

	SETOVR	9

WARN:	ERROR	< >
PRINT:	TSTARG			;ANY OPERANDS?
	BEQ	30$		;NOPE. JUST EXIT
	EXPR			;EVALUATE EXPRESSION
	CALL	ZAPCPX		;CLEAR OUT COMPLEX ROLL
	CMP	#CH.LP,R5	;(?
	BNE	20$		;NOPE
	MOV	#MODE,R2	;POINT TO EXPRESSION RESULTS
	MOV	(R2)+,-(SP)	;SAVE THEM
	MOV	(R2),-(SP)
	MOV	#2,R1		;INIT R1 SO NO ID FIELD
	CALL	$NLARG		;EVALUATE PARAMETERS
	MOV	(SP)+,(R2)	;RESTORE EXPRESSION RESULTS
	MOV	(SP)+,-(R2)
	MOV	(R1),R0		;ANY LOCATION DATA GIVEN?
	BEQ	10$		;NO. JUST EXIT
	CMP	(R1)+,(R1)+	;POINT TO RADIX
	CALL	CHKRDX		;CHECK IT
	MOV	R2,R1		;POINT TO EXPRESSION DATA
	MOV	R0,R2		;POINT TO DESTINATION FIELD
	ADD	#OCTBUF-1,R2
	CALL	SETWRD		;UNPACK EXPRESSION DATA INTO PRINT BUFFER
10$:	TST	$.NEWL		;'/' ENTERED?
	BEQ	30$		;NO. EXIT
	CALL	FLIQUE		;FORCE LINE TO PRINT
	BR	30$		;EXIT
20$:	SETPF1			;USE DEFAULT DATA FIELD
30$:	CLR	R5		;SO NO 'Q' ERRORS
	RETURN

ERROR:	ERROR	P
10$:	SETPF0			;PRINT LOCATION FIELD
	EXPR			;EVALUATE EXPRESSION
	BEQ	20$		;BRANCH IF NULL
	SETPF1			;NON-NULL, LIST VALUE
20$:	CALL	ZAPCPX		;BE SURE TO CLEAR OUT COMPLEX ROLL
	RETURN

	.IF NDF XBAW
	.GLOBL	REM

REM:				; ".REM" DIRECTIVE
	MOV	R5,R3		;SET TERMINATING CHARACTER
	BNE	10$		;BRANCH IF NON-NULL
	ERROR	A		;ERROR, NO DELIMITING CHARACTER
	RETURN

10$:	GETCHR			;GET THE NEXT CHARACTER
20$:	TST	R5		;END OF LINE?
	BNE	30$		;  NO
	CALL	ENDLIN		;YES, POLISH OFF LINE
	CALL	GETLIN		;GET NEXT LINE
	BEQ	20$		;LOOP IF NO EOF
	RETURN			;EOF, EXIT

30$:	CMP	R5,R3		;IS THIS THE TERMINATOR?
	BNE	10$		;  NO
	JMP	GETNB		;YES, BYPASS AND EXIT
	.ENDC

	XITOVR

	.SBTTL .BLKW/.BLKB
	.GLOBL	BLKW,	BLKB,	EVEN,	ODD,	RADIX,	EOT

	SETOVR	3

BLKW:	INC	R3		;FLAG WORD TYPE
BLKB:	EXPR			;EVALUATE THE EXPRESSION
	BNE	10$		;BRANCH IF NON-NULL
	INC	(R4)		;NULL, MAKE IT ONE
10$:	ABSTST			;MUST BE ABSOLUTE
20$:	ADD	R0,(R2)		;UPDATE PC
	ASR	R3		;WORD?
	BCS	20$		;  YES, DOUBLE VALUE
	RETURN

	.SBTTL .EVEN/.ODD
EVEN:	INC	(R2)		;INCREMENT THE PC
	BIC	#1,(R2)		;CLEAR IF NO CARRY
	RETURN

ODD:	BIS	#1,(R2)		;SET LOW ORDER PC BYTE

	.SBTTL .EOT

EOT:	RETURN

	.SBTTL .RADIX
RADIX:	MOV	CRADIX,R2	;SAVE IN CASE OF FAILURE
	MOV	#10.,CRADIX
	EXPR			;* GET AN EXPRESSION [27-JUN-74 RRB]
	BEQ	30$		;* NONE - REVERT TO OCTAL RADIX
	ABSTST			;* ELSE BE SURE IT'S ABSOLUTE
	CMP	R0,#2.
	BLT	10$
	CMP	R0,#16.
	BLE	20$
10$:	ERROR	A
	MOV	R2,R0
20$:	MOV	R0,CRADIX
	JMP	SETPF1
30$:	MOV	#8.,R0		;* REVERT TO OCTAL RADIX [27-JUN-74 RRB]
	BR	20$		;* AND EXIT

	ENTSEC	IMPPAS		;IMPURE AREA
CRADIX:	.BLKW			;CURRENT RADIX

	ENTSEC	XCTPAS		;TO BE EXECUTED EACH PASS
	MOV	#8.,CRADIX	;INIT TO OCTAL RADIX

	XITSEC			;BACK TO NORMAL


	XITOVR

	.SBTTL		DATA-GENERATING DIRECTIVES

	.SBTTL .WORD/.BYTE
	.GLOBL	BYTE,	WORD

	SETOVR	3

WORD:	INC	R3		;"WORD" DIRECTIVE, SET TO 2
BYTE:
	INC	R3		;"BYTE" DIRECTIVE, SET TO 1
	MOV	(R2),-(SP)	;STACK CURRENT PC
10$:	TSTARG			;TEST FOR ARGUMENT
	BEQ	20$		;  END
	EXPR			;PROCESS GENERAL EXPRESSION
	SETIMM			;CONVERT TO OBJECT FORMAT
	STCODE			;PUT ON CODE ROLL
	ADD	R3,(R2)		;UPDATE PC
	BR	10$		;TEST FOR MORE

20$:	MOV	(SP)+,(R2)	;RESTORE INITIAL PC
DGTEST:	TSTB	ROLSIZ+CODROL+1	;ANY CODE GENERATED?
	BNE	10$		;  YES
	CLR	MODE		;NO, STORE A ZERO
	CLR	VALUE
	SETIMM
	STCODE
10$:	RETURN
	XITOVR

	.IF eq,MACXX&.pdp11
	.SBTTL .VCTRS/.CKSUM
	.GLOBL VCTRS,ASCTSY,CKSUM,BYTSYM

CKSUM:
VCTRS:	TSTARG		;SKIP TO FIRST ARGUMENT (ADDED 5/78 D.S.)
	BNE 	10$	;SOMETHING THERE
	ERROR	A	;N.F.G.
	RETURN		;EXIT
10$:	ABSEXP		;FIRST ONE MUST BE ABSOLUTE
	MOV	R0,-(SP)	;SAVE THIS A MINUTE
	MOV	#CLCSAV,R2
	MOV	#CLCNAM,R1
	XMIT	5		;SAVE CLC STUFF
	CALL	ASECT		;SET US INTO AN ASECT
	MOV	(SP)+,CLCLOC	;PUT IN REQUEST PC
	MOV	SP,VCTFLG	;SIGNAL .VCTRS ASSEMBLED
	TST BYTMOD		;.CKSUM?
	BNE	20$		;YEP
	JMP	FAKWRD		;GO PUT IN VECTORS

20$:	MOV	#BYTSYM,R1	;POINT TO .BYTE directive
	JMP	FAKBYT		;GO TO FAKE BYTE ROUTINE
	.ENDC

	.SBTTL .ASCII/.ASCIZ/.ASCIN/.RAD50
	.GLOBL	RAD50,	ASCII,	ASCIZ,	ASCIN

	SETOVR	3

ASCIN:	INC	R3		;  ".ASCIN", SET TO 2  (ADDED 5/78 D.S.)
ASCIZ:	INC	R3		;  ".ASCIZ", SET TO  1
ASCII:	INC	R3		;  ".ASCII", SET TO  0
RAD50:
	DEC	R3		;  ".RAD50", SET TO -1
	CLR	ASCSAV		;INIT FOR .ASCIN
	CALL	170$		;INIT REGS
10$:	MOV	R5,R2		;SET TERMINATOR
	BEQ	80$		;ERROR IF EOL
20$:	CMP	R5,#CH.LAB	; "<", EXPRESSION?
	BEQ	110$		;  YES
30$:	GETCHR			;NO, GET NEXT CHAR
	MOV	R5,R0		;SET IN WORK REGISTER
	BEQ	80$		;ERROR IF EOL
	CMP	R5,R2		;TERMINATOR?
	BEQ	60$		;  YES
	TST	R3		;NO
	BMI	40$		;BRANCH IF RAD50
	.IF NDF	XEDLC
	MOV	CHRPNT,R0	;FAKE FOR OVLAY PIC
	MOVB	(R0),R0		;FETCH POSSIBLE LOWER CASE
	BIC	#177600,R0	;CLEAR POSSIBLE SIGN BIT
	.ENDC
	BR	50$

40$:	TSTR50			;TEST RADIX 50
50$:	CALL	120$		;PROCESS THE ITEM
	BR	30$		;BACK FOR ANOTHER

60$:	GETNB			;BYPASS TERMINATOR
70$:	TSTB	CTTBL(R5)	;EOL OR COMMENT?
	BGT	10$		;  NO
	BR	90$

80$:	ERROR	A		;ERROR, FLAG AND EXIT
90$:	CLR	R0		;YES, PREPARE TO CLEAN UP
	TST	R3		;TEST MODE
	BEQ	180$		;NORMAL EXIT IF .ASCII
	BMI	100$		;.RAD50
	DEC	R3		;.ASCIZ OR .ASCIN?
	BEQ	120$		;.ASCIZ. NEED A ZERO BYTE
	INC	R3		;PUT R3 BACK TO 2
	BIS	#600,ASCSAV	;SET MSB OF LAST DATA BYTE
	BR	120$		;AND STUFF IT
100$:	TST	R1		;.RAD50, ANYTHING IN PROGRESS?
	.IF NDF	RSX11D
	BEQ	DGTEST		;  NO, NORMAL EXIT
	.IFF
	BEQ	180$
	.ENDC
	CALL	120$		;YES, PROCESS
	BR	70$		;LOOP UNTIL WORD COMPLETED

110$:	MOV	(R4),-(SP)	;"<EXPRESSION>", SAVE PARTIAL
	ABSTRM			;ABSOLUTE TERM, SETTING R0
	MOV	(SP)+,(R4)	;RESTORE PARTIAL
	CALL	120$		;PROCESS BYTE
	BR	70$		;TEST FOR END

120$:	TST	R3		;RAD50?
	BPL	140$		;  NO
	CMP	R0,#50		;YES, WITHIN RANGE?
	BLO	130$		;  YES
	ERROR	T		;NO, ERROR
130$:	MOV	R0,-(SP)	;SAVE CURRENT CHAR
	MOV	(R4),R0		;GET PARTIAL
	CALL	MULR50		;MULTIPLY
	ADD	(SP)+,R0	;ADD IN CURRENT
	MOV	R0,(R4)		;SAVE
	INC	R1		;BUMP COUNT
	CMP	R1,#3		;WORD COMPLETE?
	BNE	180$		;  NO
140$:	CMP	R3,#2		;.ASCIN?
	BNE	150$		;NOPE
	MOV	R0,R1		;SAVE R0 FOR A SEC
	CLR	R0
	BISB	ASCSAV,R0	;PUT THE STACKED DATA INTO R0
	MOVB	R1,ASCSAV	;STACK THE NEW DATA
	TSTB	ASCSAV+1	;FIRST TIME THRU?
	BEQ	160$		;YEP. DON'T DO ANYTHING YET
150$:	MOV	R0,(R4)		;STUFF IN VALUE
	SETIMM			;CONVERT TO OBJ MODE
	STCODE			;STOW IT
160$:	INCB	ASCSAV+1	;SIGNAL NOT FISRT TIME THRU
170$:	CLR	R1		;CLEAR LOOP COUNT
	CLR	(R4)		;  AND VALUE
180$:	RETURN
	XITOVR

	ENTSEC	IMPURE
ASCSAV:	.BLKW	1		;SAVE SPACE FOR .ASCIN DIRECTIVE
	XITSEC

.IF NDF	XFLTG
	.SBTTL .FLT4/.FLT2 Floating point constants

	.GLOBL	FLT2,	FLT4

	SETOVR	3

FLT4:	INC	R3
FLT2:
	INC	R3		;MAKE IT 1 OR 2
	ASL	R3		;NOW 2 OR 4
10$:	TSTARG
	BEQ	JDGTST
	MOV	FLTPNT-2(R3),-(SP)	;EVALUATE NUMBER
	CALL	@(SP)+
	BNE	20$		;BRANCH IF NON-NULL
	ERROR	A		;  NULL, FLAG ERROR
20$:	MOV	R3,R2		;GET A WORKING COUNT
	MOV	#FLTBUF,R1	;POINT TO FLOATING POINT BUFFER
30$:	MOV	(R1)+,(R4)	;MOVE IN NEXT NUMBER
	STCODE			;PLACE ON CODE ROLL
	SOB	R2,30$		;LOOP ON WORD COUNT
	BR	10$		;CONTINUE
JDGTST:	JMP	DGTEST

	ENTSEC	DPURE
FLTPNT:	.WORD	FLTG2W,	FLTG4W
	XITSEC

	XITOVR

FLTG4W:	INC	FLTWDC		;FLOATING POINT NUMBER EVALUATOR
FLTG2W:	INC	FLTWDC
FLTG1W::
	ENTOVR	7
	SAVREG			;SAVE REGISTERS
	MOV	CHRPNT,-(SP)	;STACK CURRENT CHARACTER POINTER
	MOV	#FLTBUF,R3	;CONVENIENT COPY OF POINTERS
	MOV	#FLTSAV,R4	;  TO BUFFER AND SAVE AREA
	MOV	R4,R1
10$:	CLR	-(R1)		;INIT VARIABLES
	CMP	R1,#FLTBEG
	BHI	10$		;LOOP UNTIL DONE
	MOV	#65.,FLTBEX	;INIT BINARY EXPONENT
	CMP	#CH.ADD,R5	;  "+"?
	BEQ	20$		;  YES, BYPASS AND IGNORE
	CMP	#CH.SUB,R5	; "-"?
	BNE	30$		;  NO
	MOV	#100000,FLTSGN	;YES, SET SIGN AND BYPASS CHAR
20$:	GETCHR			;GET THE NEXT CHARACTER
30$:	BITB	#CT.NUM,CTTBL(R5)	;NUMERIC?
	BEQ	60$		;  NO
	BIT	#174000,(R3)	;NUMERIC, ROOM FOR MULTIPLICATION?
	BEQ	40$		;  YES
	INC	FLTEXP		;NO, COMPENSATE FOR THE SNUB
	BR	50$

40$:	CALL	FLTM50		;MULTIPLY BY 5
	CALL	FLTGLS		;CORRECTION, MAKE THAT *10
	SUB	#DIG.0,R5	;MAKE ABSOLUTE
	MOV	R4,R2		;POINT TO END OF BUFFER
	ADD	R5,-(R2)	;ADD IN
	ADC	-(R2)		;RIPPLE CARRY
	ADC	-(R2)
	ADC	-(R2)
50$:	ADD	FLTDOT,FLTEXP	;DECREMENT IF PROCESSING FRACTION
	CLR	(SP)		;CLEAR INITIAL CHAR POINTER (WE'RE GOOD)
	BR	20$		;TRY FOR MORE

60$:	CMP	#CH.DOT,R5	;DECIMAL POINT?
	BNE	70$		;  NO
	COM	FLTDOT		;YES, MARK IT
	BMI	20$		;LOOP IF FIRST TIME AROUND
70$:	CMP	#LET.E,R5	;EXPONENT?
	BNE	FLTG3		;  NO
	GETNB			;YES, BYPASS "E" AND BLANKS
	MOV	CRADIX,-(SP)	;STACK CURRENT RADIX
	MOV	#10.,CRADIX	;SET TO DECIMAL
	ABSTRM			;ABSOLUTE TERM
	MOV	(SP)+,CRADIX	;RESTORE RADIX
	ADD	R0,FLTEXP	;UPDATE EXPONENT
;	BR	FLTG3		;FALL THROUGH

FLTG3:	MOV	R3,R1
	MOV	(R1)+,R0	;TEST FOR ZERO
	BIS	(R1)+,R0
	BIS	(R1)+,R0
	BIS	(R1)+,R0
	BEQ	FLTGEX		;EXIT IF SO
10$:	TST	FLTEXP		;TIME TO SCALE
	BEQ	FLTG5		;FINI IF ZERO
	BLT	50$		;DIVIDE IF .LT. ZERO
	CMP	(R3),#031426	;MULTIPLY, CAN WE *5?
	BHI	20$		;  NO
	CALL	FLTM50		;YES, MULTIPLY BY 5
	INC	FLTBEX		;  AND BY TWO
	BR	30$

20$:	CALL	FLTM54		;MULTIPLY BY 5/4
	ADD	#3.,FLTBEX	;  AND BY 8
30$:	DEC	FLTEXP		;  OVER 10
	BR	10$

40$:	DEC	FLTBEX		;DIVISION, LEFT JUSTIFY BITS
	CALL	FLTGLS
50$:	TST	(R3)		;SIGN BIT SET?
	BPL	40$		;  NO, LOOP
	MOV	#16.*2,-(SP)	;16 OUTER, 2 INNER
	CALL	FLTGRS		;SHIFT RIGHT
	CALL	FLTGSV		;PLACE IN SAVE BUFFER
60$:	BIT	#1,(SP)		;ODD LAP?
	BNE	70$		;  YES
	CALL	FLTGRS		;MOVE A COUPLE OF BITS RIGHT
	CALL	FLTGRS
70$:	CALL	FLTGRS		;ONCE MORE TO THE RIGHT
	CALL	FLTGAD		;ADD IN SAVE BUFFER
	DEC	(SP)		;END OF LOOP?
	BGT	60$		;  NO
	TST	(SP)+		;YES, PRUNE STACK
	SUB	#3.,FLTBEX
	INC	FLTEXP
	BR	10$

FLTG5:	DEC	FLTBEX		;LEFT JUSTIFT
	CALL	FLTGLS
	BCC	FLTG5		;LOSE ONE BIT
	ADD	#200,FLTBEX	;SET EXCESS 128.
	BLE	10$		;BRANCH IF UNDER-FLOW
	TSTB	FLTBEX+1	;HIGH ORDER ZERO?
	BEQ	20$		;  YES
10$:	ERROR	N		;NO, ERROR
20$:	MOV	R4,R2		;SET TO SHIFT EIGHT BITS
	MOV	R2,R1
	TST	-(R1)		;R1 IS ONE LOWER THAN R2
30$:	CMP	-(R1),-(R2)	;DOWN ONE WORD
	MOVB	(R1),(R2)	;MOVE UP A BYTE
	SWAB	(R2)		;BEWARE OF THE INSIDE-OUT PC!!
	CMP	R2,R3		;END?
	BNE	30$
	CALL	FLTGRS		;SHIFT ONE PLACE RIGHT
	ROR	(R4)		;SET HIGH CARRY
	.IF NDF	XEDFPT
	BIT	#ED.FPT,EDMASK	;TRUNCATION?
	BEQ	70$		;  YES
	.ENDC
	MOV	FLTWDC,R2	;GET SIZE COUNT
	ASL	R2		;DOUBLE
	BNE	40$		;PRESET TYPE
	INC	R2		;SINGLE WORD
40$:	ASL	R2		;CONVERT TO BYTES
	BIS	#077777,FLTBUF(R2)
	SEC
50$:	ADC	FLTBUF(R2)
	DEC	R2
	DEC	R2
	BGE	50$
	TST	(R3)		;TEST SIGN POSITION
	BPL	70$		;OK IF POSITIVE
60$:	ERROR	T
70$:	ADD	FLTSGN,(R3)	;SET SIGN, IF ANY
FLTGEX:	CLR	MODE		;MAKE ABSOLUTE
	CLR	FLTWDC		;CLEAR COUNT
	MOV	(R3),VALUE	;PLACE FIRST GUY IN VALUE
	MOV	(SP)+,R0	;ORIGIONAL CHAR POINTER
	BEQ	10$		;ZERO (GOOD) IF ANY DIGITS PROCESSED
	MOV	R0,CHRPNT	;NONE, RESET TO WHERE WE CAME IN
	CLR	R3		;FLAG AS FALSE
10$:	MOV	R3,R0		;SET FLAG IN R0
	JMP	SETNB		;RETURN WITH NON-BLANK

FLTM54:				;*5/4
	CMP	(R3),#146314	;ROOM?
	BLO	10$
	CALL	FLTGRS
	INC	FLTBEX
10$:	CALL	FLTGSV		;SAVE IN BACKUP
	CALL	FLTGRS		;SCALE RIGHT
	CALL	FLTGRS
	BR	FLTGAD

FLTM50:				;*5
	CALL	FLTGSV
	CALL	FLTGLS
	CALL	FLTGLS

FLTGAD:				;ADD SAVE BUFFER TO FLTBUF
	MOV	R4,R2		;POINT TO SAVE AREA
10$:	ADD	6(R2),-(R2)	;ADD IN WORD
	MOV	R2,R1		;SET FOR CARRIES
20$:	ADC	-(R1)		;ADD IN
	BCS	20$		;CONTINUE RIPPLE, IF NECESSARY
	CMP	R2,R3		;THROUGH?
	BNE	10$		;  NO
	RETURN

FLTGRS:	CLC			;RIGHT SHIFT
	MOV	R3,R1		;RIGHT ROTATE
	ROR	(R1)+
	ROR	(R1)+
	ROR	(R1)+
	ROR	(R1)+
	RETURN

FLTGLS:				;LEFT SHIFT
	MOV	R4,R2
	ASL	-(R2)
	ROL	-(R2)
	ROL	-(R2)
	ROL	-(R2)
	RETURN

FLTGSV:	MOV	R3,R1		;MOVE FLTBUF TO FLTSAV
	MOV	R4,R2
	JMP	XMIT4


	ENTSEC	IMPURE
FLTBEG:				;START OF FLOATING POINT IMPURE
FLTSGN:	.BLKW			;SIGN BIT
FLTDOT:	.BLKW			;DECIMAL POINT FLAG
FLTEXP:	.BLKW			;DECIMAL EXPONENT
FLTBEX:	.BLKW	1		;BINARY EXPONENT (MUST PRECEED FLTBUF)
FLTBUF:	.BLKW	4		;MAIN AC
FLTSAV:	.BLKW	4

	ENTSEC	IMPLIN
FLTWDC:	.BLKW			;WORD COUNT

	XITSEC

	XITOVR

.ENDC

	.SBTTL	CONDITIONALS

	.GLOBL	IIF

	SETOVR	5

IIF:				;IMMEDIATE HANDLERS
	CALL	TCON		;TEST ARGUMENT
	TST	R3
	BMI	30$		;  BRANCH IF UNSATISFIED
	CMP	#CH.COM,R5	;COMMA?
	BNE	10$		;  NO
	GETCHR			;YES, BYPASS
10$:	MOV	CHRPNT,R1	;SAVE CURRENT LOCATION
	SETNB			;SET TO NOM-BLANK
	BIT	#LC.CND,LCMASK	;CONDITIONAL SUPPRESSION?
	BEQ	20$		;  NO
	MOV	R1,LCBEGL	;YES, SUPPRESS ALL UP TO COMMA
20$:	CLR	ARGCNT
	JMP	STMNT		;BACK TO STATEMENT

30$:	CLR	R5		;FALSE, BUT NO "Q" ERROR
	BR	ENDCX


				;CONCATENATED CONDITIONALS
	.IRP	ARG,	<EQ,GE,GT,LE,LT,NE,G,L,NZ,Z,DF,NDF>
	.GLOBL	IF'ARG
IF'ARG:
	.ENDM

	MOV	SYMBOL+2,SYMBOL	;TREAT SECOND HALF AS ARGUMENT
	CALL	TCONF		;EXAMINE IT
	BR	IF1		;INTO THE MAIN STREAM


	.GLOBL	IF,	IFT,	IFF,	IFTF,	ENDC

IF:				;MICRO-PROGRAMMMED CONDITIONAL
	CALL	TCON		;TEST ARGUMENT
IF1:	MOV	#CNDLVL,R1	;POINT TO LEVEL
	CMP	(R1),#15.	;ROOM FOR ANOTHER?
	BGT	IFOERR		;  NO, ERROR
	INC	(R1)		;YES, BUMP LEVEL
	CALL	PRTCND		;SET INDICATOR FIELD
	ASL	R3		;SET CARRY TO TRUE (0) OR FALSE (1)
	ROR	-(R1)		;ROTATE INTO CNDMSK
	ASL	R3
	ROR	-(R1)		;DITTO FOR CNDWRD
	BR	ENDCX

ENDC:				;END OF CONDITIONAL
	MOV	#CNDLVL,R1	;POINT TO LEVEL
	TST	(R1)		;IN CONDITIONAL?
	BLE	IFOERR		;  NO, ERROR
	CALL	PRTCND		;SET INDICATOR PRINT FIELD
	DEC	(R1)		;YES, DECREMENT
	ASL	-(R1)		;REDUCE MASK
	ASL	-(R1)		;  AND TEST WORD
	BR	ENDCX

IFT:				;IF TRUE SUB-CONDITIONAL
	MOV	CNDMSK,R3	;GET CURRENT
	BR	IFTF		;  AND BRANCH

IFF:				;IF FALSE SUB-CONDITIONAL
	MOV	CNDMSK,R3	;GET CURRENT CONDITION
	COM	R3		;USE COMPLEMENT AND FALL THROUGH

IFTF:				;UNCONDITIONAL SUB-CONDITIONAL
				;(R3=0 WHEN CALLED DIRECTLY)
	TST	CNDLVL		;CONDITIONAL IN PROGRESS?
	BLE	IFOERR		;  NO, ERROR
	CALL	PRTCND		;PRINT CONDITIONAL LEVEL
	ASL	CNDWRD		;MOVE OFF CURRENT FLAG
	ASL	R3		;SET CARRY
	ROR	CNDWRD		;MOV ON
ENDCX:	BIT	#LC.CND,LCMASK	;SUPPRESSION REQUESTED?
	BEQ	20$		;  NO
	MOV	LBLEND,R0	;YES, ANY LABEL?
	BEQ	10$		;  NO, SUPPRESS WHOLE LINE
	MOV	R0,LCENDL	;YES, LIST ONLY LABEL
	BR	20$

10$:	BIS	#LC.CND,LCFLAG	;MARK CONDITIONAL
20$:	RETURN

IFOERR:	ERROR	O		;CONDITION ERROR
	RETURN

PRTCND:	MOV	#140000,PF1	;SET TO PRINT A BYTE IN PF1
	MOV	CNDLVL,PF1+2	;PRINT VALUE OF NEST LEVEL
	RETURN

TCON:				;TEST CONDITION
	GSARG			;GET A SYMBOL
TCONF:	SCANW	CNDROL		;SCAN FOR ARGUMENT
	BEQ	IFAERR		;  ERROR IF NOT FOUND
	MOV	SYMBOL+2,R1	;GET ADDRESS
	ASR	R1		;LOW BIT USED FOR TOGGLE FLAG
	SBC	R3		;R3 GOES TO -1 IF ODD
	ASL	R1		;BACK TO NORMAL (AND EVEN)
	TST	CNDWRD		;ALREADY UNSAT?
	BNE	IFAERX		;  YES, JUST EXIT
	TSTARG			;BYPASS COMMA
	JMPOVR	R1		;JUMP TO HANDLER

IFAERR:	ERROR	A
IFAERX:	CLR	R5		;NO "Q" ERROR
	RETURN

	XITOVR


	GENCND	EQ,	TCONEQ
	GENCND	NE,	TCONEQ,	F
	GENCND	Z,	TCONEQ
	GENCND	NZ,	TCONEQ,	F
	GENCND	GT,	TCONGT
	GENCND	LE,	TCONGT,	F
	GENCND	G,	TCONGT
	GENCND	LT,	TCONLT
	GENCND	GE,	TCONLT,	F
	GENCND	L,	TCONLT
	GENCND	DF,	TCONDF
	GENCND	NDF,	TCONDF,	F
	.IF DF	XMACRO
	GENCND	B,	TCONB
	GENCND	NB,	TCONB,	F
	.ENDC

	SETOVR	5

	.IF DF	XMACRO
TCONB:	BEQ	TCONTR		;TRUE IF NULL
	CLR	R5		;SUPRESS Q ERROR IF NOT NULL
	BR	TCONFA
	.ENDC

TCONEQ:	ABSEXP			;EQ/NE, TEST EXPRESSION
	BEQ	TCONTR		;BRANCH IF SAT
TCONFA:	COM	R3		;  FALSE, TOGGLE
TCONTR:	RETURN			;TRUE, JUST EXIT

TCONGT:	ABSEXP
	BGT	TCONTR
	BR	TCONFA

TCONLT:	ABSEXP
	BLT	TCONTR
	BR	TCONFA

TCONDF:				;IF/IDF
	MOV	R3,R1		;SAVE INITIAL CONDITION
	CLR	R2		;SET "&"
	CLR	R3		;START OFF TRUE
10$:	GETSYM			;GET A SYMBOL
	BEQ	IFAERR		;  ERROR IF NOT A SYM
	SSRCH			;SEARCH USER SYMBOL TABLE
	CRFREF
	CLR	R0		;ASSUME DEFINED
	BIT	#DEFFLG,MODE	;GOOD GUESS?
	BNE	20$		;  YES
	COM	R0		;NO, TOGGLE
20$:	CMP	R0,R3		;YES, MATCH?
	BEQ	30$		;  YES, ALL SET
	MOV	R2,R3		;  NO
	COM	R3
30$:	MOV	R1,R2		;ASSUME "&"
	CMP	R5,#CH.AND	; "&"
	BEQ	40$		;  BRANCH IF GOOD GUESS
	CMP	R5,#CH.IOR	;PERHAPS OR?
	BNE	50$		;  NO
	COM	R2		;YES, TOGGLE MODE
40$:	GETNB			;BYPASS OP
	BR	10$		;TRY AGAIN

50$:	TST	R1		;IFDF?
	BEQ	60$		;  YES
	COM	R3		;NO, TOGGLE
60$:	RETURN

	ENTSEC	IMPPAS
				;CONDITIONAL STORAGE (MUST BE ORDERED)
CNDWRD:	.BLKW			;TEST WORD
CNDMSK:	.BLKW			;CONDITION MASK
CNDLVL:	.BLKW			;NESTING LEVEL
	XITSEC

	XITOVR

	.SBTTL	LISTING CONTROL

	.GLOBL	NLIST,	LIST

	SETOVR	2
	.ENABL	LSB
NLIST:	COM	R3		;MAKE R3 -1
LIST:
	ASL	R3		;MAKE R3 0/-2
	INC	R3		;NOW 1/-1
10$:	TSTARG			;TEST FOR ANOTHER ARGUMENT
	BNE	20$		;  VALID
	TST	ARGCNT		;NULL, FIRST?
	BNE	$NLXIT		;  NO, WE'RE THROUGH
	INC	ARGCNT		;YES, MARK IT
20$:	GETSYM			;TRY FOR A SYMBOL
$NLIST:	SCANW	LCDROL		;LOOK IT UP IN THE TABLE
	BEQ	90$		;  ERROR IF NOT FOUND
	CLR	R2
	CLR	R1
	MOV	R0,-(SP)	;SAVE COUNT
	SEC
30$:	ROL	R2
	ROL	R1
	SOB	R0,30$
	MOV	(SP)+,R0	;RESTORE COUNT
40$:	TST	EXMFLG		;CALLED FROM COMMAND STRING?
	BEQ	50$		;  NO
	BIS	R2,LCMCSI	;YES, SET DISABLE BITS
	BIS	R1,LCMCSI+2
	BR	60$		;  AND SKIP TEST

50$:	BIT	R2,LCMCSI	;THIS FLAG OFF LIMITS?
	BNE	80$		;  YES
	BIT	R1,LCMCSI+2
	BNE	80$
60$:	BIC	R2,LCMASK
	BIC	R1,LCMASK+2
	BIT	R2,#LC.		;NULL?
	BEQ	70$		;  NO
	CALL	PAGEX		;INDICATE LISTING DIRECTIVE
70$:	ASL	R0		;DOUBLE COUNT
	ADD	R3,LCLBAS-2(R0)	;UPDATE LIST LEVEL COUNT
	BGE	80$		;LEAVE IT .LIST IF => 0
	BIS	R2,LCMASK	;SET .NLIST IF < 0
	BIS	R1,LCMASK+2
80$:	TST	EXMFLG		;COME FROM CSI?
	BNE	$NLXIT		;YES. JUST LEAVE QUIETLY
	CLR	R2
	CLR	R1
	MOV	R3,-(SP)	;SAVE .LIST/.NLIST FLAG
	CALL	@SYMBOL+2	;DO SPECIAL
	MOV	(SP)+,R3	;RESTORE FLAG
	BR	10$		;TRY FOR MORE

90$:	ERROR	A
$NLXIT:	RETURN
	.DSABL	LSB

;	GENSWT	LI,LIST		;GENERATE /LI
;	GENSWT	NL,NLIST	;  AND /NL SWITCH ENTRIES

	.GLOBL	PAGE
PAGE:	INC	FFCNT		;SIMULATE FF AFTER THIS LINE
PAGEX:	BIS	#LC.LD,LCFLAG	;FLAG AS LISTING DIRECTIVE
	RETURN

	XITOVR

$NLBIN::MOV	#LBNROL,R2
	CALL	$NLARG		;UNPACK LINE
	TST	R3		;.NLIST?
	BPL	20$		;NOPE
10$:	RETURN			;YES. IGNORE STATMENT
20$:	TST	$.LOC		;ANY LOCATION DATA?
	BEQ	10$		;NOPE. IGNORE IT ALL
	MOV	#$.ID,R1	;POINT TO ARGUMENT BLOCK
	CLR	ROLUPD
	MOV	#SYMBOL,R3	;GET ADDRESS
30$:	MOV	R2,R0		;PASS ROL INDEX
	CALL	NEXT		;GET NEXT ROLL ENTRY
	BEQ	40$		;EMPTY
	BIC	#-32.,(R3)	;ZAP ALL BUT LS 4 BITS
	CMP	(R1),(R3)	;ID'S MATCH?
	BNE	30$		;NO
	DELETE			;YES. ZAP ENTRY
40$:	MOVB	(R1)+,(R3)+	;ID
	INC	R1
	MOVB	(R1)+,(R3)+	;LOCATION
	INC	R1
	MOVB	(R1)+,(R3)+	;LENGTH
	INC	R1
	CALL	CHKRDX		;CHECK RADIX
	MOV	(R1)+,-(SP)	;SAVE  RADIX
	TST	(R1)+		;LZS?
	BEQ	50$		;NOPE
	BIS	#200,(SP)	;YES. SIGNAL SAME
	TST	(R1)+		;SIGN?
	BEQ	50$		;NOPE.
	BIS	#100,(SP)	;YES. SIGNAL SAME
50$:	MOVB	(SP)+,(R3)	;PASS RADIX, LZS AND SIGN
	MOV	R2,R0		;GET ROLL INDEX
	CALL	APPEND		;STICK NEW ARGS INTO ROLL
	RETURN			;EXIT
	.PAGE
$NLLOC:	ADD	#6,R2			;SKIP UP 1 FIELD
$NLSEQ:	TST	(R1)+		;R1=R1+2
	CALL	$NLARG		;UNPACK LINE
	TST	R3		;LIST?
	BMI	10$		;.NLIST
	ADD	#$.SEQ,R2	;GETADDRESS
	TST	(R1)		;ANY DATA GIVEN?
	BEQ	10$		;NO. IGNORE IT ALL
	MOV	(R1)+,(R2)+	;MOVE IN LOCATION
	MOV	(R1)+,(R2)+	;LENGTH
	CALL	CHKRDX		;CHECK RADIX
	MOV	(R1),(R2)	;RADIX
10$:	RETURN

$NLSRC:	TST	(R1)+
	CALL	$NLARG		;UNPACK LINE
	TST	R3		;NLIST?
	BMI	20$		;YES. EXIT
	MOV	(R1)+,R0	;GET LOCATION
	BEQ	20$		;NO INPUT. IGNORE IT ALL
	TST	(R1)		;IS IT TO BE QUED?
	BNE	10$		;YES
	MOV	R0,$.SRC0	;UPDATE SOURCE POINTER
10$:	MOV	R0,$.SRC1	;ALSO QUE SPOT
20$:	RETURN
	.PAGE
$NLCOM:	TST	(R1)+
	CALL	$NLARG		;UNPACK LINE
	TST	R3
	BMI	10$		;NLIST COMMENTS
	MOV	(R1),$.COM	;POINT TO NEW COMMENTS FIELD
10$:	RETURN

$NLARG:	MOV	R2,-(SP)	;SAVE THIS
	MOV	R3,-(SP)	;AND THIS
	MOV	CRADIX,-(SP)	;AND THIS
	MOV	#10.,CRADIX	;DEFAULT LOCAL RADIX TO 10
	MOV	R1,R2		;POINT THIS TOO
	MOV	#$.ID,R0	;ADDRESS DATA FIELD
	ADD	R0,R1
	MOV	R1,-(SP)	;SAVE ADDRESS
	MOV	#VALUE,R4
	.REPT	6		;CLEAR ARGS
	CLR	(R0)+
	.ENDR
	CMP	#'=,R5		;KEY WORD?
	BNE	20$		;NOPE
10$:	GETNB			;SKIP =
20$:	CMP	#'(,R5		;OPEN?
	BEQ	40$		;NOPE
30$:	MOV	(SP)+,R1	;SET R1  TO POINT TO DATA
	MOV	(SP)+,CRADIX	;RESTORE RADIX
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R2	;RESTORE R2
	RETURN			;EXIT
40$:	GETNB			;SKIP (
50$:	CMP	#'/,R5		;NEW LINE WANTED?
	BNE	60$		;NOPE
	GETNB			;YES. SKIP /
	INC	$.NEWL		;SIGNAL SAME
	BR	120$		;SKIP THIS ARG
60$:	ABSEXP			;EVALUATE EXPRESSION
	CMP	#CH.XCL,R5	;TEXT?
	BNE	100$		;NO
	MOV	(R4),R3		;GET TEXT LOCATION
	BPL	70$		;OK
	CLR	R3		;CAN'T BE NEGATIVE
70$:	ADD	#OCTBUF-1,R3	;INDEX TO DATA FIELD
80$:	GETCHR			;GET NEXT CHARACTER
	BEQ	30$		;EOL
	CMP	#CH.XCL,R5	;END OF TEXT?
	BNE	90$		;NO. CONTINUE
	GETCHR			;GET NEXT CHAR
	CMP	#CH.XCL,R5	;2 IN A ROW?
	BNE	120$		;NO. NEXT ARG. ELSE GIVE 1
90$:	CMP	R3,#LINBUF	;CAN'T OVERFLOW
	BHIS	80$		;IGNORE IT
	MOVB	R5,(R3)+	;PUT TEXT INTO BUFFER
	BR	80$		;CONTINUE
100$:	CMP	$.ARG(R2),(R4)	;IS THE ARGUMENT LEGAL?
	BHIS	110$		;YES
	ERROR	A		;NO GIVE 'EM AN ERROR
	MOV	$.ARG(R2),(R4)	;AND PEAK IT
110$:	MOV	(R4),(R1)+	;PASS ARG
	TST	(R2)+		;UPDATE COUNT
120$:	CMP	#'),R5		;CLOSE?
	BEQ	10$		;YES. SKIP IT AND EXIT
	CMP	R1,#$.SGN+2	;END?
	BHIS	30$		;YES. EXIT
130$:	TSTARG			;SCOOT UP TO NEXT ARG
	BEQ	30$		;DONE
	BR	50$		;CONTINUE

	ENTSEC	IMPLIN
$.NEWL:	.BLKW
	XITSEC
	.PAGE
	ENTSEC	IMPPAS
$.ID:	.BLKW			;FORMAT ID #
$.LOC:	.BLKW			;TARGET OF DATA
$.LNTH:	.BLKW			;LENGTH OF FIELD
$.RDX:	.BLKW			;FIELD RADIX
$.LZS:	.BLKW			;IF .NE. SUPPRESS LEADING ZEROES
$.SGN:	.BLKW			;IF .NE. PREFIX A SIGN

	ENTSEC	DPURE
$.ARG:	.WORD	15.		;NO MORE THAN 15 FORMATS
	.WORD	132.		;LOCATION CAN'T BE > THAN 132
	.WORD	8.		;NUMBER FIELDS CAN'T BE GREATER THAN 8
	.WORD	16.		;RADIX CAN'T BE GREATER THAN 16
	.WORD	-1		;NO LIMIT ON LZS AND SGN
	.WORD	-1
	XITSEC

CHKRDX:	CMP	#1,(R1)		; 0 OR 1?
	BHIS	10$		;YES. USE DEFAULT RADIX
	CMP	#16.,(R1)	; 2-16?
	BHIS	20$		;YES. OK AS IS
	ERROR	A		;N.F.G.
	.IF eq,MACXX&.pdp11
10$:	MOV	#16.,(R1)	;RESET TO HEX
	.IFF
10$:	MOV	#8.,(R1)	;RESET TO OCTAL
	.ENDC
20$:	RETURN
	.PAGE
	.MACRO	GENLCT	MNE,INIT,LABL,LABL2	;GENERATE LISTING CONTROL TABLE
LC.'MNE=	1
...T	=<.-LCTBAS>/<RS.LCD*2>
...R	=...T
	.IIF GE,...T-16.,...R	=...R-16.
	.REPT	...R
LC.'MNE=	LC.'MNE+LC.'MNE
	.ENDR
	.GLOBL	LC.'MNE
	.RAD50	/MNE/
	.IF NB,LABL
	.WORD $NL'MNE
	.IFF
	.WORD $NLXIT
	.ENDC
	.IF NB	<INIT>
	.IIF LT,...T-16.,LCINI0	=LCINI0+LC.'MNE
	.IIF GE,...T-16.,LCINI1	=LCINI1+LC.'MNE
	.ENDC
	ENTSEC	IMPPAS
	.IIF NB,LABL2,LABL2:
	.BLKW
	ENTSEC	DPURE
	.ENDM

LCINI0=	0
LCINI1=	0

	ENTSEC	DPURE
LCTBAS:
	GENLCT	SEQ,,1,LCLBAS
	GENLCT	LOC,,1
	GENLCT	BIN,,1
	GENLCT	SRC,,1
	GENLCT	COM,,1
	GENLCT	BEX
	GENLCT	MD
	GENLCT	MC
	GENLCT	ME ,1
	GENLCT	MEB,1
	GENLCT	CND
	GENLCT	LD ,1
	GENLCT	TTM,1
	GENLCT	TOC
	GENLCT	SYM
	GENLCT	<   >,,,LCLVL	;NULL
	GENLCT	BYT
LCTTOP:

	.GLOBL	LCLVL
	ENTSEC	IMPURE
LCSAVE:				;LISTING CONTROL SAVE BLOCK
LCMASK:	.BLKW	2		;MASK BITS
LCMCSI:	.BLKW	2		;COMMAND STRING STORAGE
LCHEXC	=LCMASK+2
LCSAVL=	.-LCSAVE

LCSBAK:	.BLKW	LCSAVL/2	;FOR INITTING PASS 2


	ENTSEC	IMPLIN
LCFLAG:	.BLKW			;FLAG BITS
LCBEGL:	.BLKW			;POINTER TO START OF LINE
LCENDL:	.BLKW			;POINTER TO END OF LINE
LBLEND:	.BLKW			;END OF LABEL (FOR PARSING)

	ENTSEC	XCTPRG
	.GLOBL	LCBITS
	MOV	(PC)+,@(PC)+
LCBITS:	.WORD	LCINI0
	.WORD	LCSBAK+<LCMASK-LCSAVE>
	MOV	(PC)+,@(PC)+
LCBTS1:	.WORD	LCINI1
	.WORD	LCSBAK+<LCMASK+2-LCSAVE>

	ENTSEC	XCTPAS		;EXECUTE THIS CODE EACH PASS
	MOV	#LCSBAK,R1	;RESET LISTING FLAGS
	MOV	#LCSAVE,R2
	MOV	R2,-(SP)	;SAVE R2
	XMIT	LCSAVL/2
	MOV	(SP)+,R2	;RESTORE R2
	MOV	(R2)+,R0	;GET LIST CONTROL BITS
	MOV	(R2),R1
	MOV	#LCLBAS,R2	;POINT TO LEVEL COUNT WORDS
10$:	CLC			;MOVE BITS RIGHT DRAGGING THRUOGH A 0
	ROR	R1
	ROR	R0
	SBC	(R2)+		;INIT THE LEVEL COUNT
	MOV	R0,-(SP)	;UNTIL NO MORE BITS SET
	BIS	R1,(SP)+
	BNE	10$
	XITSEC

MACP0:				;SAVE OUTPUT SWITCHES
	MOV	#LCSAVE,R1	;REVERSE OF ABOVE
	MOV	#LCSBAK,R2
	XMIT	LCSAVL/2
	MOV	EDMASK,EDMBAK	;DITTO FOR ENABL/DSABL
	RETURN

	.SBTTL	ENABL/DSABL FUNCTIONS

	.GLOBL	ENABL,	DSABL

	SETOVR	2
	.ENABL	LSB
DSABL:	COM	R3		;R3=-1
ENABL:				;R3=0
10$:	GSARG			;GET A SYMBOLIC ARGUMENT
	BEQ	70$		;END IF NULL
$EDABL:	SCANW	EDTROL		;SEARCH THE TABLE
	BEQ	60$		;  NOT THERE, ERROR
	CLR	R2		;COMPUTE BIT POSITION
	SEC
20$:	ROL	R2
	SOB	R0,20$
	TST	EXMFLG		;CALLED FROM COMMAND STRING?
	BEQ	30$		;  NO
	BIS	R2,EDMCSI	;YES, SET DISABLE BITS
	BR	40$		;  AND BYPASS TEST

30$:	BIT	R2,EDMCSI	;OVER-RIDDEN FROM CSI?
	BNE	10$		;  YES, IGNORE IT
40$:	BIC	R2,EDMASK	;NO, CLEAR SELECTED BIT
	TST	R3		;ENDBLE?
	BEQ	50$		;  YES, LEAVE IT CLEAR
	BIS	R2,EDMASK	;NO, CLEAR IT
50$:	MOV	SYMBOL+2,-(SP)	;MAKE IT PIC
	TST	R3		;SET FLAGS
	CALL	@(SP)+		;CALL ROUTINE
	BR	10$

60$:	ERROR	A
70$:	RETURN
	.DSABL	LSB
	XITOVR


	ENTSEC	IMPURE
EDMASK:	.BLKW			;CONTAINS SET FLAGS
EDMCSI:	.BLKW			;BITS FOR CSI OVERRIDE
EDMBAK:	.BLKW			;TO RE-INIT FOR PASS 2

	ENTSEC	XCTPRG
	.GLOBL	EDBITS
	.BLKW	1
EDBITS:
	.BLKW	-1
	MOV	#EDINIT,EDMBAK	;SET DEFAULT CONDITIONS

	ENTSEC	XCTPAS
	MOV	EDMBAK,EDMASK	;SET EACH PASS

	XITSEC


;	GENSWT	EN,ENABL	;GENERATE /EN
;	GENSWT	DS,DSABL	;  AND /DS SWITCH TABLE ENTRIES

	.GLOBL	CRFTAB,ECREF,DCREF,CRFFLG

DCREF:	COM	R3		;R3 => -1
ECREF:				;R3 => 0
	TST	PASS		;PASS 1?
	BNE	20$		;NOPE
10$:	RETURN			;YEP. DO NOTHING.
20$:	GSARG			;GET ARGUMENT
	BNE	30$		;SOMETHING THERE
	MOV	CRFTAB+2,R1	;USE DEFAULTS
	BR	70$
30$:	MOV	#CRFTAB,R2
40$:	CMP	R0,(R2)+	;LOOK FOR DATA IN TABLE
	BEQ	60$		;FOUND IT
	TST	(R2)+		;SKIP OVER FLAG BITS
	TST	(R2)		;END?
	BNE	40$		;NO
	ERROR	A		;DIDN'T FIND IT
50$:	GSARG			;GET THE NEXT ARG
	BNE	30$		;PROCESS IT
	RETURN			;DONE
60$:	MOV	(R2),R1		;GET FLAG BITS
70$:	MOV	CRFFLG,R0	;GET REQUEST BITS
	COM	R0
	BIC	R0,R1		;CHANGE ONLY OPTIONS TYPED AT CSI
	TST	R3
	BMI	80$		;TURN OFF BIT(S)
	BIS	R1,CRFTST	;TURN ON BIT(S)
	BR	50$
80$:	BIC	R1,CRFTST
	BR	50$
	.PAGE
	.SBTTL CROSS/NOCROSS

NOCRO::	INC	R3		;NO = 1
CROSS::				;YES = 0
	TSTARG			;CHECK FOR ARG
	BNE	10$		;GOT ONE
	RETURN

10$:	GETSYM			;GET SYMBOL
	BNE	20$		;OK
	ERROR	A		;NOT A SYMBOL, ERROR
	BR	CROSS		;CONTINUE

20$:	SCAN	CRFROL		;LOOK IN CREF ROLL
	TST	R3		;IN/OUT?
	BEQ	30$		;OUT
	INSERT			;IN
	BR	CROSS

30$:	DELETE			;OUT
	BR	CROSS
	.PAGE
	.SBTTL SYMBOL ATTRIBUTE DIRECTIVE

SYMBO::	GSARG			;GET USER SYMBOL
	BNE	20$		;OK
10$:	ERROR	A		;NO SYMBOL, ERROR
	RETURN

20$:	MOV	#SYMBOL+2,R4	;POINT TO SYMBOL
	MOV	(R4),R2		;SAVE SYMBOL
	MOV	-(R4),R1
	GSARG
	BEQ	10$		;NO SYMBOL, ERROR
	SEARCH	SYMROL		;LOOK IN USER SYMBOL TABLE
	BISB	FLAGS,R3	;PASS SYMBOL FLAGS TO USER
	SEARCH	PSTROL		;LOOK IN PERM SYMBOL TABLE
.if df,dirtop	; if directives are in a different roll
	bne	30$
	search	dirrol		; keep looking
.endc
	BEQ	50$		;NOT THERE
30$:	MOV	#400,R0
	TST	FLAGS		;OPCODE?
	BMI	40$		;YEP
	ASL	R0		;NOPE, DIRECTIVE
40$:	BIS	R0,R3

50$:	SEARCH	MACROL		;LOOK IN MACRO ROLL
	BEQ	60$		;NOT THERE
	BIS	#2000,R3

60$:	SEARCH	SECROL		;LOOK IN PSECT ROLL
	BEQ	70$		;NO
	BIS	#4000,R3

70$:	SEARCH	STNROL		;LOOK IN STACK NAME ROLL
	BEQ	80$
	BIS	#10000,R3

80$:	MOV	R1,(R4)+	;RESTORE USER SYMBOL NAME
	MOV	R2,(R4)+
	MOV	#DEFFLG,(R4)+	;SIGNAL DEFINED
	MOV	R3,(R4)		;PASS VALUE
	SEARCH	SYMROL		;POSITION POINTERS
	INSERT			;STUFF IT
	RETURN			;AND EXIT
	.PAGE
	.SBTTL	LISTING STUFF

SETPF0::			;SET PRINT FIELD ZERO
	MOV	CLCFGS,PF0	;SET CURRENT LOCATION FLAGS
	BISB	#100,PF0+1	;ASSUME WORD
	MOV	CLCLOC,PF0+2	;SET LOCATION
	RETURN

SETPF1::			;SET PRINT FIELD ONE
	MOV	MODE,PF1	;SET MODE OF CURRENT VALUE
	BISB	#100,PF1+1	;ASSUME WORD
	MOV	VALUE,PF1+2
	RETURN

	ENTSEC	IMPLIN
PF0::	.BLKW	2
PF1::	.BLKW	2
PF2::	.BLKW	2
	XITSEC


SETWRD:	BIC	#100000,(R1)	;FORCE TO PRINT WORD
	BR	SETWDB
SETBYT:	BIS	#100000,(R1)	;FORCE TO PRINT BYTE MODE
SETWDB:	MOV	R3,-(SP)	;SAVE SOME REGS
	MOV	R1,-(SP)
	MOV	(R1),-(SP)
	MOV	R2,-(SP)
	MOV	#WDBFLD-2,R2	;POINT TO WORK SPACE
	MOV	#"00,R0		;PRE-FILL WITH ZEROES
	TST	$.LZS		;FILL WITH ZEROES?
	BPL	30$		;YES
	MOV	#40*400+40,R0	;NO. FILL WITH BLANKS
	TST	$.SGN		;UNSIGNED?
	BPL	30$		;YES.
	TST	(R1)		;BYTE MODE?
	BPL	10$		;NO
	MOVB	2(R1),$.SGN+1	;SIGN EXTEND TO UPPER BYTE
	BPL	30$		;+. OK AS IS
	BR	20$		;-. NEED TO NEGATE
10$:	MOV	2(R1),$.SGN	;SET SIGN
	BPL	30$		;CONTINUE
20$:	NEG	2(R1)		;INVERT IT
30$:	MOV	R0,(R2)+
	MOV	R0,(R2)+
	MOV	R0,(R2)+
	MOV	R0,(R2)+	;LEAVE POINTER 1 PLACE TO THE RIGHT
	CLR	R0
	BISB	2(R1),R0	;GET VALUE.
	TST	(R1)		;BYTE MODE?
	BMI	40$		;YES.
	MOV	2(R1),R0	;GET WHOLE WORD
40$:	MOV	R0,R1		;SAVE VALUE IN R1
	.PAGE
STWDB0:	MOVB	$.RDX,R3	;GET PRINT RADIX
	BLE	60$		;N.F.G.
	MOV	R3,R0		;PUT IT IN R0
10$:	ASR	R0		;FIND A BIT
	BCC	10$
	BNE	50$		;CAN'T DO QUICK DIVIDE
	DEC	R3		;ADJUST IT
	COM	R3		;MAKE IT A MASK
20$:	MOV	R1,R0		;GET DIVIDEND
	BIC	R3,R0		;GET REMAINDER
	CMP	R2,#WDBFLD	;OVERFLOW?
	BLOS	40$		;YES. IGNORE RESULT
	MOVB	HEX(R0),-(R2)	;ASCIFY AND STORE REMAINDER
	BIT	R3,R1		;ANY BITS LEFT?
	BEQ	40$		;NOPE. EXIT
	MOV	R3,R0		;GET MASK
30$:	ASR	R0		;DIVIDE DATA BY RADIX
	BCS	20$		;CONTINUE
	ROR	R1		;DON'T SIGN EXTEND
	BR	30$
40$:	COM	R3		;FIX RADIX
	INC	R3
	BR	60$
50$:	CLR	R0		;INIT DIVIDEND
	DIV	R3,R0		;DIVIDE R0,R1 BY RADIX
	CMP	R2,#WDBFLD	;FIELD OVERFLOW?
	BLOS	60$		;YES. HIGH ORDER TRUNCATION
	MOVB	HEX(R1),-(R2)	;ASCIFY REMAINDER AND STORE
	MOV	R0,R1		;PUT QUOTIENT IN R1
	BNE	50$		;CONTINUE UNTIL QUOTIENT = 0
60$:	TST	$.LZS		;SUPRESS LEADING ZEROES?
	BEQ	70$		;NOPE. IGNORE SIGN
	TST	$.SGN		;SIGNED?
	BPL	70$		;NOPE
	MOVB	#'-,-(R2)	;YES. PREFIX A MINUS SIGN
70$:	MOV	#WDBFLD,R1	;POINT TO WORK FIELD
	CMP	R3,#10.		;RADIX 10?
	BLO	90$		;NO. MUST BE 8. GIVE ALL 6 CHARACTERS
	BEQ	80$		;YES. GIVE 5
	INC	R1		;MUST BE 16. GIVE 4
80$:	INC	R1
90$:	MOV	(SP)+,R2	;GET POINTER
	MOV	$.LNTH,R0	;LENGTH SPECIFIED?
	BNE	120$		;YES. DO SPECIAL
	MOV	#40,R0		;GET A SPACE CODE
	TST	(SP)+		;WORD MODE?
	BPL	100$		;YES. LEAVE EVERYTHING AS IS
	CMPB	(R1)+,(R1)+	;SKIP AT LEAST 2 CHARS
	MOVB	R0,(R2)+	;BLANK FILL
	MOVB	R0,(R2)+
	CMP	R3,#8.		;RADIX 8?
	BHI	100$		;NO.
	MOVB	R0,(R2)+	;BLANK 1 MORE
	INC	R1		;1 LESS DIGIT
100$:	MOVB	(R1)+,(R2)+	;UNLOAD DATA
	CMP	R1,#WDBFLD+6.	;UNTIL NO MORE
	BLO	100$
110$:	PULL	R1
	PULL	R3
	RETURN

120$:	MOV	#WDBFLD+6,R1	;POINT TO END OF WORK FIELD
	ADD	R0,R2		;SKIP TO END OF DATA FIELD
	MOV	R2,(SP)		;PASS AN UPDATED R2 BACK
130$:	MOVB	-(R1),-(R2)	;SEND ASCIFIED DATA
	DEC	R0		;COUNT IT
	BLE	140$		;LENGTH EXCEEDED
	CMP	R1,#WDBFLD-1	;WORK FIELD EXCEEDED?
	BHIS	130$		;NO. CONTINUE
140$:	PULL	R2		;RESTORE R2
	BR	110$		;EXIT
	.DSABL	LSB

	ENTSEC	IMPLIN
	.BLKW			;OVERFLOW AREA
WDBFLD:	.BLKW	3

	ENTSEC	TXTBYT
HEX:	.ASCII	/0123456789ABCDEF/
	XITSEC
	.PAGE
	.SBTTL	OBJECT CODE HANDLERS
	.GLOBL OBJTIM,OBJERR,OBJERC

ENDP1:				;END OF PASS HANDLER
	ENTOVR	4
	.IF NDF	XREL
	CALL	SETMAX		;SET MAX LOCATION
	.IFTF
.IF df ed.gbl		; do we support this?
	BIT	#ED.GBL,EDMASK	;AUTO GLOBAL MODE?
	BNE	30$		;NOPE, SKIP THIS THEN
	MOV	ROLBAS+SYMROL,R4 ;POINT TO SYMBOL TABLE
	MOV	ROLTOP+SYMROL,R5 ;POINT TO TOP OF TABLE
10$:	CMP	R4,R5		;AT THE LIMIT YET?
	BHIS	30$		;YEP, STOP ZAPPING	
	BIT	#GLBFLG!DEFFLG,FLAGS-SYMBOL(R4)	;GLOBAL OR DEFINED?
	BNE	20$		;YEP, LEAVE IT THEN	
.if ndf,dfgflg
	bis	#glbflg,flags-symbol(r4)	;give global attributes
.iff
	BIS	#GLBFLG!DFGFLG,FLAGS-SYMBOL(R4) ;GIVE GLOBAL ATTRIBUTES
.endc
20$:	ADD	#RS.SYM*2,R4	;UP TO NEXT ITEM
	BR	10$		;CONTINUE
30$:
.ENDC	;df ed.gbl
	TSTB	IOFTBL+BINCHN	;ANY OBJ FILE?
	BEQ	ENDP1B		;  NO
	CALL	OBJINI		;INIT OUTPUT
	.IFT
	MOV	#BLKT01,@BUFTBL+RELCHN	;SET BLOCK TYPE 1
	MOV	#PRGTTL,R1	;SET "FROM" INDEX
	CALL	GSDDMP		;OUTPUT GSD BLOCK
.IF NDF	DOSV4
	MOV	#PRGIDN,R1	;POINT TO SUB-TTL BUFFER
	TST	4(R1)		;SET?
	BEQ	40$		;  NO
	CALL	GSDDMP		;YES, STUFF IT
.ENDC
40$:	CLR	-(SP)		;INIT FOR SECTOR SCAN
50$:	MOV	(SP)+,ROLUPD	;SET SCAN MARKER
	NEXT	SECROL		;GET THE NEXT SECTOR
	BEQ	ENDP1A		;BRANCH IF THROUGH
	MOV	ROLUPD,-(SP)	;SAVE MARKER
.IF NDF	RSX11D
	MOV	#MODE,R1
	MOV	(R1),R5		;SAVE SECTOR
	CLRB	R5		;ISOLATE IT
	SWAB	R5		;  AND PLACE IN RIGHT
.IF ne,MACXX&.pdp11
	BIC	#-400,(R1)	;CLEAR UNUSED BITS
.IFF
	BIC	#^C<CSTREL!CSTBSE!CSTALO>,(R1)	;CLEAR UNUSED BITS
.ENDC
	BIS	#<GSDT05>+CSTDEF,(R1)+	;SET TO TYPE 5, PSECT DECLARATION
	MOV	R5,(R1)+	;ASSUME ABS
.IFF
	MOV	#SECTOR,R1
	CLR	R5
	BISB	(R1),R5
	MOVB	#GSDT05/400,(R1)+
	CLR	(R1)+
	BITB	#CSTREL,MODE
.ENDC
.IIF NDF RT11,	BEQ	60$		;  OOPS!
	MOV	(R1),-(R1)	;  REL, SET MAX
60$:	CLR	ROLUPD		;SET FOR INNER SCAN
70$:	MOV	#SYMBOL,R1	;set up regs
	MOV	#MODE,R3
	CALL	GSDDMP		;OUTPUT THIS BLOCK
80$:	NEXT	SYMROL		;FETCH THE NEXT SYMBOL
	BEQ	50$		;  FINISHED WITH THIS GUY
90$:	BIT	#GLBFLG,(R3)	;GLOBAL?
	BEQ	80$		;  NO
	CMPB	SECTOR,R5	;YES, PROPER SECTOR?
	BNE	80$		;  NO
	bit	#defflg,(r3)	;defined?
	bne	100$		;yep, ok then
	tst	value		;any references?
	beq	80$		;nope, don't include it in the GSD
100$:	BIC	#^C<DEFFLG!RELFLG!GLBFLG>,(R3)	;CLEAR MOST
	BIS	#GSDT04,(R3)	;SET TYPE 4
	BR	70$		;OUTPUT IT

ENDP1A:	BIC	#^C<RELFLG>,ENDVEC+4	;CLEAR ALL BUT REL FLAG
	BIS	#GSDT03+DEFFLG,ENDVEC+4
	MOV	#ENDVEC,R1
	CALL	GSDDMP		;OUTPUT END BLOCK
	CALL	OBJDMP		;DUMP IT
	MOV	#BLKT04,@BUFTBL+RELCHN	;INIT FOR TEXT BLOCKS
	.IFTF
ENDP1B:
	.IFT
	CLR	ROLUPD		;SET FOR RE-INIT SCAN
10$:	NEXT	SECROL		;GET THE NEXT ENTRY
	BEQ	20$		;  BRANCH IF FINISHED
	CLR	VALUE		;FOUND, RESET PC
	INSERT			;PUT BACK IN TABLE
	BR	10$

20$:
	.IFTF
	INC	PASS		;SET FOR PASS 2
	RETURN


	.IFT
GSDDMP:				;DUMP A GSD BLOCK
	MOV	#4*2,R0		;FOUR WORDS PER GSD ENTRY
	CALL	TSTRLD		;ROOM?
	JMP	XMIT4		;WE HAVE NOW.  STUFF ENTRY

	.ENDC

	XITOVR

	.SBTTL ENDP2 Print symbol table
ENDP2:				;END OF PASS 2
	ENTOVR	4
.IF NDF	XREL
	CALL	SETMAX		;SET MAX LOCATION
.IFTF
	MOV	#SYMTXT,R1
	MOV	#STLBUF,R2
	MOVBYT			;SET "SYMBOL TABLE" SUB-TITLE
	TST	OBJPNT		;ANY OBJECT OUTPUT?
	BEQ	10$		;  NO
	CALL	OBJDMP		;YES, DUMP IT
.IFT
	MOVB	ERRCNT,OBJERC	;PASS ERROR COUNT TO OBJECT MODULE
	MOVB	WRNCNT,OBJERC+1	;AND WARNING COUNT
	MOV	#BLKT01,@BUFTBL+RELCHN	;SET "GSD" type
	MOV	#OBJTIM,R1	;TIME/DATE
	CALL	GSDDMP		;DUMP DATE/TIME
	CALL	GSDDMP		;DUMP LANGUAGE/ERROR/WARN COUNTS
	CALL	OBJDMP		;FLUSH IT OUT
	MOV	#BLKT02,@BUFTBL+RELCHN	;SET "END OF GSD"
	CALL	RLDDMP
	MOV	#BLKT06,@BUFTBL+RELCHN	;SET END OF MODULE
	CALL	RLDDMP		;DUMP IT
	.ENDC
	.IF NDF	XEDABS
	BIT	#ED.ABS,EDMASK	;ABS OUTPUT?
	BNE	10$		;  NO
	MOV	OBJPNT,R0
	MOV	ENDVEC+6,(R0)+	;SET END VECTOR
	MOV	R0,OBJPNT
	CALL	OBJDMP
	.ENDC
10$:	TSTB	LSTDEV		;ANY LISTING OUTPUT?
	BEQ	20$		;  NO
	BIT	#LC.SYM,LCMASK	;SYMBOL TABLE SUPPRESSION?
	BEQ	30$		;  NO
20$:	RETURN			; YES, JUST EXIT

30$:	CLR	LPPCNT		;FORCE NEW PAGE
	MOV	#$.LNTH,R1	;POINT TO SETBYT CONTROLS
	CLR	(R1)+		;NO LENGTH (INHERENT MODE)
	.IF eq,MACXX&.pdp11
	MOV	#16.,(R1)+	;SYMBOL TABLE PRINTS IN HEX
	.IFF
	MOV	#8.,(R1)+	;SYMBOL TABLE PRINTS IN OCTAL
	.ENDC
	CLR	(R1)+		;DON'T SUPPRESS LEADING ZEROES
	CLR	(R1)		;NO SIGN
	MOV	#3,SYMCNT	;DEFAULT # OF COLUMNS
	.IF NDF	XLCTTM
	BIT	#LC.TTM,LCMASK	;LINE PRINTER MODE?
	BEQ	40$		;NOPE
	MOV	#5,SYMCNT	;ELSE USE 5 COLUMNS
	.ENDC
40$:
	.PAGE
EP20:	MOV	ROLTOP+SYMROL,R1  ;COMPUTE SIZE OF SYMBOL TABLE
	SUB	ROLBAS+SYMROL,R1
	BLOS	ENDP2A		;NO SYMBOLS
	MOV	SYMCNT,R3	;NUMBER OF SYMBOLS/LINE
	IMULI	RS.SYM*2,R3	;* NUMBER OF BYTES/SYMBOL
	CLR	R0
	DIV	R3,R0		;DIVIDED INTO SIZE OF TABLE = LINES TO PRINT
	TST	R1		;REMANIDER?
	BEQ	10$		;NOPE
	INC	R0		;ROUND UP TO NEXT LINE
10$:	MOV	R0,-(SP)	;SAVE TOTAL LINE COUNT
	TST 	-(SP)		;MAKE A HOLE ON STACK
	MOV	ROLBAS+SYMROL,-(SP)	;POINT TO BEGINING OF ROLL

20$:	MOV	#LPP-3,R4	;GET LINES FREE ON PAGE

30$:	SUB	R4,4(SP)	;TAKE LINES TO BE PRINTED ON THIS PAGE
	BPL	40$		;   FROM TOTAL. STILL SOME LEFT.
	ADD	4(SP),R4	;ELSE USE RESIDUAL COUNT
40$:	MOV	R4,2(SP)	;PUT A COPY IN HOLE ON STACK
	IMULI	RS.SYM*2,R4	;COMPUTE BYTES TO SKIP PER COLUMN

50$:	CLR	ITMCNT		;0 => ITEM COUNTER
	MOV	#LINBUF,R2	;POINT TO LINE BUFFER
	MOV	SYMCNT,R5	;COLUMN COUNTER

60$:	MOV	(SP),R1		;POINT TO SYMBOL ROLL
	ADD	ITMCNT,R1	;POINT TO SYMBOL
	CMP	R1,ROLTOP+SYMROL  ;OFF THE END?
	BHIS	110$		;YEP. TERMINATE LINE
	MOV	R2,-(SP)	;SAVE POSITION
	MOV	#SYMBOL,R2	;POINT TO TEMPORARY PLACE
	XMIT	4		;COPY IN SYMBOL
	MOV	(SP)+,R2
	R50UNP			;UNPACK THE SYMBOL
	MOV	#MODE,R1	;POINT TO MODE BITS
	MOV	#ENDP2T,R3
	CALL	ENDP2C		;put in = or space and % or space
	BIT	#DEFFLG,(R1)	;DEFINED?
	BEQ	70$		;  NO
	CALL	SETWRD
	BR	80$

70$:	movb	#space,-2(r2)	;else step on the =
	MOV	#STARS,R1	;PRINT STARS INSTEAD
	MOVBYT			;UNDEFINED, SUBSTITUTE ******
80$:
	.IF eq,MACXX&.pdp11
	MOVB	#SPACE,(R2)+	;SPACE LISTING
	.ENDC
90$:	CALL	ENDP2C
	.IF eq,MACXX&.pdp11
	MOVB	#TAB,(R2)+	;2 TABS REQUIRED FOR HEX SYMBOL TABLE
	.ENDC
	.IIF DF	RSX11D,	CALL	ENDP2X
	MOV	#SECTOR,R1
	MOVB	(R1),-(R1)	;MOVE SECTOR DOWN
	BITB	#-2,(R1)	;SECTOR 2-377?
	BEQ	100$		;NOPE
	TST	-(R1)		;BACK UP 1
	CALL	SETBYT
100$:	MOVB	#TAB,(R2)+	;SEPARATOR
	ADD	R4,ITMCNT	;UP TO NEXT ITEM
	SOB	R5,60$		;NEXT

110$:	CALL	ENDP2B		;OUTPUT LINE
	ADD	#RS.SYM*2,(SP)	;TO NEXT SYMBOL
	DEC	2(SP)		;COUNT DOWN
	BGT	50$		;ANOTHER LINE
	TST	4(SP)		;ANY MORE?
	BLE	120$		;NOPE
	SUB	R4,ITMCNT	;ADJUST POINTER
	ADD	ITMCNT,(SP)	;UPDATE POSITION TO NEXT PAGE
	BR	20$		;CONTINUE

120$:	ADD	#6,SP		;PURGE STACK

	ENTSEC	IMPURE
SYMCNT:	.WORD	0
ITMCNT:	.BLKW
	XITSEC

ENDP2A:
	.IF NDF	XREL
	CLR	ROLUPD		;SET FOR SECTOR SCAN
10$:	CALL	ENDP2B		;OUTPUT LINE
	NEXT	SECROL		;GET THE NEXT ENTRY
	BEQ	ENDP2D		;  EXIT IF END OF ROLL
	R50UNP			;PRINT THE NAME,
	MOVB	#TAB,(R2)+
	MOV	#VALUE,R1
	CALL	SETWRD		;  THE VALUE,
	MOVB	#TAB,(R2)+
	MOVB	-(R1),-(R1)	;MOVE DATA 1 BYTE BACK
	TST	-(R1)		;POINT 2 AWAY FROM IT
	CALL	SETBYT		;  AND THE ENTRY NUMBER
	BR	10$
	.IFF
	RETURN
	.ENDC

ENDP2B:	CLRB	(R2)
	PUTLP	#LINBUF
	MOV	#LINBUF,R2	;RESET TO START OF BUFFER
ENDP2D:	RETURN

ENDP2C:	CALL	ENDP2X
ENDP2X:	MOV	(R3)+,R0
	BIT	(R3)+,MODE
	BNE	10$
	SWAB	R0
10$:	MOVB	R0,(R2)+
	RETURN

	ENTSEC	DPURE
ENDP2T:
	.ASCII	/ =/
	.WORD	LBLFLG
	.ASCII	/% /
	.WORD	REGFLG
	.ASCII	/R /
	.WORD	RELFLG
	.ASCII	/G /
	.WORD	GLBFLG
	.IF DF	RSX11D
	.ASCII	/X /
	.WORD	DFGFLG
	.ENDC

	ENTSEC	TXTBYT
	.IF ne,MACXX&.pdp11
STARS:	.ASCIZ	/******/
	.IFF
STARS:	.ASCIZ	/****/
	.ENDC
SYMTXT:	.ASCIZ	/SYMBOL TABLE/
	XITSEC
	XITOVR


	ENTSEC	XCTPAS		;EXECUTE EACH PASS
	COMB	OBJSEC		;FORCE SEQUENCE BREAK
	XITSEC

LST.KB=	1			;TELETYPE LISTING
LST.LP=	2			;LPT LISTING

PUTKB:	MOV	#LST.KB,LSTREQ	;SET REQUEST
	BR	PUTLIN

PUTKBL:	MOV	#LST.KB,LSTREQ	;SET FOR TTY
PUTLP:	BISB	LSTDEV,LSTREQ	;LPT

PUTLIN:				;OUTPUT A LINE
	SAVREG			;STACK REGISTERS
	MOV	R0,R1		;ARG TO R1
	MOVB	LSTREQ,R4	;GET REQUEST
	CLR	LSTREQ		;CLEAR IT
	TST	R4
	BEQ	PUTLI9		;JUST EXIT IF EMPTY
	BGT	PUTLI2		;OMIT HEADER IF NOT LISTING
	DEC	LPPCNT		;YES, DECREMENT COUNT
	BGT	PUTLI2		;SKIP IF NOT TIME
	ENTOVR	8
PUTLI1:	MOV	#LPP,LPPCNT	;RESET COUNT
	MOV	R1,-(SP)	;STACK CURRENT POINTER
	TST	PASS
	BEQ	20$
	MOV	TTLBRK,R2	;END OF PRE-SET TITLE
	MOV	#PAGMNE,R1
	MOVBYT			;MOVE "PAGE" INTO POSITION
	MOV	PAGNUM,R1
	DNC			;CONVERT TO DECIMAL
	INC	PAGEXT
	BEQ	10$
	MOVB	#CH.ADD,(R2)+
10$:	CLRB	(R2)
20$:	PUTLP	#TTLBUF		;PRINT TITLE
	PUTLP	#STLBUF		;  SUB-TITLE,
	PUTLP	#CRLF		;  AND A BLANK LINE
	MOV	(SP)+,R1
	XITOVR	INLINE		;FALL THROUGH

PUTLI2:	$WAIT	LST		;WAIT ON PREVIOUS OUTPUT
	MOV	BUFTBL+LSTCHN,R2	;SET DESTINATION INDEX
	MOV	R2,R3		;SAVE A COPY
10$:	MOVB	(R1)+,(R2)+	;MOVE CHARACTER TO OUTPUT BUFFER
	BGT	10$		;LOOP IF NOTHING SPECIAL
	MOVB	-(R2),R0	;SPECIAL, BACK UP AND SET R0
	BEQ	20$		;END IF NULL
	.IF NDF	XEDLC
	BICB	#200,(r2)+	;CLEAR SIGN BIT IN dest
	BNE	10$		;keep moving if lower case
	MOVB	#CH.QM,-1(R2)	;MUST BE ERROR, give 'em a bad sign
	.IFF
	MOVB	#CH.QM,(R2)+	;ILLEGAL CHAR, SET "?"
	.ENDC
	BR	10$

20$:	CMP	R2,R3		;AT BEGINNING?
	BEQ	30$		;  YES, DON'T RETREAT
	MOVB	-(R2),R0	;FETCH PRECEDING CHAR
	BITB	#CT.SP!CT.TAB,CTTBL(R0)	;BLANK?
	BNE	20$		;  YES, TRIM IT
	CMPB	#VT,(R2)+	;MOVE TO END, A VT?
	BEQ	40$		;  YES, NO CR/LF
30$:	MOVB	#CR,(R2)+	;STUFF CR
	MOVB	#LF,(R2)+	;SET LF
40$:	SUB	R3,R2		;COMPUTE CHARACTER COUNT
	MOV	R2,@CNTTBL+LSTCHN	;SET COUNT
	ASR	R4		;KB REQUESTED?
	BCC	50$		;  NO
	.IF NDF	RT11
	$WRITW	CMO		;TYPE THE LINE
	.IFF
	ADD	R3,R2
	CLRB	-(R2)		;SET STOPPER
	.PRINT	BUFTBL+LSTCHN
	MOVB	LSTDEV,R4	;GET LISTING DEVICE DATA
	BIC	#1,R4		;NO KB NEXT TIME THRU
	BR	30$		;GO PUT THE <CR><LF> BACK IN AND LIST
	.ENDC
50$:	ASR	R4		;LISTING REQUESTED?
	BCC	PUTLI9		;  NO
	$WRITE	LST		;LIST IT
PUTLI9:	RETURN


	ENTSEC	IMPURE
LSTREQ:	.BLKW			;LIST REQUEST FLAGS
LSTDEV:	.BLKB	2		;ERROR(LH), LISTING(RH)

	ENTSEC	TXTBYT
PAGMNE:	.ASCII	/ PAGE /
CRLF:	.ASCIZ	//
	XITSEC

	.IF NDF	XBAW
PROSW:				;PROCESS SWITCH
				;IN -  ASCII IN R0
				;OUT-  .NE. 0 IF OK
	ENTOVR	1
	SAVREG
	SETXPR			;SET EXPRESSION-TYPE REGISTERS
	MOV	R0,(R1)+	;SET "SYMBOL"
	CALL	XCTLIN		;ZERO LINE-ORIENTED FLAGS
	SCANW	SWTROL		;SCAN FOR SWITCH
	BEQ	10$		;  NOT FOUND, EXIT ZERO
	CLR	(R3)		;CLEAR "MODE"
	MOV	(R1),(R4)	;ADDRESS TO "VALUE"
	MOV	#LINBUF,CHRPNT	;POINT TO START OF LINE
	SETNB			;SET R5
	INC	EXMFLG		;FLAG EXEC MODE
	CALL	PROPC		;PROCESS AS OP-CODE
	CLR	R0		;ASSUME ERROR
	BIS	ERRBTS,R5	;ERROR OR NOT TERMINATOR?
	BNE	10$		;  YES, ERROR
	COM	R0		;OK, SET .NE. ZERO
10$:	RETURN
	.ENDC
	XITOVR

	ENTSEC	IMPLIN
EXMFLG:	.BLKW			;EXEC MODE FLAG
	XITSEC

	.SBTTL USER STACK CONTROL
	.SBTTL	DEFINE IT
	.GLOBL STKLIM
; THE USER STACK CONSISTS OF 2 ITEMS:
;  FIRST IS THE STACK NAME AND LIMITS LOCATED IN STNROL
;  SECOND IS THE STACK ARRAY ITSELF LOCATED IN STKROL

; THE STACK NAME ROLL ENTRY CONSISTS OF THE FOLLOWING:
;     offset    definition
;	0	 name
;	4	 starting position of STACK from STKROL base
;	6	 user stack pointer
;	8	 high limit (= stack size in bytes)
;	10	 entry size (1=byte/2=word/4=symbol)

DEFST::
DEFSTACK::
	GSARG			;GET STACK NAME
	BNE	10$		;GOT ONE
	RETURN

10$:	SETXPR			;SET UP REGS
	MOV	(R1)+,-(SP)	;SAVE NAME
	MOV	(R1)+,-(SP)
	SCAN	STNROL		;LOOK FOR NAME IN STACK ROLL
	BEQ	50$		;NOT THERE
	MOV	2(R4),-(SP)	;GET STACK SIZE
	MOV	(R3),R2		;AND BASE ADDRESS
	DELETE			;REMOVE ITEM FROM ROLL
	MOV	ROLPNT,ROLUPD	;SET UP POINTER FOR "NEXT"
	SUB	#RS.STN*2,ROLUPD  ;BACK UP 1 ENTRY BECAUSE OF DELETE
	SUB	ROLBAS+STNROL,ROLUPD	;MAKE IT AN ENTRY NUMBER
20$:	NEXT	STNROL		;GET NEXT ENTRY
	BEQ	30$		;END
	SUB	(SP),(R3)	;COMPUTE NEW BASE
	INSERT			;UPDATE
	BR	20$		;CONTINUE

30$:	ADD	ROLBAS+STKROL,R2	;STARTING SOURCE ADDRESS
	MOV	R2,R3		;DESTINITATION ADDRESS
	ADD	(SP),R3		; + STACK SIZE
40$:	MOV	-(R2),-(R3)	;REMOVE TEXT FROM ROLL
	CMP	R2,SP		;ALL THE WAY DOWN TO THE CURRENT STACK POINTER
	BHI	40$
	MOV	R3,SP		;MOVE THE STACK
	ADD	(SP)+,ROLBAS+STKROL	;MOVE THE BASE ADDRESS OF THE STACK ROLL
	.IIF NE,STKROL,.ERROR  ;STKROL MUST BE FIRST, OR PUT CODE HERE TO FIX IT
	.PAGE
50$:	TSTARG			;GET NEXT ARGUMENT
	BNE	70$		;GOT ONE
60$:	CLR	R5		;PREVENT Q ERRORS
	CMP	(SP)+,(SP)+	;PURGE STACK
	RETURN

70$:	ABSEXP			;GET STACK SIZE
	TST	(R4)		;0?
	BEQ	60$		;YES, EXIT
	INC	(R4)		;MAKE SURE ITS'S EVEN
	BIC	#1,(R4)
	SETPF1			;PRINT SIZE
	MOV	(R4),-(SP)	;SAVE STACK SIZE
	MOV	#1,-(SP)	;ASSUME 1 BYTE/ENTRY
	GSARG			;GET SYMBOL
	TST	ERRBTS		;ANY ERRORS?
	BNE	80$		;YES, ERROR EXIT
	TST	R0		;ANY SYMBOL?
	BEQ	90$		;NONE, ASSUME SYMBOL
	CMP	SYMBOL,#^RWOR	;WORD?
	BEQ	100$		;YES
	CMP	SYMBOL,#^RBYT	;BYTE?
	BEQ	110$		;YES
	CMP	SYMBOL,#^RSYM	;SYMBOL?
	BEQ	90$		;YES
	ERROR	U		;DON'T KNOW WHAT'S GOING ON
80$:	CMP	(SP)+,(SP)+	;PURGE STACK
	BR	60$		;EXIT

90$:	ASL	(SP)		;4 BYTES/ENTRY
100$:	ASL	(SP)		;2 BYTES/ENTRY
110$:	MOV	(SP),R3		;1 BYTE/ENTRY

	MOV	2(SP),R0	;GET SIZE
	MUL	R3,R0		;* ENTRY SIZE = MEMORY RQMNTS
	BCC	130$		;GO IF NO OVERFLOW
120$:	ERROR	A
	BR	80$
	.PAGE
130$:	MOV	R1,2(SP)	;SAVE ANSWER
	MOV	SP,R1		;POINT TO TOP OF FREE SPACE
	SUB	2(SP),R1	;BACK DOWN
	BLO	120$		;TOO BIG
	CMP	R1,STKLIM	;CHECK LOWER LIMIT
	BLOS	120$		;TOO BIG
	MOV	ROLTOP+STKROL,R2	;POINT TO TOP OF STACK ROLL
	SUB	ROLBAS+STKROL,R2	;COMPUTE CURRENT SIZE OF STACK ROLL
	MOV	#SYMBOL+<RS.STN*2>,R4	;POINT 1 WORD BEYOND ENTRY
	MOV	(SP)+,-(R4)	;ENTRY SIZE
	MOV	(SP)+,R3	;SAVE HIGH LIMIT VALUE
	MOV	R3,-(R4)	;HIGH LIMIT
	MOV	R3,-(R4)	;INITIALISE USER STACK POINTER
	MOV	R2,-(R4)	;BASE ADDRESS
	MOV	(SP)+,-(R4)	;NAME
	MOV	(SP)+,-(R4)
	APPEND	STNROL		;INSERT INTO NAME ROLL
	MOV	ROLTOP+STKROL,R2	;GET TOP ADDRESS
	SUB	SP,R2		;COMPUTE # OF BYTES TO MOVE
	CLC			; (JUST TO BE SAFE)
	ROR	R2		;  WORDS TO MOVE
	MOV	SP,R0		;SOURCE
	SUB	R3,ROLBAS+STKROL  ;MAKE STACK ROLL BIGGER
.IIF NE,STKROL,.ERROR  ;STKROL SHOULD BE FIRST HERE
	SUB	R3,SP		;DESTINATION, MOVE STACK
	MOV	SP,R1

140$:	MOV	(R0)+,(R1)+
	SOB	R2,140$		;MOVE ALL THE TEXT
	ROR	R3		;COMPUTE # OF WORDS IN DEFINED ARRAY
150$:	CLR	(R1)+		;CLEAR USERS STACK ARRAY
	SOB	R3,150$
	RETURN			;DONE
	.PAGE
	.SBTTL	.PUSH

PUSH::	CALL	USNAME		;GET USER STACK NAME
	BNE	10$		;GOT IT
	RETURN
10$:	TSTARG			;POSITION TO NEXT SYMBOL
	BEQ	PPCLUP		;DONE
	CMP	R3,#4		;STACK TYPE?
	BHIS	20$		;SYMBOL
	ABSEXP			;GET EXPRESSION
	BR	40$		;STUFF IT

20$:	GETSYM			;TRY FOR A SYMBOL
	BNE	30$		;ITS OK
	ERROR	A		;ELSE ERROR
	BR	PPPF1		;PRINT IT AND EXIT

30$:	SSRCH			;LOOK IN USER'S TABLE
	CRFREF			;CREF IT

40$:	SUB	R3,R2		;MOVE USER'S POINTER
	BHIS	50$		;OK
	ERROR	P		;STACK UNDERFLOW ERROR
	BR	PPPF1		;SET IT TO PRINT AND EXIT

50$:	MOV	R2,R0		;GET POINTER
	ADD	R4,R0		; + BASE
	ADD	ROLBAS+STKROL,R0  ; + POSITION OF ROLL
	MOV	#VALUE,R1	;ASSUME DATA TYPE
	CMP	SYMBOL,#<^R.  >	;MESSING WITH THE PC?
	BNE	60$		;NOPE
	MOV	#CLCLOC,R1	;YEP, POINT TO LOCATION COUNTER
60$:	CMP	R3,#2		;TEST TYPE
	BEQ	70$		;WORD TYPE
	BLT	80$		;BYTE TYPE
	MOV	-2(R1),(R0)+	;SYMBOL, COPY ATTRIBUTES
70$:	MOVB	(R1)+,(R0)+	;COPY VALUE
80$:	MOVB	(R1),(R0)
	CMP	R3,#4		;TEST TYPE AGAIN
	BLO	10$		;DATA
	CMP	SYMBOL,#<^R.  >	;MESSING WITH THE PC?
	BEQ	10$		;YEP, DON'T BOTHER WITH THE REST
	BIC	#^C<DEFFLG>,MODE ;ZAP ALL BUT DEFINED BIT
	INSERT			;UPDATE SYMBOL
	BR	10$		;KEEP LOOKING
	.PAGE
PPCLUP:	MOV	#SYMBOL,R4	;POINT TO SYMBOL
	MOV	S.SAVE,(R4)+	;RESTORE SYMBOL
	MOV	S.SAVE+2,(R4)+
	SCAN	STNROL		;LOOKUP STACK ROLL AGAIN
	MOV	R2,2(R4)	;UPDATE STACK POINTER
	INSERT			;REGISTER IT

PPPF1:	MOV	R2,R1		;
	CLR	R0
	DIV	R3,R0
	CLR	MODE
	MOV	R0,VALUE
	SETPF1			;SET UP TO PRINT STACK POINTER VALUE
	CLR	R5		;RESET ANY "Q" ERRORS
	RETURN

	ENTSEC	IMPURE
S.SAVE:	.BLKW	2
	XITSEC
	.PAGE
	.SBTTL	POP

POP::	CALL	USNAME		;GET USERS STACK NAME
	BNE	10$		;OK
	RETURN

10$:	TSTARG			;POSITION TO NEXT SYMBOL
	BEQ	PPCLUP		;DONE
	GETSYM			;TRY FOR A SYMBOL
	BNE	20$		;ITS OK
	ERROR	A		;ELSE ERROR
	BR	PPPF1		;PRINT IT AND EXIT

20$:	CMP	R2,R1		;STACK EMPTY?
	BLO	30$		;NOPE
	ERROR	P		;STACK OVERFLOW
	BR	PPPF1		;PRINT IT AND EXIT

30$:	SSRCH			;FIND SYMBOL IN USERS'S TABLE
	CRFDEF			;THIS CONSTITUTES A DEFINITION
	MOV	R2,R0		;USER'S SP
	ADD	R4,R0		; + BASE
	ADD	ROLBAS+STKROL,R0 ; + POSITION OF ROLL = ADDRESS OF ARRAY
	MOV	R1,-(SP)	;SAVE R1
	CMP	SYMBOL,#<^R.  >	;MESSING WITH THE "."?
	BEQ	70$		;YEP, DO SPECIAL PROCESSING
	MOV	#FLAGS,R1	;POINT TO "FLAGS"
	MOV	#DEFFLG,(R1)+	;ASSUME DEFINED/ABSOLUTE
	CMP	R3,#2		;TYPE?
	BEQ	40$		;WORD
	BLT	50$		;BYTE
	MOV	(R0)+,-2(R1)	;PASS SYMBOL ATTRIBUTES
40$:	MOVB	(R0)+,(R1)+
50$:	MOVB	(R0)+,(R1)+
	INSERT			;DEFINE SYMBOL
60$:	MOV	(SP)+,R1	;RESTORE R1
	ADD	R3,R2		;UPDATE USERS STACK POINTER
	BR	10$		;CONTINUE

70$:	CMP	R3,#2		;TYPE?
	BGT	110$		;SYMBOL TYPE, EVERYTHING IS LEGAL
	BIT	#CSTREL,CLCFGS	;ARE WE CURRENTLY IN AN ABS SECTION?
	BEQ	80$		;YEP
	ERROR	M		;ELSE GIVE 'EM AN ERROR
	BR	60$		;POP THE STACK, BUT DON'T CHANG THE PC

80$:	CMP	R3,#2		;TYPE?
	BLT	100$		;BYTE
90$:	MOVB	1(R0),CLCLOC+1	;WORD, MOVE IN MSB
100$:	MOVB	(R0),CLCLOC	;MOVE IN LSB
	BR	60$		;CONTINUE

110$:	INC	R0		;SKIP THE FLAGS
	CLR	R1		;GET THE SAVED SECTOR #
	BISB	(R0)+,R1	;  INTO R1
	CMPB	R1,CLCSEC	;TRYING TO SET TO THE SAME SECTOR?
	BEQ	90$		;YEP, GO AHEAD AND DO IT THEN
	PUSH	<R2,(R0)>	;SAVE STACK POINTER AND VALUE
	CALL	SETMAX		; MAX OUT THE CURRENT SECTOR
	CALL	LSBSET		;CLOSE OUT LSB
	IMULI	RS.SEC*2,R1	;COMPUTE OFFSET INTO SECTOR ROLL
	ADD	ROLBAS+SECROL,R1
	MOV	#CLCNAM,R2
	CALL	XMIT0-<RS.SEC*2>  ;COPY IN NEW PARAMETERS
	PULL	<CLCLOC,R2>	;GET CURRENT LOCATION AND RESTORE STK PTR
	BR	60$		;CONTINUE	
	.PAGE
	.SBTTL	GET USER'S STACK POINTER
GETPO::
GETPOINTER::
	CALL	USNAME		;GET USER'S STACK NAME
	BEQ	20$
	MOV	R2,R1		;POINTER
	CLR	R0
	DIV	R3,R0		;COMPUTE RELATIVE
	MOV	R0,R1		;SAVE ENTRY #
	GSARG			;GET USERS SYMBOL
	BEQ	20$		;NONE
	SSRCH			;LOOK IN USER'S SYMBOL TABLE
	BIT	#177400+LBLFLG+GLBFLG,MODE	;LEGIT SYMBOL?
	BEQ	10$		;YES
	ERROR	A
	RETURN

10$:	CRFDEF			;CREF IT
	MOV	R1,VALUE	;PASS VALUE
	MOV	#DEFFLG,MODE	;SIGNAL DEFINED
	INSERT
20$:	RETURN
	.PAGE
	.SBTTL	PUT A VALUE IN USER'S STACK POINTER
PUTPO::
PUTPOINTER::
	CALL	USNAME
	BEQ	50$
	TSTARG			;SKIP TO ARGUMENT
	BNE	10$		;OK
	ERROR	A
	RETURN

10$:	ABSEXP			;GET NEW VALUE
	MOV	R1,R4		;SAVE HIGH LIMIT
	MOV	VALUE,R0	;GET VALUE
	MOV	R0,R2		;SAVE IT FOR LATER
	MUL	R3,R0		;COMPUTE NEW POINTER
	BCS	20$		;ERROR, OVERFLOW
	CMP	R1,R4		;SIZE?
	BLOS	30$		;OK
20$:	ERROR	P		;TOO BIG
	BR	40$

30$:	MOV	S.SAVE,SYMBOL
	MOV	S.SAVE+2,SYMBOL+2
	SCAN	STNROL		;RETRIEVE STACK NAME STUFF
	MOV	R1,VALUE
	INSERT			;UPDATE ROLL
40$:	CLR	MODE
	MOV	R2,VALUE	;PRINT USERS VALUE
	SETPF1			;PRINT THE VALUE
50$:	RETURN



USNAME:	GSARG			;GET NAME
	BNE	20$		;OK
10$:	ERROR	U		;N.F.G.
	CLR	R5		;RESET "Q" ERRORS BUT CAUSE ERROR EXIT
	RETURN

20$:	SCAN	STNROL		;LOOK FOR NAME
	BEQ	10$		;ERROR
	MOV	#SYMBOL,R3	;POINT TO SYMBOL
	MOV	(R3)+,S.SAVE	;SAVE NAME
	MOV	(R3)+,S.SAVE+2
	MOV	(R3)+,R4	;BASE
	MOV	(R3)+,R2	;POINTER
	MOV	(R3)+,R1	;HIGH LIMIT
	MOV	(R3),R3		;ENTRY SIZE
	RETURN
	.PAGE
	.SBTTL NUMBER CONVERSIONS

DNC:				;DECIMAL NUMBER CONVERSION
	MOV	#10.,R3		;SET DIVISOR
DNCF:				;ENTRY FOR OTHER THAN DECIMAL
	CLR	R0
	DIV	R3,R0		;DIVIDE R1
	MOV	R1,-(SP)	;SAVE REMAINDER
	MOV	R0,R1		;SET FOR NEXT DIVIDE
	BEQ	10$		;  UNLESS ZERO
	CALL	DNCF		;RECURSE
10$:	MOV	(SP)+,R1	;RETRIEVE NUMBER
	ADD	#DIG.0,R1	;CONVERT TO ASCII
	MOVB	R1,(R2)+	;STORE
	RETURN

	.GLOBL	R50UNP

R50UNP:				;RAD 50 UNPACK ROUTINE
	MOV	R4,-(SP)	;SAVE REG
	MOV	#SYMBOL,R4	;POINT TO SYMBOL STORAGE
10$:	MOV	(R4)+,R1	;GET NEXT WORD
	MOV	#50*50,R3	;SET DIVISOR
	CALL	20$		;DIVIDE AND STUFF IT
	MOV	#50,R3
	CALL	20$		;AGAIN FOR NEXT
	MOV	R1,R0
	CALL	30$		;FINISH LAST GUY
	CMP	R4,#SYMBOL+4	;THROUGH?
	BNE	10$		;  NO
	MOV	(SP)+,R4	;YES, RESTORE REGISTER
	RETURN


20$:	CLR	R0
	DIV	R3,R0
30$:	TST	R0		;SPACE?
	BEQ	60$		;  YES
	CMP	R0,#33		;TEST MIDDLE
	BLT	50$		;ALPHA
	BEQ	40$		;DOLLAR
	ADD	#22-11,R0	;DOT OR DOLLAR
40$:	ADD	#11-100,R0
50$:	ADD	#100-40,R0
60$:	ADD	#40,R0
	MOVB	R0,(R2)+	;STUFF IT
	RETURN
	.IF NDF	PDPV45
	.PAGE
	.SBTTL	MUL/DIV ROUTINE
				;DIV R3,R0   (R0 IGNORED)
				;MUL R3,R0
DIV:				;GENERAL DIVIDE ROUTINE
	MOV	#16.,-(SP)	;LOOP COUNT
10$:	ASL	R1		;SHIFT WORK REGISTERS
	ROL	R0		;  DOUBLE REGISTER
	CMP	R0,R3		;BIG ENOUGH FOR OPERATION?
	BLO	20$		;  NO
	SUB	R3,R0		;YES
	INC	R1		;BUMP RESULT
20$:	DEC	(SP)		;TEST FOR END
	BNE	10$
	MOV	R1,(SP)		;R1=QUOTIENT
	MOV	R0,R1		;PLACE REMAINDER IN R1
	MOV	(SP)+,R0	;QUOTIENT
	RETURN

MUL:				;GENERAL MULTIPLY ROUTINE
	MOV	R0,-(SP)	;GET THE FIRST GUY
	CLR	R0		;CLEAR RESULTS
	CLR	R1
	ROR	(SP)
	BR	20$
10$:	ASR	(SP)
20$:	BCS	30$
	BNE	40$
	TST	(SP)+		;PRUNE STACK
	RETURN
30$:	ADD	R3,R1
	ADC	R0
40$:	ASL	R3
	BR	10$

	.ENDC

	.SBTTL	SYMBOL/CHARACTER HANDLERS

GETSYM:
	SAVREG
	MOV	CHRPNT,SYMBEG	;SAVE IN CASE OF RESCAN
	MOV	#SYMBOL+4,R1
	CLR	-(R1)
	CLR	-(R1)
	BITB	CTTBL(R5),#CT.ALP	;ALPHA?
	BEQ	50$		;  NO, EXIT FALSE
	MOV	#26455,R2
	SETR50
10$:	CALL	MULR50
20$:	ASR	R2
	BCS	10$
	ADD	R0,(R1)
30$:	GETR50
	BLE	40$
	ASR	R2
	BCS	20$
	BEQ	30$
	TST	(R1)+
	BR	10$

40$:	SETNB
50$:	MOV	SYMBOL,R0
	RETURN


MULR50::			;MULTIPLY R0 * 50
	IMULI	50,R0
	RETURN

GETR50:	GETCHR
SETR50:	MOV	R5,R0
TSTR50:	BITB	#CT.ALP!CT.NUM!CT.SP,CTTBL(R0)	;ALPHA, NUMERIC, OR SPACE?
	BEQ	10$		;  NO, EXIT MINUS
	CMP	R0,#CH.DOL	;YES, TRY DOLLAR
	BLO	20$		;SPACE
	BEQ	30$		;DOLLAR
	CMP	R0,#LET.A
	BLO	40$		;DOT OR DIGIT
	BR	50$		;ALPHA

10$:	MOV	#100000+SPACE,R0	;INVALID, FORCE MINUS
20$:	SUB	#SPACE-11,R0	;SPACE
30$:	SUB	#11-22,R0	;DOLLAR
40$:	SUB	#22-100,R0	;DOT, DIGIT
50$:	SUB	#100,R0		;ALPHABETIC
	RETURN

CVTNUM:				;CONVERT TEXT TO NUMERIC

				; IN  -  R2    RADIX

				; OUT -  VALUE RESULT
				; R0 - HIGH BIT  - OVERFLOW
				;    - HIGH BYTE - CHARACTER COUNT
				;    - LOW  BYTE - OVERSIZE COUNT


	SAVREG
	CLR	R0		;RESULT FLAG REGISTER
	CLR	R1		;NUMERIC ACCUMULATOR
10$:	MOV	CHRPNT,SYMBEG	;SAVE FOR RESCAN
20$:	MOV	R5,R3		;GET A COPY OF THE CURRENT CHAR
	SUB	#DIG.0,R3	;CONVERT TO ABSOLUTE
	CMP	R3,#9.		;NUMERIC?
	BLOS	30$		;ITS OK
	SUB	#7.,R3		;A-F
	CMP	R3,#10.		;TOO SMALL?
	BLO	80$		;YEP
	CMP	R3,#16.		;TOO BIG?
	BHIS	80$		;YEP
30$:	CMP	R3,R2		;YES, LESS THAN RADIX?
	BLO	40$		;  YES
	INC	R0		;NO, BUMP "N" ERROR COUNT
40$:
	.IF NDF	PDPV45
	MOV	R2,R4		;COPY OF CURRENT RADIX
	CLR	-(SP)		;TEMP AC
50$:	ASR	R4		;SHIFT RADIX
	BCC	60$		;BRANCH IF NO ACCUMULATION
	ADD	R1,(SP)		;ADD IN
60$:	TST	R4		;ANY MORE BITS TO PROCESS?
	BEQ	70$		;  NO
	ASL	R1		;YES, SHIFT PATTERN
	BCC	50$		;BRANCH IF NO OVERFLOW
	BIS	#100000,R0	;OH, OH.  FLAG IT
	BR	50$

70$:	MOV	(SP)+,R1	;SET NEW NUMBER
	.IFF
	MUL	R2,R1
	.ENDC
	ADD	R3,R1		;ADD IN CURRENT NUMBER
	GETCHR			;GET ANOTHER CHARACTER
	ADD	#000400,R0	;TALLY CHARACTER COUNT
	BR	20$

80$:	MOV	R1,VALUE	;RETURN  RESULT IN "VALUE"
	BISB	#DEFFLG,FLAGS	;PASS DEFINED FLAG
	RETURN			;RETURN, TESTING R0

GSARG:				;GET A SYMBOLIC ARGUMENT
	.ENABL	LSB
	TSTARG			;TEST GENERAL
	BEQ	20$		;  EXIT NULL
GSARGF:	GETSYM			;ARG, TRY FOR SYMBOL
	BEQ	10$		;  ERROR IF NOT SYMBOL
	CMP	R0,R50DOT	;  "."?
	BNE	20$		;  NO, OK
10$:	ERROR	A
	CLR	R0		;TREAT ALL ERRORS AS NULL
20$:	RETURN
	.DSABL	LSB

TSTARG:				;TEST ARGUMENT
10$:	MOVB	CTTBL(R5),R0	;GET CHARACTERISTICS
	BLE	60$		;THROUGH IF EOL OR SEMI-COLON
	TST	ARGCNT		;FIRST ARGUMENT?
	BEQ	50$		;  YES, GOOD AS IS
	BIT	#CT.COM,R0	;NO, COMMA?
	BNE	40$		;  YES, BYPASS IT
	TST	EXPFLG		;NO, WAS ONE REQUIRED?
	BEQ	20$		;  NO
	ERROR	A		;YES, FLAG ERROR
20$:	CMP	CHRPNT,ARGPNT	;DID ANYBODY USE ANYTHING?
	BNE	50$		;  YES, OK
30$:	GETCHR			;NO, BYPASS TO AVOID LOOPS
	BITB	#CT.PC+CT.SP+CT.TAB-CT.COM-CT.SMC,CTTBL(R5)
	BNE	30$		;  YES, BYPASS
	SETNB			;NO, SET TO NON-BLANK
	ERROR	A		;FLAG ERROR
	BR	10$		;NOW TRY AGAIN

40$:	GETNB			;BYPASS COMMA
50$:	INC	ARGCNT		;INCREMENT ARGUMENT COUNT
60$:	CLR	EXPFLG
	MOV	CHRPNT,ARGPNT	;SAVE POINTER
	BIC	#177600,R0	;SET FLAGS
	RETURN


	ENTSEC	IMPLIN		;CLEAR EACH LINE
ARGCNT:	.BLKW			;ARGUMENT COUNT
ARGPNT:	.BLKW			;START OF LAST ARGUMENT
EXPFLG:	.BLKW			;SET WHEN COMMA REQUIRED
	XITSEC

CT.EOL=	000		; EOL
CT.COM=	001		; COMMA
CT.TAB=	002		; TAB
CT.SP=	004		; SPACE
CT.PCX=	010		; PRINTING CHARACTER
CT.NUM=	020		; NUMERIC
CT.ALP=	040		; ALPHA, DOT, DOLLAR
CT.LC=	100		;  LOWER CASE ALPHA
CT.SMC=	200		;  SEMI-COLON  (MINUS BIT)

CT.PC=	CT.COM!CT.SMC!CT.PCX!CT.NUM!CT.ALP	;PRINTING CHARS

	.MACRO	GENCTT	ARG	;GENERATE CHARACTER TYPE TABLE
	.IRP	A,	<ARG>
	.BYTE	CT.'A
	.ENDM
	.ENDM


	ENTSEC	DPURE
CTTBL:				;CHARACTER TYPE TABLE

GENCTT	<EOL, EOL, EOL, EOL, EOL, EOL, EOL, EOL>  ;NUL,SOH,STX,ETX,EOT,ENQ,ACK,BEL
GENCTT	<EOL, TAB, EOL, EOL, EOL, EOL, EOL, EOL>  ;BS,HT,LF,VT,FF,CR,SO,SI
GENCTT	<EOL, EOL, EOL, EOL, EOL, EOL, EOL, EOL>  ;DLE,DC1,DC2,DC3,DC4,NAK,SYN,ETB
GENCTT	<EOL, EOL, EOL, EOL, EOL, EOL, EOL, EOL>  ;CAN,EM,SUB,ESC,FS,GS,RS,US

GENCTT	<SP , PCX, PCX, PCX, ALP, PCX, PCX, PCX>  ;  ! " # $ % & '
GENCTT	<PCX, PCX, PCX, PCX, COM, PCX, ALP, PCX>  ;( ) * + , - . /
GENCTT	<NUM, NUM, NUM, NUM, NUM, NUM, NUM, NUM>  ;0 1 2 3 4 5 6 7
GENCTT	<NUM, NUM, PCX, SMC, PCX, PCX, PCX, PCX>  ;8 9 : ; < = > ?

GENCTT	<PCX, ALP, ALP, ALP, ALP, ALP, ALP, ALP>  ;@ A B C D E F G
GENCTT	<ALP, ALP, ALP, ALP, ALP, ALP, ALP, ALP>  ;H I J K L M N O
GENCTT	<ALP, ALP, ALP, ALP, ALP, ALP, ALP, ALP>  ;P Q R S T U V W
GENCTT	<ALP, ALP, ALP, PCX, PCX, PCX, PCX, PCX>  ;X Y Z [ \ ] ^ _

GENCTT	<PCX, LC , LC , LC , LC , LC , LC , LC >  ;` a b c d e f g
GENCTT	<LC , LC , LC , LC , LC , LC , LC , LC >  ;h i j k l m n o
GENCTT	<LC , LC , LC , LC , LC , LC , LC , LC >  ;p q r s t u v w
GENCTT	<LC , LC , LC , PCX, PCX, PCX, PCX, EOL>  ;x y z { | } ~ DEL

	XITSEC

SETSYM:				;SET SYMBOL FOR RE-SCAN
	MOV	SYMBEG,CHRPNT	;SET THE POINTER
	BR	SETCHR		;SET CHARACTER AND FLAGS

GETNB:				;GET A NON-BLANK CHARACTER
	INC	CHRPNT		;BUMP POINTER
SETNB::	SETCHR			;SET REGISTER AND FLAGS
	BITB	#CT.SP!CT.TAB,CTTBL(R5)	;BLANK?
	BNE	GETNB		;  YES, BYPASS
	BR	SETCHR		;EXIT, SETTING FLAGS

GETCHR::			;GET THE NEXT CHARACTER
	INC	CHRPNT		;BUMP POINTER
SETCHR::MOVB	@CHRPNT,R5	;SET REGISTER AND FLAGS
.IF NDF	XEDLC
	BPL	10$		;OK IF NO SIGN BIT
	SUB	#177600+40,R5	;TRY FOR LOWER CASE MAP
.ENDC
	BMI	GETCHR		;LOOP IF INVALID CHARACTER
10$:	RETURN

CHSCAN:				;CHARACTER SCAN ROUTINE
10$:	TST	(R0)+		;END (ZERO)?
	BEQ	20$		;  YES
	CMP	(R0)+,R5	;THIS THE ONE?
	BNE	10$		;  NO
	TST	-(R0)		;YES, MOVE POINTER BACK
	MOV	CHRPNT,SYMBEG	;SAVE CURRENT POINTER
	GETNB			;GET NEXT NON-BLANK
20$:	MOV	-(R0),R0	;MOVE ADDR OR ZERO INTO R0
	RETURN

	.SBTTL	ROLL HANDLERS

SSRCH:				;USER DEFINED OPERAND SEARCH
	SEARCH	SYMROL
	.IF ne,MACXX&<..m69!.6502>
	BEQ	10$		;IGNORE BIT FLIP IF NOT FOUND
	MOV	R0,-(SP)	;SAVE R0
	XOR	#FWDFLG,MODE	;FLIP FWDFLG
	MOV	(SP)+,R0	;RESTORE R0 AND SET CC'S
	.ENDC
10$:	RETURN

OSRCH:				;OP-CODE SEARCH
	SEARCH	PSTROL
.if df dirrol
	bne	10$
	search	dirrol
.endc
10$:	RETURN

	.IF NDF	XMACRO
MSRCH:	SEARCH	MACROL
	RETURN
	.ENDC

	.IF NDF	XEDLSB
LSRCH::				;LOCAL SYMBOL SEARCH
	TST	LSYFLG		;FLAG SET?
	BEQ	10$		;  NO
	CLR	LSYFLG		;YES, CLEAR IT
	INC	LSYBKN		;BUMP BLOCK NUMBER
10$:	MOV	#SYMBOL,R0
	MOV	LSYBKN,(R0)+	;MOVE INTO "SYMBOL"
	MOV	VALUE,(R0)
	SEARCH	LSYROL		;SEARCH THE ROLL
	RETURN

	ENTSEC	IMPPAS
LSYFLG:	.BLKW			;BUMPED AT "LABEL:"
LSYBKN:	.BLKW			;BLOCK NUMBER
LSYBAS:	.BLKW			;SECTION BASE
LSGBAS:	.BLKW			;BASE FOR GENERATED SYMBOLS
	XITSEC

	.ENABL	LSB
LSBTST:	BNE	20$		;BYPASS IF /DS
	BR	10$

LSBSET:	BIT	#ED.LSB,EDMASK	;IN LSB OVER-RIDE?
	BEQ	20$		;  YES
10$:	INC	LSYFLG		;FLAG NEW BLOCK
	MOV	CLCLOC,LSYBAS	;SET NEW BASE
	.IF ne,MACXX&.pdp11
	BIC	#1,LSYBAS	;BE SURE ITS EVEN
	.ENDC
	CLR	LSGBAS		;CLEAR GENERATED SYMBOL BASE
20$:	RETURN

	.DSABL	LSB
	.ENDC

.IF NDF	RSX11D

SEARCH:				;BINARY ROLL SEARCH
	SETROL			;SET ROLL REGISTERS
	MOV	R3,-(SP)
	SUB	R3,R1		;POINT ONE SLOT LOW
	MOV	R2,R3
	SUB	R1,R3		;COMPUTE SIZE
	CLR	R0		;GET SET TO COMPUTE SEARCH OFFSET
	SEC			;  (R0 DOUBLES AS T/F FLAG)
10$:	ROL	R0		;SHIFT BIT
	BIC	R0,R3		;CLEAR CORRESPONDING BIT.  LAST ONE?
	BNE	10$		;  NO
20$:	ADD	R0,R1
30$:	ASR	R0		;END OF ITERATION, HALVE OFFSET
	BIC	#2,R0		;END?
	BEQ	70$		;  YES
40$:	CMP	R2,R1		;OFF IN NO-MANS'S LAND?
	BLOS	60$		;  YES
	CMP	(R4),(R1)	;NO, FIRST WORDS MATCH?
	BNE	50$		;  NO
	CMP	2(R4),2(R1)	;YES, HOW ABOUT SECOND?
	BEQ	80$		;  YES, FOUND
50$:	BHI	20$		;NO, BRANCH IF TOO HIGH
60$:	SUB	R0,R1		;LOWER INDEX
	BR	30$

70$:	CMP	(R1)+,(R1)+	;POINT TO INSERTION SLOT
80$:	MOV	(SP)+,R3
	BR	SCANX		;EXIT THROUGH SCAN

	.IFF

SEARCH:
	SETROL
	BIT	#ED.REG,EDMASK	;REGISTER DEFINITION ENABLED?
	BNE	10$		;IF NE NO
	CMP	R5,#SYMROL	;SYMBOL ROLL?
	BNE	10$		;IF NE NO
	BIT	#7,(R4)		;MAKE RUFF RUFF TEST BYPASS 90%
	BNE	10$		;IF NE DON'T CHECK FOR REGISTER
	SCAN	REGROL		;SCAN REGISTER ROLL
	MOV	R5,ROLNDX	;RESTORE ROLL INDEX
	TST	R0		;FIND SYMBOL?
	BEQ	10$		;IF EQ NO FIND EM
	RETURN			;
10$:	MOV	R1,-(SP)	;SAVE ROLL BASE
	CMP	R1,R2		;ANY IN ROLL?
	BEQ	50$		;IF EQ NO
	SUB	R3,R2		;CALCULATE HIGH AND LOW BOUNDS
	MOV	R1,R0		;
	BIC	#177770,(SP)	;
20$:	MOV	R0,R1		;CALCULATE TRIAL INDEX
	ADD	R2,R1		;
	ROR	R1		;HALVE RESULT
	BIC	#7,R1		;CLEAR GARBAGE BITS
	BIS	(SP),R1		;
	CMP	(R1),(R4)	;COMPARE HIGH PARTS
	BHI	40$		;IF HI SET NEW HIGH LIMIT
	BLO	30$		;IF LO SET NEW LOW LIMIT
	CMP	2(R1),2(R4)	;COMPARE LOW PARTS
	BEQ	60$		;IF EQ HIT
	BHI	40$		;IF HI SET NEW HIGH LIMIT
30$:	MOV	R1,R0		;SET NEW LOW LIMIT
	ADD	R3,R0		;REDUCE BY ONE MORE
	CMP	R0,R2		;ANY MORE TO SEARCH?
	BLOS	20$		;IF LOS YES
	ADD	R3,R1		;POINT TO PROPER ENTRY
	BR	50$		;EXIT
40$:	MOV	R1,R2		;SE NEW HIGH LIMIT
	SUB	R3,R2		;REDUCE BY ONE MORE
	CMP	R0,R2		;ANY MORE TO SEARCH?
	BLOS	20$		;IF LOS YES
50$:	CLR	R0		;SET FALSE FLAG
60$:	TST	(SP)+		;CLEAN STACK
	BR	SCANX		;VAMMOOSA

	.ENDC

.IF NE,MACXX&..MZ80	; ONLY USED IN Z80
SAMCPU::			;TEST FOR PROPER CPU, IF NOT, DO "SAMES"
	S.NEXT	PSTROL		;WE MAY BE DOING "NEXT"S
	MOV	ROLUPD,PSTUPD	;AND THIS IS WHAT WE WILL NEED FOR THEM
	MOV	SYMBOL,OLDSYM	;WE WILL EVENTUALLY NEED THIS
	MOV	SYMBOL+2,OLDSYM+2	;(BOTH PARTS)
	MOV	#.Z80,.XXCPU	;ASSUME Z80
	BIT	#ED.Z80,EDMASK	;IS THIS RIGHT?
	BEQ	10$		;YES, NOW WE KNOW WHICH ONE WE WILL USE
	MOV	#.8080,.XXCPU	;NO, USE 8080 INSTEAD.
10$:	BIT	.XXCPU,MODE	;IS THIS RECORD GOOD FOR OUR CPU?
	BEQ	SAME		;NO, LOOK FOR ANOTHER RECORD (A DUPLICATE)
	TST	R0		;WHICH WE HAVEN'T CHANGED SINCE SCAN* WAS DONE
	RETURN

SAME::				;GET THE NEXT ENTRY, FAIL IF SYMNAM < OLD+50
	MOV	PSTUPD,ROLUPD	;RESTORE THE POSITION WE WILL NEED
	NEXT	PSTROL		;SEE IF THERE IS ANOTHER ENTRY AT ALL
	BEQ	99$		;NO, SO QUIT
	MOV	ROLUPD,PSTUPD	;YES, SO RESAVE THE CURRENT OFFSET
	CMP	SYMBOL,OLDSYM	;WERE THEY CLOSE?
	BNE	93$		;NO, ABORT
	MOV	#39.,R0		;START WITH THE MAXIMUM OFFSET
	ADD	OLDSYM+2,R0	;ADD IN THE ORIGINAL VALUE
	CMP	SYMBOL+2,R0	;COMPARE OUR VALUE WITH MAX LEGAL VALUE
	BHI	93$		;DIDN'T WORK, NO MORE DUPLICATES
	MOV	OLDSYM+2,SYMBOL+2	;NOW CHANGE THE NAME BACK (IN THE COPY)
	BIT	.XXCPU,MODE	;SEE IF THIS ENTRY IS FOR THE RIGHT PROCESSOR
	BEQ	SAME		;NOPE--TRY AGAIN
	MOV	ROLUPD,R0	;FETCH THE "NORMAL" VALUE
	RETURN			;AND QUIT
93$:	CLR	R0		;SAY IT DIDN'T WORK
99$:	RETURN			;NOTHING TO DO

.ENDC			; Z80 ONLY	

S.NEXT::			; PRONOUNCED "SEARCHNEXT"
	SETROL			;  SET UP FOR "NEXT" AFTER A "SEARCH"
	MOV	ROLPNT,R0	;GET ABSOLUTE ADDRESS OF ENTRY
	SUB	R1,R0		;ELIMINATE BASE OFFSET
	ADD	R3,R0		;POINT TO FOLLOWING ENTRY
	MOV	R0,ROLUPD	;THIS IS THE NEW VALUE
	RETURN			;RETURNED VALUE DOESN'T MATTER

NEXT::				;GET THE NEXT ENTRY
	SETROL
	MOV	ROLUPD,R0	;GET ENTRY #
	ADD	R0,R1		;ADD TO BASE
	ADD	R3,R0		;SKIP TO NEXT ENTRY
	CMP	R1,R2		;AT TOP?
	BLO	SCANX		;NO. JUST EXIT
	BR	SCANXF		;YES. EXIT FALSE

SCANW:				;SCAN ONE WORD
	SETROL			;SET REGISTERS
	CLR	R0		;ASSUME FALSE
10$:	INC	R0		;TALLY ENTRY COUNT
	CMP	(R4),(R1)	;MATCH?
	BEQ	SCANY		;  YES
	ADD	R3,R1		;NO, INCREMENT POINTER
	CMP	R1,R2		;FINISHED?
	BLO	10$		;  NO
	CLR	R0
	RETURN			;YES, EXIT FALSE

SCAN:				;LINEAR ROLL SCAN
	SETROL			;SET ROLL REGISTERS
	CLR	R0		;ASSUME FALSE
10$:	CMP	R2,R1		;END?
	BEQ	SCANXF		;  YES, EXIT FALSE
	INC	R0
	CMP	(R4),(R1)	;NO, MATCH ON FIRST WORDS?
	BNE	20$		;  YES
	CMP	2(R4),2(R1)	;NO, HOW ABOUT SECOND?
	BEQ	SCANX		;  YES
20$:	ADD	R3,R1		;INCREMENT BY SIZE
	BR	10$

	.ENABL	LSB
SCANXF:	CLR	R0		;FALSE EXIT
SCANX:	MOV	R1,ROLPNT	;SET ENTRY POINTER
	MOV	R0,ROLUPD	;SAVE FLAG
	BEQ	10$		;BRANCH IF NOT FOUND
SCANY:	MOV	R4,R2		;POINTER TO "SYMBOL"
	NEG	R3		;NEGATE ENTRY SIZE
	JMP	XMIT0(R3)	;FOUND, XFER ARGUMENTS

10$:	CMP	(R4)+,(R4)+	;BYPASS SYMBOL ITSELF
	ASR	R3		;GET WORD COUNT
	SUB	#2,R3		;COMPENSATE FOR ABOVE CMP
	BLE	30$		;BRANCH IF END
20$:	CLR	(R4)+		;CLEAR WORD
	SOB	R3,20$
30$:	RETURN
	.DSABL	LSB

APPEND::			;APPEND TO END OF ROLL
	SETROL
	MOV	R2,ROLPNT	;SET POINTER
	CLR	ROLUPD
	BR	INSERF
	.GLOBL	INSERT

INSERT:				;INSERT IN ROLL
	CALL	SETROF		;SET ROLL REGISTERS (BUT NO ARG)
INSERF:	MOV	ROLPNT,R0	;POINTS TO PROPER SLOT
	TST	ROLUPD		;WAS SEARCH TRUE?
	BNE	30$		;  YES
	INCB	ROLSIZ+1(R5)	;UPDATE ENTRY COUNT
	ADD	R3,ROLTOP(R5)	;UPDATE TOP POINTER
	CMP	R2,ROLBAS+2(R5)	;GAP BETWEEN ROLLS?
	BNE	30$		;  YES, JUST STUFF IT
	.IF NDF	FIXSTK
	MOV	SP,R1		;"FROM" ADDRESS
	SUB	R3,SP		;WE'RE ABOUT TO MOVE STACK
	MOV	SP,R2		;"TO" ADDRESS
	.IFF
	CALL	TSTSYT		;TEST FOR ROOM
	MOV	ROLBAS,R1	;DITTO FOR SEPARATE STACK
	MOV	R1,R2
	SUB	R3,R2
	.IFTF
	SUB	R1,R0		;COMPUTE BYTE COUNT
	CLC			; NO SIGN EXTEND!
	ROR	R0		;  NOW WORD COUNT
	.IFF
	BEQ	20$		;BRANCH IF FIRST TIME
	.ENDC

10$:	MOV	(R1)+,(R2)+	;MOVE AN ENTRY DOWN
	SOB	R0,10$
20$:	SUB	R3,ROLBAS(R5)	;DECREMENT POINTERS
	SUB	R3,ROLTOP(R5)
	SUB	#2,R5		;MORE ROLLS?
	BGE	20$		;  YES
	MOV	R2,R0		;POINT TO INSERTION SLOT
30$:	ASR	R3		;HALVE SIZE COUNT
40$:	MOV	(R4)+,(R0)+	;MOVE AN ENTRY INTO PLACE
	SOB	R3,40$		;LOOP IF NOT END
	RETURN

DELETE:	CALL	SETROF		;SET ROL REGS (LEAVE ROLNDX AS IS)
	MOV	ROLPNT,R0	;POINTS TO SLOT
	TST	ROLUPD		;ANYTHING?
	BEQ	20$		;NO. ALREADY DELETED
	DECB	ROLSIZ+1(R5)	;BACK UP 1 ENTRY
	MOV	ROLTOP(R5),R4	;GET CURRENT TOP POINTER
	SUB	R3,ROLTOP(R5)	;UPDATE TOP POINTER
	MOV	R0,R1
	ADD	R3,R1		;SKIP TO NEXT ENTRY
10$:	CMP	R1,R4		;END?
	BHIS	20$		;YES. EXIT
	MOV	(R1)+,(R0)+	;MOVE STUFF DOWN 1 ENTRY
	BR	10$
20$:	RETURN

ZAP::				;EMPTY A ROLL
	SETROL
	MOV	R1,ROLTOP(R5)	;MAKE TOP = BOTTOM
	CLRB	ROLSIZ+1(R5)	;CLEAR ENTRY COUNT
	RETURN


SETROL:				;SET ROLL REGISTERS
	MOV	R0,ROLNDX	;SET ARGUMENT
SETROF:	MOV	(SP)+,R0	;SAVE RETURN ADDRESS
	SAVREG			;SAVE REGISTERS
	MOV	R5,-(SP)	;  AND CURRENT CHARACTER
	MOV	ROLNDX,R5	;SET INDEX
	MOV	ROLBAS(R5),R1	;CURRENT BASE
	MOV	ROLTOP(R5),R2	;CURRENT TOP
	MOVB	ROLSIZ(R5),R3	;ENTRY SIZE
	MOV	#SYMBOL,R4	;POINTER TO SYMBOL
	CALL	(R0)		;CALL PROPER ROUTINE
	MOV	(SP)+,R5	;RESTORE CURRENT CHARACTER
	RETURN			;  AND REST OF REGS

	ENTSEC	IMPURE
ROLNDX::.BLKW			;ROLL INDEX
ROLPNT::.BLKW			;ROLL POINTER
ROLUPD::.BLKW			;ROLL UPDATE
	XITSEC

	.SBTTL	UTILITIES

SETXPR:				;SET EXPRESSION REGISTERS
	MOV	#SYMBOL,R1
	MOV	#SECTOR,R2
	MOV	#MODE,R3
	MOV	#VALUE,R4
	RETURN

SAVREG:				;SAVE REGISTERS
	MOV	R3,-(SP)
	MOV	R2,-(SP)
	MOV	R1,-(SP)
	MOV	6.(SP),-(SP)	;PLACE RETURN ADDRESS ON TOP
	MOV	R4,8.(SP)
	CALL	TSTSTK		;TEST STACK
	CALL	@(SP)+		;RETURN THE CALL
	MOV	(SP)+,R1	;RESTORE REGISTERS
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	MOV	(SP)+,R4
	TST	R0		;SET CONDITION CODES
	RETURN

	.REPT	MAXXMT-7
	MOV	(R1)+,(R2)+	;PAD TO MAX NEEDED
	.ENDR
XMIT7::	MOV	(R1)+,(R2)+
XMIT6::	MOV	(R1)+,(R2)+
XMIT5::	MOV	(R1)+,(R2)+
XMIT4::	MOV	(R1)+,(R2)+
XMIT3::	MOV	(R1)+,(R2)+
XMIT2::	MOV	(R1)+,(R2)+
XMIT1::	MOV	(R1)+,(R2)+
XMIT0::	RETURN

MOVBYT:				;MOVE BYTE STRING
10$:	MOVB	(R1)+,(R2)+	;MOVE ONE
	BNE	10$		;LOOP IF NON-NULL
	TSTB	-(R2)		;END, POINT BACK TO NULL
	RETURN

	.IF DF	TRAPS
TRPPRO:				;TRAP PROCESSOR
	MOV	(SP),2(SP)	;MOVE RETURN ADDRESS UP
	SUB	#2,(SP)		;POINT TO TRAP INSTRUCTION
	MOV	@(SP)+,-(SP)	;STACK IT
	ADD	#TRPBAS-TRAP,(SP)	;FORM ADDRESS
	MOV	@(SP)+,PC	;BRANCH AND PRUNE
	.ENDC

	.IF NDF	XCREF

CRFDEF:	MOVB	#'#,CRFBUF+11.	;CREF DEFINITION
CRFREF:	INC	CRFCNT		;COUNT # OF REFERENCES
	TST	CRFTST		;ANY CREF THIS TIME?
	BEQ	50$		;NOPE - RETURN
.IF ne,MACXX&.pdp11
	BIT	#ED.CRF,EDMASK	;CREFS ENABLED HERE?
	BNE	50$		;NOPE, JUST EXIT
.ENDC
	SAVREG
	MOV	ROLNDX,R3	;SAVE ROLL CONTROLS
	CMPB	#SYMROL,R3	;IS IT A SYMBOL?
	BNE	10$		;NOPE - DONT CHECK FOR REG
	BIT	#REGFLG,MODE	;ELSE IS IT REGISTER SYMBOL?
	BEQ	10$		;NOPE
	MOV	#REGROL,R3	;INDICATE REGISTER
10$:	MOV	#CRFBUF,R2	;GET LINE BUFFER ADDRESS
	MOV	#CRFTYP-1,R1	;AND ADDR OF TYPE TABLE
	MOV	CRFTST,R0	;GET TYPES ENABLED STRING
20$:	ASR	R0		;SHIFT TYPE MASK
	INC	R1		;SKIP PREVIOUS MATCH BYTE
	CMPB	R3,(R1)+	;FIND MATCHING TABLE
	BNE	20$		;LOOP UNTIL FOUND
	ASR	R0		;MOVE MASK BIT TO CARRY
	BCC	50$		;THIS TYPE IS NOT DESIRED.
	MOVB	(R1),(R2)+	;MOVE INTO BUFFER
	BMI	30$		;NOT ONE OF FIRST 4, CREF ANYWAY
	CMP	SYMBOL,#^R...	; "...xxx" SYMBOL?
	BEQ	50$		;YES, DON'T CREF IT
	MOV	ROLNDX,-(SP)
	MOV	ROLPNT,-(SP)
	MOV	ROLUPD,-(SP)
	SCAN	CRFROL		;LOOK IN CROSS ROLL FOR SYMBOL
	MOV	(SP)+,ROLUPD	;RESTORE ROLL CONTROLS
	MOV	(SP)+,ROLPNT
	MOV	(SP)+,ROLNDX
	TST	R0		;SYMBOL IN ROLL?
	BNE	50$		;ITS THERE, DON'T CROSS REF IT
30$:	R50UNP
	MOVB	PAGNUM+1,(R2)+	;MOVE IN PAGE NUMBER
	MOVB	PAGNUM,(R2)+
	MOVB	LINNUM+1,(R2)+	;AND LINE NUMBER
	MOVB	LINNUM,(R2)+
	BISB	#SPACE,@R2	;SET BLANK OR DEF FLAG
	TST	CRFDFL		;CHECK FOR DESTRUCTIVE REF
	BPL	40$		;NOPE - ALL SET
	MOVB	#'*,@R2		;ELSE FLAG IT
40$:	MOV	#12.,@CNTTBL+CRFCHN ;SET COUNT
	$WRITW	CRF		;WRITE THE BUFFER
50$:	CLRB	CRFBUF+11.	;AND CLEAN UP FOR NEXT TIME
	RETURN

ERRROL=	1			;DUMMY ROLL FOR ERRORS
REGROL=	3			;DUMMY ROLL FOR REGISTERS

	ENTSEC	IMPLIN
CRFDFL:	.BLKB	2		;"#" AND "*" FLAGS

	ENTSEC	TXTBYT
CRFTYP:
	.BYTE	SYMROL,<0*40>+<'S&37>
	.BYTE	REGROL,<1*40>+<'R&37>
	.IF NDF	XMACRO
	.BYTE	MACROL,<2*40>+<'M&37>
	.IFF
	.BYTE	-1,0
	.ENDC
	.BYTE	PSTROL,<3*40>+<'P&37>
.if df dirrol
	.BYTE	DIRROL,<4*40>+<'D&37>
.iff
	.BYTE	-1,0
.endc
	.BYTE	SECROL,<5*40>+<'C&37>
	.BYTE	ERRROL,<6*40>+<'E&37>
	XITSEC

	.ENDC

	.SBTTL	MACRO HANDLERS

	.IF NDF	XMACRO

MT.RPT=	177601
MT.IRP=	177602
MT.MAC=	177603
MT.MAX=	MT.MAC

	.GLOBL	REPT,	ENDR,	ENDM,	MEXIT

REPT:				;REPEAT HANDLER
	ABSEXP			;EVALUATE COUNT
	MOV	R0,-(SP)	;SAVE COUNT
	SETPF1			;MARK THE LISTING
	CALL	GETBLK		;GET A STORAGE BLOCK
	CLR	(R2)+		;START IN THIRD WORD
	CLR	-(SP)		;NO ARGUMENTS
	MOV	R0,-(SP)	;  AND START OF BLOCK
	CALL	ENDLIN		;POLISH OFF LINE
	ZAP	DMAROL		;NO DUMMY ARGS FOR REPEAT
	CALL	PROMT		;USE MACRO STUFF

	MOV	#MT.RPT,R5	;FUDGE AN "END OF REPEAT"
REPTF:	CALL	WCIMT
	CALL	MPUSH		;PUSH PREVIOUS MACRO BLOCK
	MOV	(SP)+,(R2)+	;STORE TEXT POINTER
	MOV	(SP)+,(R2)+	;STORE ARG POINTER
	CLR	(R2)+		;COUNTER
	MOV	(SP)+,(R2)+	;MAX
	SETCHR			;RESTORE CHARACTER

ENDMAC:	MOV	#MSBCNT,R0	;SET POINTER TO COUNT
	INC	(R0)		;BUMP IT
	CMP	(R0)+,(R0)+	;THROUGH?
	BGT	10$		;  YES
	MOV	MSBTXT,(R0)	;NO, SET READ POINTER
	ADD	#4,(R0)		;BYPASS LINK
	RETURN

10$:	JMP	MPOP

ENDM:
ENDR:
	ENTOVR	6
	.IFTF
	.GLOBL	OPCERR
OPCERR:	ERROR	O
	RETURN
	.IFT
	XITOVR

	.GLOBL	MACRO,	MACR

	SETOVR	6
MACRO:
MACR:				;MACRO DEFINITION
	GSARG			;GET THE NAME
	BEQ	OPCERR		;  ERROR IF NULL
MACROF:
	TSTARG			;BYPASS POSSIBLE COMMA
	MOV	SYMBOL,MACNAM
	MOV	SYMBOL+2,MACNAM+2
	MSRCH			;SEARCH THE TABLE
	MOV	(R4),R0		;GET THE POINTER
	BEQ	10$		;BRANCH IF NULL
	CALL	DECMAC		;DECREMENT THE REFERENCE
10$:	CALL	GETBLK		;GET A STORAGE BLOCK
	MOV	R0,-(SP)	;SAVE POINTER
	MSRCH			;GETBLK MIGHT HAVE MOVED THINGS
	MOV	(SP)+,(R4)	;SET POINTER
	INSERT			;INSERT IN TABLE
	CRFDEF
	CALL	PROMA		;PROCESS DUMMY ARGS
	CLR	(R2)+		;CLEAR LEVEL COUNT
	MOV	ARGCNT,(R2)+	;KEEP NUMBER OF ARGS
	MOV	MACGSB,(R2)+	;  AND GENERATED SYMBOL BITS
	BIS	#LC.MD,LCFLAG
	CALL	ENDLIN		;POLISH OFF LINE
	CALL	PROMT		;PROCESS THE TEXT
	CMP	VALUE,#END	;ABNORMAL END?
	BNE	20$		;NOPE, PROCEED
	ERROR	P		;SAY THERE'S AN INBALANCE IN .ENDM'S
	JMP	PROPC		;ELSE EXIT THROUGH .END HANDLER

20$:	GETSYM			;GET SYMBOL ON .ENDM STATEMENT
	BEQ	40$		;THERE IS NONE
	CMP	R0,MACNAM	;DOES IT MATCH THE ONE JUST BUILT?
	BNE	30$		;NO. ERROR
	CMP	SYMBOL+2,MACNAM+2	;2ND WORD?
	BEQ	40$		;YES. ITS OK
30$:	ERROR	A
40$:	MOV	#MT.MAC,R5	;SET .ENDM FLAG
	CALL	WCIMT		;WRITE IT IN MACRO TREE
	SETCHR			;RESET REGS
	RETURN
	XITOVR
	.PAGE
MEXIT::	TST MACLVL		;IN A MACRO?
	BEQ OPCERR		;NOPE. ERROR
	TSTARG			;ANY ARGUMENTS?
	BEQ ENDMAC		;NOPE.
	ABSEXP			;GET ARG
	MOV R0,-(SP)		;SAVE VALUE
	BLE 20$			;NULL

10$:	CALL MPOP		;POP OUT OF MACRO
	BLE 20$			;CAN'T POP OUT TOO FAR
	DEC (SP)		;COUNT
	BGT 10$

20$:	TST (SP)+		;PURGE STACK
	RETURN			;DONE

REXIT::	MOV MSBCNT,MSBCNT+2	;TERMINATE REPT/IRP
	BR MEXIT


MPURG::	BR	OPCERR		;DON'T ALLOW PURGE	

MACROC:				;MACRO CALL
	ENTOVR	6
	SETPF0			;MARK LOCATION
	MOV	VALUE,R0	;GET BLOCK POINTER
	BEQ	OPCERR		;  ERROR IF NULL
	MOV	R0,-(SP)
	CALL	INCMAC		;INCREMENT REFERENCE
	CMP	(R0)+,(R0)+	;MOVE UP A COUPLE OF SLOTS
	MOV	(R0)+,ARGMAX	;SET NUMBER OF ARGS
	MOV	(R0)+,MACGSB	;  AND GENERATED SYMBOL BITS
	MOV	R0,-(SP)	;SAVE POINTER
	CALL	PROMC		;PROCESS CALL ARGUMENTS
	MOV	R0,R3		;SAVE BLOCK POINTER
	MOV	#MT.MAC,R5
	CALL	MPUSH		;PUSH NESTING LEVEL
	MOV	(SP)+,MSBMRP
	MOV	(SP)+,(R2)+	;SET TEXT POINTER
	MOV	R3,(R2)+	;  AND ARGUMENT POINTER
	MOV	ARGCNT,(R2)	;FILL IN ARGUMENT COUNT
	MOV	(R2)+,(R2)+	;  AND REPLECATE
	SETCHR
	RETURN
	XITOVR

	.GLOBL	IRP,	IRPC

	SETOVR	6
IRPC:	INC	R3
IRP:
	CALL	GMARG
	BEQ	10$
	CALL	PROMA
	CALL	RMARG
	CALL	GMARG
	BEQ	10$
	MOV	#177777,ARGMAX	;ANY NUMBER OF ARGUMENTS
	CALL	PROMCF
	MOV	R0,R3
	CALL	RMARG
	CALL	GETBLK
	CLR	(R2)+
	MOV	ARGCNT,-(SP)
	MOV	R3,-(SP)
	MOV	R0,-(SP)
	CALL	ENDLIN
	CALL	PROMT
	MOV	#MT.IRP,R5
	JMP	REPTF

10$:	ERROR	A
	RETURN
	XITOVR

	SETOVR	6
PROMA:				;PROCESS MACRO ARGS
	ZAP	DMAROL		;CLEAR DUMMY ARGUMENT ROLL
	CLR	ARGCNT		;GET A FRESH START WITH ARGUMENTS
	CLR	MACGSB		;CLEAR GENERATED BIT PATTERN
	MOV	#100000,-(SP)	;STACK FIRST GENERATED SYMBOL BIT
10$:	TSTARG			;ANY MORE ARGS?
	BEQ	30$		;  NO, QUIT AND GO HOME
	CMP	#CH.QM,R5	;YES, GENERATED TYPE?
	BNE	20$		;  NO
	BIS	(SP),MACGSB	;YES, SET PROPER BIT
	GETNB			;BYPASS IT
20$:	CALL	GSARGF		;GET SYMBOLIC ARGUMENT
	APPEND	DMAROL		;APPEND TO DMA ROLL
	CLC
	ROR	(SP)		;SHIFT GENERATED SYM BIT
	BR	10$

30$:	TST	(SP)+		;PRUNE STACK
	RETURN

	XITOVR

	SETOVR	6
PROMC:	CLR	R3		;MACRO CALL ENTRY
PROMCF:
	CLR	ARGCNT		;START WITH ARGCNT=0
	CALL	GETBLK		;GET SOME MEMORY
	MOV	R0,-(SP)	;SAVE LOCATION
	MOV	R2,-(SP)	;SAVE POINTER TO ARG LINK CELL
	CLR	(R2)+		;SAY THERE IS ONLY  1 ARG
	TST	R3		;MACRO CALL?
	BNE	70$		;NO
10$:	CMP	ARGMAX,ARGCNT	;TOO MANY ARGS?
	BLOS	80$		;YES. STOP LOOKING
	TSTARG			;BYPASS ANY COMMA
	BNE	20$		;OK IF NON-NULL
	TST	MACGSB		;NULL, ANY GENERATED STUFF LEFT?
	BEQ	80$		;  NO, THROUGH
	INC	ARGCNT		;KEEP COUNTING ARGUMENTS
20$:	CMP	#CH.BSL,R5	; "\"?
	BEQ	120$		;  YES
	CALL	GMARGF		;GET ARGUMENT START AND END ADDRESSES (MODIFIES SOURCE)
.IF NDF	XEDLSB
	TST	R5		;ANY ARGUMENTS?
	BNE	30$		;  YES
	TST	MACGSB		;NO, GENERATION REQUESTED?
	BMI	140$		;  YES
.ENDC
30$:	CALL	ARGLNK		;LINK TO NEXT ARGUMENT
40$:	CALL	WCIMTL		;STICK ARGUMENT INTO MEMORY SPACE (PRESERVE LC)
	BEQ	50$		;UNTIL END OF ARGUMENT
	GETCHR			;GET NEXT CHARACTER
	BR	40$		;CONTINUE

50$:	CALL	RMARG		;RESTORE ORIGINAL SOURCE
60$:	ASL	MACGSB		;MOVE GENERATION BIT OVER ONE
	BR	10$

70$:	INC	ARGCNT		;.IRPC PROCESSING
	CALL	ARGLNK		;LINK TO NEXT ARGUMENT
	CALL	WCIMTL		;STUFF BTYE INTO MACRO TREE
	BEQ	80$		;END OF TEXT
	CLR	R5		;SET ARGUMENT TERMINATOR
	CALL	WCIMT
	GETCHR			;GET THE NEXT CHAR
	BNE	70$		;ONE PRESENT
	BR	90$		;NONE PRESENT

80$:	COM	R5		;SIGNAL END OF ARGUMENT BY BIT 7
	CALL	WCIMT		;STUFF IT IN MEMORY
	COM	R5		;RESTORE CHARACTER
90$:	BIT	#LC.MC,LCMASK	;MACRO CALL SUPPRESSION?
	BEQ	110$		;  NO
	MOV	LBLEND,R0	;YES, HAVE WE A LABEL?
	BEQ	100$		;  NO, SUPPRESS ENTIRE LINE
	MOV	R0,LCENDL	;YES, LIST ONLY LABEL
	BR	110$

100$:	BIS	#LC.MC,LCFLAG
110$:	TST	(SP)+		;PURGE STACK
	MOV	(SP)+,R0	;RESTORE R0
	RETURN

120$:	GETNB			; "\", BYPASS
	ABSEXP			;EVALUATE EXPRESSION, ABS
	CALL	ARGLNK		;LINK TO ARGUMENT
	MOV	R5,-(SP)	;STACK CHARACTER
	MOV	R3,-(SP)
	MOV	CRADIX,R3	;BREAK OUT IN CURRENT RADIX
	CMP	R3,#10.		;RADIX > 10?
	BLOS	130$		;NOPE. USE IT AS IS
	MOV	#10.,R3		;ELSE USE 10
130$:	MOV	VALUE,R1	;VALUE TO R1
	CALL	MCNCVT		;CONVERT TO ASCII
	CLR	R5
	CALL	WCIMT
	MOV	(SP)+,R3	;RESTORE REGS
	MOV	(SP)+,R5
	BR	60$

	.IF NDF	XEDLSB
140$:	INC	LSGBAS		;GENERATED SYMBOL, BUMP COUNT
	MOV	LSGBAS,R1	;FETCH IT
	ADD	#64999.,R1	;START AT 65000.
	CALL	ARGLNK		;LINK TO ARGUMENT
	MOV	R5,-(SP)	;STACK CURRENT CHAR
	MOV	R3,-(SP)	;AND R3
	MOV	#10.,R3		;MAKE IT DECIMAL
	CALL	MCNCVT		;CONVERT TO ASCII
	MOV	#CH.DOL,R5
	CALL	WCIMT		;WRITE "$"
	CLR	R5
	CALL	WCIMT
	MOV	(SP)+,R3	;RESTORE REGS
	MOV	(SP)+,R5
	BR	50$		;RETURN
	.ENDC

MCNCVT:
10$:				;MACRO NUMBER CONVERTER
	CLR	R0
	DIV	R3,R0
	MOV	R1,-(SP)	;STACK REMAINDER
	MOV	R0,R1		;SET NEW NUMBER
	BEQ	20$		;DOWN TO ZERO?
	CALL	10$		;  NO, RECURSE
20$:	MOV	(SP)+,R5		;GET NUMBER
	ADD	#DIG.0,R5	;CONVERT TO ASCII
	JMP	WCIMT		;WRITE IN TREE AND EXIT

ARGLNK:	CMP	ARGCNT,#1	;FIRST ARGUMENT?
	BLOS	10$		;YES. JUST EXIT
	MOV	R1,-(SP)	;SAVE A REG
	MOV	4(SP),R1	;GET POINTER TO LINK CELL
	INC	R2		;GET A WORD IN MACRO TREE
	BIC	#1,R2
	CALL	WCIMT		;TELL EVERYONE WE HAVE IT
	DEC	R2		;BACK UP
	MOV	R2,(R1)		;LINK TO THIS ARGUMENT
	MOV	R2,4(SP)	;PASS POINTER FOR NEXT LINK
	CLR	(R2)+		;SAY WE HAVE NO MORE
	MOV	(SP)+,R1	;RESTORE REG
10$:	RETURN			;EXIT

	XITOVR

PROMT:
	ENTOVR	6
	CLR	R3		;NESTING FLAG
10$:	CALL	GETLIN		;GET NEXT LINE OF SOURCE
	BNE	20$		;EOF
	BIS	#LC.MD,LCFLAG	;INDICATE MACRO DEFINITION TO LISTING CONTROLS
	CALL	SETCLI		;GET OPCODE FROM STATEMENT
	BIT	#DFLMAC,R0	;IS IT A MACRO DIRECTIVE?
	BEQ	30$		;NO
	BIT	#DFLEND,R0	;IS IT A .END?
	BNE	20$		;YES, EXIT MACRO
	INC	R3		;BUMP NEXT COUNT
	CMP	#ENDM,VALUE	;.ENDM?
	BNE	40$		;NO. CONTINUE
	DEC	R3		;SUBTRACT 1 FROM NEST
	DEC	R3		;.ENDM APPLY TO MACRO DEFINITION?
	BPL	40$		;NO
20$:	RETURN			;YES. DONE
30$:
	.IF NDF	XSML
	TST	SMLLVL		;IN SYSTEM MACRO?
	BEQ	40$		;  NO
	BIT	#DFLSMC,R0	;YES, NESTED?
	BEQ	40$		;  NO
	CALL	SMLTST		;YES, TEST FOR MORE
	.ENDC
40$:	MOV	#LINBUF,CHRPNT	;BACK UP TO BEGINNING OF LINE
	SETCHR			;SET REGS
50$:	GETSYM			;TRY FOR A SYMBOL
	BEQ	90$		;NOT THERE
	SCAN	DMAROL		;DOES IT MATCH A DUMMY ARG?
	MOV	R0,R4		;R0 = 0 IF MATCH
	BEQ	60$		;NO
	MOV	ROLUPD,R5	;GET INDEX (# OF ARG) INTO R5
	NEG	R5		;FORCE NEGATIVE (POINTS TO ENTRY IN DMAROL)
	DEC	CONCNT		;SIGNAL NO CONCATENATED CHARS
	CALL	WCIMT		;STUFF R5 INTO MACRO TREE
	DEC	CONCNT		;SIGNAL NO CONCATENATED CHARS
60$:	SETSYM			;RESET REGS
70$:	TST	R4		;DID WE INSERT A DUMMY ARG?
	BNE	80$		;YES. SKIP OVER ARG.
	CALL	WCIMTL		;AND INSERT CHARACTER INTO MACRO TREE
80$:	GETR50			;GET LEGAL R50 CHAR
	BGT	70$		;CONTINUE TO DELIMITER
90$:	CMP	R5,#CH.XCL	;APOSTROPHIE?
	BEQ	100$		;YES. CONCATENATION REQUIRED
	CALL	WCIMTL		;NO. STUFF IT INTO MACRO TREE
	BNE	110$		;UNTIL END OF LINE
	CALL	ENDLIN		;POLISH OFF LINE
	BR	10$		;AND CONTINUE

100$:	INC	CONCNT		;INDICATE CONCATENATION RQD
110$:	GETCHR			;SKIP TO NEXT CHAR
	BR	50$		;TRY FOR SYMBOL

	XITOVR

	.GLOBL	NARG,	NCHR
.IF ne,MACXX&.pdp11
	.GLOBL	NTYPE
.ENDC

	SETOVR	2
NARG:				;NUMBER OF ARGUMENTS
	CALL	GSARG		;GET A SYMBOL
	BEQ	NTYPER		;ERROR IF MISSING
	MOV	MSBCNT+2,R3	;SET NUMBER
	BR	NTYPEX

NCHR:				;NUMBER OF CHARACTERS
	CALL	GSARG
	BEQ	NTYPER		;  ERROR ID NO SYMBOL
	CALL	GMARG		;ISOLATE ARGUMENT
	BEQ	NTYPEX		;  ZERO IF NULL
	TST	R5		;QUICK TEST FOR COMPLETION
	BEQ	20$		;  YES
10$:	INC	R3		;BUMP COUNT
	GETCHR			;GET THE NEXT CHARACTER
	BNE	10$		;LOOP IF NOT END
20$:	CALL	RMARG		;REMOVE ARG DELIMITERS
.IF ne,MACXX&.pdp11
	BR	NTYPEX

NTYPE:				;TEST EXPRESSION MODE
	CALL	GSARG		;GET THE SYMBOL
	BEQ	NTYPER		;  ERROR
	TSTARG			;BYPASS ANY COMMAS
	MOV	#SYMBOL,R1
	MOV	(R1)+,-(SP)	;PRESERVE SYMBOL
	MOV	(R1)+,-(SP)
	CALL	AEXP		;EVALUATE
	MOV	R0,R3		;SET RESULT
	ZAP	CODROL		;CLEAR ANY GENERATED CODE
	MOV	(SP)+,-(R1)	;RESTORE SYMBOL
	MOV	(SP)+,-(R1)
.ENDC
NTYPEX:	CLR	MODE		;CLEAR MODE
	MOV	R3,VALUE	;  AND SET VALUE
	JMP	ASGMTF		;EXIT THROUGH ASSIGNMENT

NTYPER:	ERROR	A
	BR	NTYPEX

	XITOVR

	GENCND	B,	TCB
	GENCND	NB,	TCB,	F
	GENCND	IDN,	TCID
	GENCND	DIF,	TCID,	F


	SETOVR	5
TCB:				; "IFB" CONDITIONAL
	BEQ	TCBERX		;OK IF NULL
	CALL	GMARGF		;ISOLATE ARGUMENT
	SETNB			;BYPASS ANY BLANKS
	BEQ	TCIDT		;TRUE IF POINTING AT DELIMITER
	BR	TCIDF		;ELSE FALSE

TCBERR:	ERROR	A		;NAUGHTY
TCBERX:	RETURN

TCID:				; "IFIDN" CONDITIONAL
	BEQ	TCBERR		;ERROR IF NULL ARG
	CALL	GMARGF		;ISOLATE FIRST ARG
	MOV	CHRPNT,R1	;SAVE CHARACTER POINTER
	TST	-(R0)
	MOV	-(R0),R2	;POINTER TO TERMINATOR
	CALL	RMARG		;RETURN THIS ARG
	CALL	GMARG		;GET THE NEXT
	BEQ	TCBERR
10$:	MOVB	(R1),R0		;SET CHARACTER FROM FIRST FIELD
	BPL	20$		;OK IF NO SIGN BIT
	SUB	#177600+40,R0	;else upcase it
20$:	CMP	R1,R2		;IS IT THE LAST?
	BNE	30$		;  NO
	CLR	R0		;YES, CLEAR IT
30$:	CMP	R0,R5		;MATCH?
	BNE	TCIDF		;  NO
	TST	R5		;YES, FINISHED?
	BEQ	TCIDT		;  YES, GOOD SHOW
	GETCHR			;NO, GET THE NEXT CHARACTER
	INC	R1		;ADVANCE FIRST ARG POINTER
	BR	10$		;TRY AGAIN

TCIDF:	COM	R3		;FALSE, TOGGLE CONDITION
TCIDT:	JMP	RMARG		;OK, RESTORE ARGUMENT

	XITOVR

GMARG:				;GET MACRO ARGUMENT
	TSTARG			;TEST FOR NULL
	BEQ	GMARGX		;  YES, JUST EXIT
GMARGF:	SAVREG			;STASH REGISTERS
	CLR	R1		;CLEAR COUNT
	MOV	#CHRPNT,R2
	MOV	(R2),-(SP)	;SAVE INITIAL CHARACTER POINTER
	MOV	#CH.LAB,R3	;ASSUME "<>"
	MOV	#CH.RAB,R4
	CMP	R5,R3		;TRUE?
	BEQ	30$		;  YES
	CMP	R5,#CH.UAR	;UP-ARROW?
	BEQ	20$		;  YES
10$:	BITB	#CT.PC-CT.COM-CT.SMC,CTTBL(R5)	;PRINTING CHARACTER?
	BEQ	60$		;  NO
	GETCHR			;YES, MOVE ON
	BR	10$

20$:	GETNB			; "^", BYPASS IT
	BEQ	50$		;ERROR IF NULL
	MOV	(R2),(SP)	;SET NEW POINTER
	COM	R3		;NO "<" EQUIVALENT
	MOV	R5,R4		;">" EQUIVALENT
30$:	GETCHR
	BEQ	50$		;  ERROR IF EOL
	CMP	R5,R3		; "<"?
	BEQ	40$		;  YES
	CMP	R5,R4		;NO, ">"?
	BNE	30$		;  NO, TRY AGAIN
	DEC	R1		;YES, DECREMENT LEVEL COUNT
	DEC	R1
40$:	INC	R1
	BPL	30$		;LOOP IF NOT THROUGH
	INC	(SP)		;POINT PAST "<"
	BIS	#100000,R5	;MUST MOVE PAST IN RMARG
	BR	60$

50$:	ERROR	A
60$:	MOV	GMAPNT,R0	;GET CURRENT ARG SAVE POINTER
	BNE	70$		;BRANCH IF INITIALIZED
	MOV	#GMABLK,R0	;DO SO
70$:	MOV	(R2),(R0)+	;SAVE POINTER
	MOV	R5,(R0)+	;  AND CHARACTER
	CLRB	@(R2)		;SET NULL TERMINATOR
	MOV	(SP)+,(R2)	;POINT TO START OF ARG
	SETCHR			;SET REGISTER 5
	MOV	R0,GMAPNT	;SAVE NEW BUFFER POINTER
GMARGX:	RETURN

RMARG:				;REMOVE MACRO ARGUMENT
	MOV	GMAPNT,R0	;SET POINTER TO SAVED ITEMS
	MOV	-(R0),R5	;SET CHARACTER
	TST	-(R0)
	MOVB	R5,@(R0)	;RESTORE VIRGIN CHARACTER
	ASL	R5
	ADC	(R0)
	MOV	(R0),CHRPNT
	SETNB
	MOV	R0,GMAPNT
	RETURN

	ENTSEC	IMPPAS
GMAPNT:	.BLKW	1		;POINTER TO FOLLOWING BUFFER
GMABLK:	.BLKW	1		;POINTER TO "BORROWED" CHARACTER
	.BLKW	1		;CHARACTER ITSELF
	.BLKW	3*2		;ROOM FOR MORE PAIRS
	XITSEC

WCIMTL:	MOVB	@CHRPNT,R5	;GET CHARACTER PRESERVING LC
	BIC	#177600,R5	;ISOLATE LOWER 7 BITS
WCIMT:				;WRITE CHARACTER IN MACRO TREE
	DEC	CONCNT		;ANY CONCATENATION CHARS PENDING?
	BMI	10$		;  NO
	MOV	R5,-(SP)	;YES, STACK CURRENT CHARACTER
	MOV	#CH.XCL,R5
	CALL	20$
	MOV	(SP)+,R5
	BR	WCIMT

10$:	CLR	CONCNT
20$:	BIT	#BPMB-1,R2	;ROOM IN THIS BLOCK?
	BNE	30$		;  YES
	SUB	#BPMB,R2	;NO, POINT TO LINK
	MOV	R2,-(SP)
	CALL	GETBLK
	MOV	R0,@(SP)+	;SET NEW LINK
30$:	MOVB	R5,(R2)+	;WRITE, LEAVING FLAGS SET
	RETURN

GETBLK:				;GET A MACRO BLOCK
	MOV	MACNXT,R0	;TEST FOR BLOCK IN GARBAGE
	BNE	10$		;  YES, USE IT
	APPEND	MABROL		;NO, GET BLOCK IN ROLL
	MOV	ROLBAS+MABROL,R0	;GET START
	MOV	R0,ROLTOP+MABROL	;ZAP MAB ROLL
	MOV	R0,ROLBAS+MAAROL	;AWARD SPACE TO MAA
	BR	20$

10$:	MOV	(R0),MACNXT	;SET NEW CHAIN
20$:	MOV	R0,R2
	CLR	(R2)+		;CLEAR LINK CELL, POINT PAST IT
	RETURN



INCMAC:	INC	2(R0)		;INCREMENT MACRO REFERENCE
	RETURN

DECMAC:	DEC	2(R0)		;DECREMENT MACRO STORAGE
	BPL	REMMAX		;JUST EXIT IF NON-NEGATIVE

REMMAC:	MOV	R0,-(SP)	;SAVE POINTER
10$:	TST	(R0)		;END OF CHAIN?
	BEQ	20$		;  YES
	MOV	(R0),R0		;NO, LINK
	BR	10$

20$:	MOV	MACNXT,(R0)
	MOV	(SP)+,MACNXT
REMMAX:	RETURN

MPUSH:				;PUSH MACRO NESTING LEVEL
	CALL	GETBLK		;GET A STORAGE BLOCK
	MOV	#MSBBLK,R1	;POINTER TO START OF PROTOTYPE
	MOV	R2,-(SP)	;SAVE DESTINATION
	MOV	R1,-(SP)	;  AND CORE POINTERS
10$:	MOV	(R1),(R2)+	;XFER AN ITEM
	CLR	(R1)+		;CLEAR CORE SLOT
	CMP	#MSBEND,R1	;THROUGH?
	BNE	10$		;  NO
	MOV	R0,-(SP)	;SAVE POINTER TO LAST BLOCK
	CALL	GETBLK		;GET ANOTHER BLOCK
	MOV	R0,@(SP)+	;LINK TO NEXT BLOCK
	MOV	#CNDWRD,R1	;POINT TO CONDITIONAL FLAGS
	MOV	(R1),(R2)+	;PUT THEM IN MACRO TREE
	CLR	(R1)+		;AND START CONDITIONAL WITH CLEAN SLATE
	MOV	(R1),(R2)+	;3 WORDS
	CLR	(R1)+
	MOV	(R1),(R2)+
	CLR	(R1)
	MOV	(SP)+,R2	;YES, MAKE CORE DESTINATION
	MOV	R5,(R2)+	;SAVE TYPE
	MOV	(SP)+,(R2)+	;  AND PREVIOUS BLOCK POINTER
	INC	MACLVL		;BUMP LEVEL COUNT
	RETURN			;RETURN WITH R2 POINTING AT MSBTXT

MPOP:				;POP MACRO NESTING LEVEL
	MOV	#MSBARG+2,R2	;POINT ONE SLOT PAST ARG
	MOV	-(R2),R0	;GET POINTER TO ARG BLOCK
	BEQ	10$		;BRANCH IF NULL
	CALL	REMMAC		;REMOVE IT
10$:	MOV	-(R2),R0	;POINT TO TEXT BLOCK
	BEQ	20$		;BRANCH IF NULL
	CALL	DECMAC		;DECREMENT LEVEL
20$:	MOV	-(R2),R1	;GET PREVIOUS BLOCK
	TST	-(R2)		;POINT TO START
	MOV	R1,R0		;SAVE BLOCK POINTER
	CALL	XMIT0-<MSBEND-MSBBLK>	;XFER BLOCK
	MOV	-(R0),R1	;LINK TO NEXT ELEMENT
	TST	(R1)+		;SKIP TO DATA
	MOV	#CNDWRD,R2	;POINT TO CONDITIONAL STUFF
	MOV	(R1)+,(R2)+	;RESTORE THEM
	MOV	(R1)+,(R2)+
	MOV	(R1)+,(R2)+
	CALL	REMMAC		;RETURN BLOCKS FOR DEPOSIT
	DEC	MACLVL		;DECREMENT LEVEL COUNT
	RETURN


	ENTSEC	IMPURE
MSBBLK:				;PUSHABLE BLOCK (MUST BE ORDERED)
MSBTYP:	.BLKW			;BLOCK TYPE
MSBPBP:	.BLKW			;PREVIOUS BLOCK POINTER
MSBTXT:	.BLKW			;POINTER TO BASIC TEXT BLOCK
MSBARG:	.BLKW			;POINTER TO ARG BLOCK
MSBCNT:	.BLKW	2		;REPEAT COUNT, ETC.
MSBMRP:	.BLKW			;MACRO READ POINTER
MSBEND:				;END OF ORDERED STORAGE

MACNXT:	.BLKW
MACLVL:	.BLKW			;MACRO LEVEL COUNT
CONCNT:	.BLKW
ARGMAX:	.BLKW
MACNAM:	.BLKW	2
MACGSB:	.BLKW			;MACRO GENERATED SYMBOL BITS
	XITSEC

	.IF NDF	XSML

	.GLOBL	MCALL		;.MCALL

	SETOVR	6
MCALL:
	CALL	SMLTST		;TEST FOR UNDEFINED ARGUMENTS
	BEQ	50$		;  BRANCH IF NONE
	TST	PASS		;FOUND SOME, PASS ONE?
	BNE	40$		;  NO, ERROR
10$:	CALL	INISML		;GET ANOTHER FILE
	BEQ	40$		;  ERROR IF NONE
20$:	CLR	R3		;SET COUNT TO ZERO
30$:	CALL	GETLIN		;GET A NEW LINE
	BNE	10$		;TRY ANOTHER FILE IF EOF
	CALL	SETCLI		;TEST FOR DIRECTIVE
	BIT	#DFLMAC,R0	;MACRO/ENDM?
	BEQ	30$		;  NO
	MOV	#VALUE,R4	;SET FOR LOCAL AND MACROF
	DEC	R3		;YES, ASSUME .ENDM
	CMP	#ENDM,(R4)	;GOOD GUESS?
	BEQ	30$		;  YES
	INC	R3		;NO, BUMP COUNT
	INC	R3
	CMP	#1,R3		;OUTER LEVEL?
	BNE	30$		;  NO
	GSARG			;YES, GET NAME
	BEQ	40$		;  ERROR IF NULL
	MSRCH			;SEARCH TABLE
	BEQ	30$		;IGNORE IF NOT THERE
	TST	(R4)		;FOUND, VALUE OF ZERO?
	BNE	30$		;  NO, NOT INTERESTED
	CALL	MACROF		;GOOD, DEFINE IT
	DEC	SMLLVL		;DECREMENT COUNT
	BGT	20$		;LOOP IF MORE TO GO
	BR	50$		;OK, CLEAN UP

40$:	ERROR	U
50$:	CLR	SMLLVL		;MAKE SURE COUNT IS ZAPPED
	CLR	ENDFLG		;DITTO FOR END FLAG
	JMP	FINSML		;BE SURE FILES ARE CLOSED

SMLTST:				;TEST MCALL ARGUMENTS
10$:	GSARG			;FETCH NEXT ARGUMENT
	BEQ	30$		;  EXIT IF THROUGH
	MSRCH			;OK, TEST FOR MACROS
	BNE	20$		;  FOUND, NOT INTERESTED
	INSERT			;INSERT WITH ZERO POINTER
	INC	SMLLVL		;BUMP COUNT
20$:	CRFDEF			;CREF IT
	BR	10$

30$:	MOV	SMLLVL,R0	;FINISHED, COUNT TO R0
	RETURN

	.GLOBL	MACLI,SMDBLK,SMLSW,FILENM

MACLI:	TSTARG			;SKIP TO ARGUMENT
	BNE	10$		;THERE'S ONE PRESENT
	ERROR	O		;NO GOOD
	RETURN
10$:	MOV	#SMDBLK,R1	;FILE NAME GOES HERE
	MOV	#SMDEXT,R3	;DEFAULT EXTENSION GOES TO R3
	CALL	FILENM		;GET FILE NAME
	.CLOSE	CHAN+SMLCHN
	CLR	SMLSW		;MAKE SURE SYSTEM KNOWS ITS CLOSED
	RETURN

	ENTSEC	IMPPAS
SMLLVL:	.BLKW			;MCALL HIT COUNT
	XITSEC

	.ENDC			;XSML
	XITOVR
	.ENDC			;XMACRO

FILENM:	SAVREG
	MOV	R1,-(SP)
	CLR	(R1)+		;START WITH ALL 0'S
	CLR	(R1)+
	CLR	(R1)+
	CLR	(R1)
	MOV	(SP),R1
	TST	(R1)+		;ASSUME NO DEVICE SPEC'D
10$:	MOV	#26455,R2
	SETR50			;CONVERT THE FIRST CHAR TO R50
20$:	CALL	MULR50		;MULTIPLY BY 50
30$:	ASR	R2		;SIGNIFICANCE?
	BCS	20$		;HIGH
	ADD	R0,(R1)		;COMPUTE R50 EQUIVALENT
40$:	GETR50			;GET THE NEXT R50 CHARACTER
	BLE	60$		;ILLEGAL OR SPACE
	CMP	#34,R0		;R50 DOT?
	BNE	50$		;NO
	MOV	(SP),R1		;SET THE ADDRESS
	ADD	#6,R1		;SKIP TO EXTENSION LOCATION
	MOV	#55,R2		;RESET SIGNIFICANCE FLAGS
	CLR	(R1)		;START WITH 0
	GETR50			;SKIP OVER '.'
	BGT	20$		;OK TO CONTINUE
	BR	70$		;END
50$:	ASR	R2		;SIGNIFICANCE
	BCS	30$		;HIGH
	BEQ	70$		;WORD TOO LONG
	TST	(R1)+		;SKIP TO NEXT WORD
	BR	20$		;CONTINUE
60$:	CMP	#':,R5		;COLON?
	BNE	70$		;END
	MOV	(SP),R1		;RESET POINTER
	MOV	2(R1),(R1)+	;MOVE IN DEVICE NAME (IF ANY)
	CLR	(R1)+		;START WITH 0
	CLR	(R1)+
	CLR	(R1)
	SUB	#4,R1		;BACK UP TO FILE NAME
	GETR50			;SKIP THE ':'
	BGT	10$		;OK TO CONTINUE
70$:	MOV	(SP)+,R1	;PURGE STACK
	TST	(R1)		;DVC SPECIFIED
	BNE	80$		;YEP
	TST	2(R1)		;FILE NAME?
	BEQ	90$		;NO. JUST EXIT
	MOV	(PC)+,(R1)	;MOVE IN DEFAULT DEVICE
	.RAD50	/DK /
80$:	TST	6(R1)		;ANY EXT?
	BNE	90$		;YEP. JUST EXIT
	MOV	R3,6(R1)	;USE DEFAULT
90$:	RETURN

	.END
