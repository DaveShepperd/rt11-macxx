	.NLIST	CND,BEX
	.TITLE OPC69 6809 OP CODE PROCESSOR
	.ENABL	LC

	.REPT	0

The opcode syntax for the 6809 assembler is as follows:

LABEL:	OPCODE	OPERAND		;Comments

The available syntax of the operand(s) is as follows:

null		;Inherent mode (i.e. ABX)
label		;PC relative
@#		;extended mode
#data		;immediate mode
(r)		;Register indirect (0 offset)
@(r)		;Indirect register indirect
(r)+		;Register indirect auto-increment by 1
(r)++		;Register indirect auto-increment by 2
@(r)+		;or
@(r)++		;Indirect register indirect auto-increment by 2
n(r)		;Register indexed. (i.e. EA = n + r where:
		;   n => accumulator A,B or D
		;   n => any other expression)
@n(r)		;Indexed indirect. [i.e. EA = (n + r) where:
		;   n => accumulator A,B or D or
		;   n => any other expression]
-(r)		;Auto-decrement by 1. Register indirect.
--(r)		;Auto-decrement by 2. Register indirect.
@-(r)		;or
@--(r)		;Auto-decrement by 2. Indirect register indirect.

'r' in the above examples may be PC,X,Y,U or S (or the equivalent).

The following is an alternate form of input to specify specific types
of addressing modes:

E,label		;Extended mode
NE,label	;indirect extended
I,data		;Immediate mode
D,label		;Direct page mode
n,label(r)	;and
n,@label(r)	;If n = 5 then forces offset to 5 bit code
		;If n = 8 then forces offset to 8 bit code

	.ENDR
	.PAGE
	.SBTTL MACRO STUFF

	.MACRO	GENCAL	NAME
	.GLOBL	NAME
	.MACRO	NAME
	CALL	NAME
	.ENDM
	.ENDM

	.MACRO	PUSH	ARG
	.IRP	X,<ARG>
	MOV	X,-(SP)
	.ENDR
	.ENDM

	.MACRO	PULL	ARG
	.IRP	X,<ARG>
	MOV	(SP)+,X
	.ENDR
	.ENDM

	.PAGE
	.MACRO	ERROR	CHR
	BIS	#ERR.'CHR,ERRBTS
	.ENDM

...ERR	=1
	.IRPC	X,< ABDEILMNOPQRTUZ>
ERR.'X	=...ERR
...ERR	=...ERR*2
	.ENDR

	GENCAL SETIMM
	GENCAL SETDSP
	GENCAL STCODE
	GENCAL TSTARG
	GENCAL TSTARG
	GENCAL SAVREG
	GENCAL SETXPR
	GENCAL GETSYM
	GENCAL SETSYM
	GENCAL CVTNUM
	GENCAL GLBEXP
	GENCAL STUFPB
	GENCAL GETNB
	GENCAL ABSEXP
	GENCAL SSRCH
	GENCAL GSARG
	GENCAL CRFREF
	GENCAL INSERT
	
	.PAGE
	.GLOBL PCRCNT,BYTMOD,CRFDFL,ROLBAS,CODROL,CRADIX
	.GLOBL	OPCODE,CPOPJ,OPCMAP
	
	.MACRO CHSCAN LABEL
	MOV #LABEL,R0
	CALL CHSCAN
	.ENDM
	
	.GLOBL CHSCAN,VALUE,SYMBOL,MODE,SECTOR,CLCSEC,CLCLOC
	.GLOBL EDBITS,ED.WRN,CLCFGS
	
AM.I	=0001		;IMMEDIATE
AM.D	=0002		;DIRECT
AM.X	=0004		;INDEXED
AM.E	=0010		;EXTENDED
AM.S	=0020		;BRANCH
AM.SPC	=0040		;IMMEDIATE MODE REQUIRES 2 BYTES
AM.SPD	=0100		;DIRECT PAGE HAS UPPER NIBBLE=0
OPC10	=0200		;UPPER BYTE OF OPCODE=10
OPC11	=0400		;UPPER BYTE OF OPCODE=11
AM.SPL	=1000		;LONG BRANCH
	
R.CCR	=1		;CONDITION CODES
R.A	=2		;A
R.B	=4		;B
R.DPR	=10		;DIRECT PAGE
R.X	=20		;X
R.Y	=40		;Y
R.S	=100		;HARDWARE STACK(S)
R.U	=200		;USER STACK(U)
R.PC	=400		;PROGRAM COUNTER
R.D	=1000		;D
	.PAGE
	.SBTTL ENTRY
OPCODE:	MOV	#77776,PCRCNT	;LIST LOCATION OF FIRST WORD ONLY
	BIC	#-256.,R1	;ISOLATE VALUE IN LOW BYTE
	MOV	#OPCMAP,R0	;GET ADDRESS OF AM MAP
	MOV	(R4),(R0)	;GET AM MAP (PASSED TO THIS ROUTINE IN 'VALUE')
	CLR	(R4)		;COVER OUR TRACKS
	ASL	(SP)+		;PRUNE STACK AND TEST SPECIAL BIT
	BPL	6$		;NOTHING TO WORRY ABOUT
	MOV	(R0),R0		;GET INDEX
	CLR	R3		;ZAP THIS FOR ROUTINE'S USE
	JMP	@SPCOPC(R0)	;GO TO ROUTINE

6$:	INC	BYTMOD		;ASSUME BYTE OPCODE
	BIT	#OPC10!OPC11,(R0)	;TRUE?
	BEQ	5$		;YES
	CLR	BYTMOD		;NO. SET WORD MODE
	BIS	#10000,R1	;SET IN UPPER BYTE OF OPCODE
	BIT	#OPC11,(R0)	;TRUE?
	BEQ	5$		;YES
	BIS	#400,R1		;NO. SET IN AN '11'
5$:	MOV	R1,(R4)		;PASS NEW OPCODE
	SETIMM			;PREPARE IT FOR OBJECT
	STCODE			;STUFF IT IN OBJECT
	CLR	BYTMOD		;ASSUME OPERAND IS WORD MODE
	CLR	(R4)		;ZAP OLD VALUE
	MOVB	OPCMAP+1,CRFDFL+1	;SEND CREF STUFF TO CREF CONTROL
	BIT	#^C<OPC11+OPC10>,OPCMAP  ;ANY OPERANDS REQUIRED?
	BEQ	CPOPJ		;NOPE. TAKE ANY EASY EXIT
	SETXPR			;SET REGISTERS
	BIT	#AM.S,OPCMAP	;BRANCH?
	BNE	BRANCH		;YES.
	TSTARG			;SKIP TO OPERAND
	BNE	3$		;THERE'S ONE HERE
	ERROR	A		;N.F.G.
	BIC	#AM.I+AM.SPC+AM.X,OPCMAP	;I OR X ONLY?
	BNE	2$		;NOPE
	MOV	#11022,(R4)	;SET NOPS
2$:	SETIMM			;GIVE 'EM 2 BYTES OF ZERO'S
	STCODE
	MOV	#60,R0		;OPCODE MODIFIER FOR EXTENDED MODE
	TST	OPCMAP		;I OR X ONLY?
	BNE	4$		;NOPE
	MOV	#100022,R0	;YES. INIT R0
	BR	4$
3$:	PUSH	ERRBTS		;SAVE THESE
	CLR	ERRBTS		;AND ZAP THEM FOR OPERAND PROCESSING
	CALL	OPRAND		;DO OPERAND PROCESSING
	BIS	(SP)+,ERRBTS	;MERGE IN OLD ERROR BITS
4$:	MOV	ROLBAS+CODROL,R1 ;GET ADDRESS OF OPCODE IN CODROL
	TST	R0		;ERROR?
	BMI	7$		;YES
	ADD	6(R1),R0	;COMPUTE NEW OPCODE
7$:	MOVB	R0,6(R1)	;STORE IT BACK
CPOPJ:	RETURN			;DONE


SPCOPC:	.WORD	EXG
	.WORD	PSHS
	.WORD	PSHU
	.WORD	PULS
	.WORD	PULU
	.WORD	TFR



	.SBTTL BRANCH HANDLER

BRANCH:	BIT	#AM.SPL,OPCMAP	;LONG?
	BNE 	1$	;YES.
	INC	BYTMOD	;SHORT
1$:	TSTARG		;SKIP TO OPERAND
	BNE	2$	;THERE'S ONE HERE
4$:	MOV	CLCFGS,(RMODE)	;SET FLAGS AND SECTOR
	MOV	CLCLOC,(R4)	;AND VALUE (THIS CAUSES BR TO SELF)
	ERROR	A	;ERROR
3$:	SETDSP		;DO DISPLACEMENT MODE
	STCODE		;INSERT IN CODROL
	RETURN		;DONE

2$:	GLBEXP		;GET EXPRESSION
	BIT	#ERR.U,ERRBTS	;ANY UNDEFINED?
	BNE	4$		;YES
	TST	BYTMOD	;16 BIT OFFSET?
	BEQ	3$	;YES. ITS OK AS IS
	BIT	#CPXFLG!GLBFLG,(RMODE)	;ANY EXTERNAL?
	BNE	4$	;YES. NO GOOD
	CMPB	CLCSEC,(R2)	;IN CURRENT SECTOR?
	BNE	4$	;NO, NO GOOD
	MOV	(R4),R0	;YES. GET VALUE
	SUB	CLCLOC,R0	;COMPUTE VALUE -.
	SUB	#2,R0	;-2 FOR INSTRUCTION SIZE
	BIC	#127.,R0	;-128 < X < 127 ?
	BEQ	3$	;YES. ITS OK
	ADD	#128.,R0
	BNE	4$	;NO. ERROR
	BR	3$	;YES. DO IT
	.PAGE
	.SBTTL OPERAND PROCESSOR
	.GLOBL	GETNB,ED.AMA,EDMASK,SYMBOL,CHRPNT,ERRBTS,EXPFGS

REGFLG	=001			;REGISTER TYPE
DEFFLG	=010			;DEFINED
BSEFLG	=020			;BASE FLAG
RELFLG	=040			;RELOCATABLE
GLBFLG	=100			;GLOBAL
CPXFLG	=200			;COMPLEX EXPRESSION FLAG
PS1FLG	=200			;UNDEFINED

OPRAND:	SAVREG			;SAVE THE REGISTERS
	SETXPR			;INITIALISE THEM (R1) => SYMBOL
				;		 (R2) => SECTOR
				;		 (R3) => MODE
				;		 (R4) => VALUE

RSYM	=R1
RSEC	=R2
RMODE	=R3
RVAL	=R4

	MOV	#20000,-(SP)	;ASSUME INDEXED MODE. 0 FLAGS

FG.1M	=001			;BIT 0 - 1 MINUS FOUND
FG.2M	=002			;    1 - 2 MINUS'S FOUND
FG.5	=004			;    2 - 5 BIT OFFSET REQUIRED
FG.8	=010			;    3 - 8 BIT OFFSET REQUIRED
FG.N	=020			;    4 - @ FOUND
FG.O	=040			;    5 - OFFSET PRESENT
FG.PC	=100			;    6 - OFFSET INDEXED OFF PC
				;    15-8 - OPCODE MODIFIER VALUE

	CLR	(RMODE)		;START WITH NOTHING
	CLR	(RVAL)
OPRTN:	CHSCAN	AMOP1		;LOOK FOR SPECIAL STUFF
	BEQ	2$		;DIDN'T FIND ANY
	ASR	R0		;INDEXED?
	BCS	3$		;NOPE
	BIT	#AM.X,OPCMAP	;LEGAL?
	BEQ	ERRA		;NOPE
3$:	ASL	R0		;FIX ADDRESS
	JMP	(R0)		;EXECUTE SPECIALS

2$:	GETSYM			;TRY FOR A SYMBOL
	BNE	4$		;GOT ONE
	JMP	NDX0		;DIDN'T GET ONE, WHAT'S GOIN' ON?

4$:	CMP	#',,R5		;IS IT REALLY AN ADDRESS MODE SYMBOL?
	BNE	NDXD		;NO. DO INDEXED OPERATION
	MOV	#AMODE,R0	;LOOK FOR AN ADDRESS MODE
1$:	TST	(R0)+		;END OF LIST?
	BEQ	ERRA		;YES. THIS GUY IS A JERK. GIVE 'EM AN ERROR
	CMP	(R1),(R0)+	;MATCH?
	BNE	1$		;NO. CONTINUE LOOKING
	MOV	-4(R0),-(SP)	;SAVE ADDRESS
	TSTARG			;SKIP AM FIELD
	JMP	@(SP)+		;GO TO ROUTINE

ERRA:	ERROR	A		;N.F.G.
ERRR:	MOV	#11022,(RVAL)	;GIVE 'EM NOPS
	CLR	(RMODE)
	MOV	#100022,(SP)	;SET FLAGS
	BR	IRTN

ERTN:	BIT	#AM.E,OPCMAP	;EXTENDED LEGAL?
	BEQ	IRTN		;NO. LEAVE IT
	BIS	#30000,(SP)	;SET OPCODE MODIFIER FOR EXTENDED
IRTN:	SETIMM
DSPRTN:	STCODE
	MOV	(SP)+,R0	;INIT R0 IN CASE OF ERROR
	CMP	R0,#100022	;ERROR?
	BEQ	1$		;YES. JUST EXIT
	CLRB	R0		;ZAP LOW BITS
	SWAB	R0		;PUT OPCODE MODIFIER IN LOW BYTE
1$:	RETURN

AMODE:	.WORD	EXTND
	.RAD50	/E  /
	.WORD	IMM
	.RAD50	/I  /
	.WORD	DIRCT
	.RAD50	/D  /
	.WORD	NEXTD
	.RAD50	/NE /
	.WORD	0		;TERMINATOR

NEXTD:	BIT	#AM.X,OPCMAP	;LEGAL?
	BEQ	ERRA		;NO
	MOV	#237,PBYTE	;SET POST BYTE
	STUFPB			;STUFF IT
	GLBEXP			;EVALUATE EXPRESSION
	BR	IRTN

EXTND:	BIT	#AM.E,OPCMAP	;LEGAL
	BEQ	ERRA
	GLBEXP			;EVALUATE EXPRESSION
	BR	ERTN		;DO QUICK EXIT

IMM:	BIT	#AM.I,OPCMAP	;IMMEDIATE MODE ALLOWED?
	BEQ	ERRA		;NOPE. EXIT
	GLBEXP			;ELSE EVALUATE EXPRESSION
	CLR	(SP)		;ZAP OPCODE MODIFIER AND FLAGS
	BIT	#AM.SPC,OPCMAP	;2 BYTE IMMEDIATE?
	BNE	IRTN		;YES. OK THEN
DRTN:	INC	BYTMOD		;NO. SET BYTE MODE
	BR	IRTN

DIRCT:	BIT	#AM.D,OPCMAP	;DIRECT PAGE ALLOWED?
	BNE	1$		;YES
	ERROR	A		;NOPE
	BR	EXTND		;DO EXTENDED MODE
1$:	GLBEXP			;EVALUATE EXPRESSION
DPGE:	MOV	#10000,(SP)	;SIGNAL DIRECT PAGE
	CMPB	1(RVAL),DPREG	;HIGH BYTE MATCH DP VALUE?
	BEQ	2$		;YES. PROCEED
	bitb	#bseflg,(rmode)	;is it externally a base page?
	bne	2$		;yep, let LINKM take care of error
	ERROR	<>		;WARN 'EM DPAGE REG DON'T MATCH
2$:	CLRB	1(RVAL)		;ELSE ZAP UPPER BYTE
	BIT	#AM.SPD,OPCMAP	;SPECIAL DIRECT?
	BEQ	DRTN		;NO
	MOV	#140000,(SP)	;YES. SET SPECIAL CODE
	BR	DRTN

FIVE:	CMP	#',,R5		;IS IT REALLY A 5?
	BNE	NDXD		;NO. DO INDEXED.
	BIS	#FG.5,(SP)	;SIGNAL 5 BIT OFFSET REQUIRED
EIGHT:	CMP	#',,R5		;IS IT REALLY AN 8?
	BNE	NDXD		;NO. DO INDEXED
	TSTARG			;YES. SKIP ADRESS MODE FIELD
	BIS	#FG.8,(SP)	;SIGNAL 8 BIT OFFSET RQD
	BR	NDX0

NDXD:	SETSYM			;RESET POINTERS
NDX0:	MOV	OPCMAP,R0	;GET ADDRESS MODE MAP
	BIC	#AM.I+AM.SPC,R0	;IMMEDIATE MODE THE ONLY ONE?
	BEQ	IMM		;YEP.
	BIT	#AM.X,R0	;IS INDEXED LEGAL HERE?
	BEQ	EXTND		;NO. TRY EXTENDED MODE
	CHSCAN	AMOP2		;LOOK FOR OPERATOR
	BEQ	AMCD		;NONE FOUND
	JMP	(R0)		;GO TO SPECIAL CODE

AM03:	BIS	#FG.N,(SP)	;SIGNAL INDIRECT FOUND
AMCD:	GLBEXP			;TRY FOR AN EXPRESSION
	MOV	#^B10001101,PBYTE	;ASSUME PC RELATIVE 16 BIT OFFSET
	CMP	#'(,R5		;IS IT REGISTER INDEXED?
	BEQ	JSKPPAR		;YES. SPECIAL STUFF REQUIRED
	BIT	#FG.5,(SP)	;5 BIT OFFSET ASKED FOR?
	BEQ	AM04		;NO. ITS OK THEN
6$:	ERROR	A		;GIVE 'EM AN ERROR
JERTN:	JMP	ERTN		;AND DO EXTENDED
JSKPPAR: JMP	SKPPAR

	.ENABL	LSB
AM04:	BIT	#FG.8,(SP)	;8 BIT OFFSET REQUIRED?
	BNE	50$		;YES. FORCE ALLOCATION TO 8 BITS
	BIT	#ED.AMA,EDMASK	;AMA ENABLED?
	BNE	20$		;NOPE. DO PC RELATIVE
	BIT	#FG.N,(SP)	;INDIRECT REQUESTED?
	BEQ	10$		;NOPE
	MOV	#^B10011111,PBYTE  ;RESET TO INDIRECT EXTENDED
	STUFPB			;STUFF IN POST BYTE
	JMP	IRTN		;EXIT VIA IMMEADIATE MODE

10$:	BIT	#AM.D!AM.E,OPCMAP	;EXTENDED OR DP ALLOWED?
	BEQ	20$		;NOPE. DO PC RELATIVE
NDIM:	BIT	#ERR.A!ERR.U,ERRBTS	;ANY ERRORS?
	BNE	JERTN		;YES. FORCE EXTENDED
	BIT	#BSEFLG,(RMODE)	;DEFINED EXTERNALLY AS A DPAGE?
	BNE	15$		;YEP, GIVE IT A CHECK FOR FWD REFS
	BIT	#CPXFLG!GLBFLG!RELFLG,(RMODE)	;EXTERNALS?
	BNE	JERTN		;YES. FORCE EXTENDED
	CMPB	1(RVAL),DPREG	;MATCH DP REG?
	BNE	JERTN		;NO. FORCE EXTENDED
15$:	CALL	FWDTST		;CHECK FOR FORWARD REFERENCES
	BCS	JERTN		;GOT ONE, GIVE 'EM 16 BIT OFFSET
	BR	DPGE		;FORCE DIRECT PAGE

20$:	BIT	#ERR.A!ERR.U,ERRBTS	;ANY ADDRESS ERRORS?
	BNE	60$		;YES. FORCE IT TO 16 BITS
	BITB	#CPXFLG!GLBFLG,(RMODE)	;ANY EXTERNALS?
	BNE	60$		;YES. FORCE IT TO 16 BITS
	CMPB	(R2),CLCSEC	;IN CURRENT SECTOR?
	BNE	60$		;NO. DO 16 BIT OFFSET
	MOV	#3,R0		;ASSUME 1 BYTE OPCODE, PBYTE, 1 BYTE OFFSET
	BIT	#OPC10!OPC11,OPCMAP	;TRUE?
	BEQ	30$		;SO FAR, YES
	INC	R0		;16 BIT OPCODE
30$:	ADD	CLCLOC,R0	;COMPUTE UPDATED LOCATION COUNT
	NEG	R0		;COMPUTE DIFFERENCE TARGET-CLCLOC
	ADD	(RVAL),R0
	BIC	#127.,R0	;TRY FOR +127 OR -128
	BEQ	40$		;OK TO DO 8 BIT OFFSET IF NO FWD REFS
	ADD	#128.,R0	;-128.?
	BNE	60$		;NOPE, GIVE 'EM 16 BITS
40$:	CALL	FWDTST		;SEE ABOUT FORWARD REFERENCES
	BCS	60$		;GOT ONE, CAN'T DO 8 BIT
50$:	INC	BYTMOD		;SET BYTE MODE
	DEC	PBYTE		;ADJUST POST BYTE
60$:	STUFPB			;STUFF IN POST BYTE
	SETDSP			;SET DISPLACEMENT MODE
	JMP	DSPRTN		;PUT IN OBJECT ROL AND EXIT
	.DSABL LSB

AM02:	CMPB	#'-,R5		;IS IT AUTO-DEC BY 2?
	BNE	2$		;NO
	ADD	#FG.1M,(SP)	;COUNT IT
	GETNB			;SKIP IT
2$:	CMPB	#'(,R5		;IS IT REALLY AUTO-DEC?
	BEQ	3$		;YEP. ALL IS PEACHY
	BIT	#FG.1M+FG.2M,(SP)	;WHAT THE HELL IS GOING ON?
	BEQ	4$		;DON'T KNOW. CONTINUE LOOKING
	JMP	ERRA		;THIS IS BAD NEWS
4$:	SETSYM			;RESET POINTERS
	JMP	AMCD		;DO EXPRESSION
3$:	ADD	#FG.1M,(SP)	;COUNT IT
SKPPAR:	GETNB			;SKIP OVER "-" OR "("

REXP:	MOV	#^B10000100,PBYTE	;INIT TO (R)
	MOV	RVAL,R2		;COPY POINTER
	MOV	ERRBTS,R0	;TEST FOR ANY OFFSET
	BIC	#^C<ERR.A+ERR.U>,R0 ;OR ADDRESS ERRORS
	BIS	(RMODE),R0
	BIC	#DEFFLG!BSEFLG,R0 ;TURN OFF "NUMBER FOUND" AND BASE FLAGS
	BIS	(RVAL),R0	;  (LET VALUE SPEAK FOR ITSELF)
	BEQ	1$		;NOPE. DO (R)
	BIS	#FG.O,(SP)	;SIGNAL OFFSET PRESENT
	PULL	R0		;SAVE FLAGS
	PUSH	<EXPFGS,(R2),-(R2),-(R2),-(R2),R0>	;SAVE OFFSET AND FLAGS
1$:	GETSYM			;GET THE REGISTER SYMBOL
	BEQ	2$		;ERROR
	SSRCH			;LOOK IN THE SYMBOL TABLE
	BEQ	2$		;NOT THERE
	CMPB	#'),R5		;HAPPY ENDING?
	BNE	2$		;NO. ERROR
	GETNB			;SKIP )
2$:	BIT	#FG.1M!FG.2M!FG.O,(SP)	;ANY OFFSET OR AUTO-DEC STUFF?
	BNE	3$		;YEP. CAN'T HAVE AUTO-INCREMENT TOO.
	BIT	#R.PC,(RVAL)	;IS (PC)?
	BNE	3$		;YEP. NO AUTO INC ALLOWED
	CMPB	#'+,R5		;AUTO-INC?
	BNE	3$		;NO.
	GETNB			;YES. SKIP +
	MOV	#200,PBYTE	;START WITH NEW PBYTE
	CMPB	#'+,R5		;AUTO-INC BY 2?
	BNE	10$		;NOPE
	INC	PBYTE		;YEP
	GETNB			;SKIP SECOND +
10$:	BIT	#FG.N,(SP)	;@ MODE?
	BEQ	3$		;NOPE. OK AS IS
	BISB	#1,PBYTE	;FORCE ++
3$:	MOV	(RVAL),R0	;GET REGISTER
	CLR	(RVAL)		;ZAP OLD STUFF
	CLR	(RMODE)
	BIT	#FG.O,(SP)	;OFFSET SUPPLIED?
	BEQ	8$		;NO
	MOV	(SP)+,R1	;YES. SAVE OFFSET STUFF AND MOVE FLAGS TO (SP)
	PULL	<(R2)+,(R2)+,(R2)+,(R2),EXPFGS>	;SAVE OFFSET
	MOV	R1,-(SP)	;SET FLAGS
8$:	CLR	R1		;START INDEX AT 0

6$:	ROR	R0		;FIND BIT
	BCS	5$		;FOUND IT
	BEQ	4$		;N.F.G.
	INC	R1
	BR	6$		;CONTINUE

5$:	BNE	4$		;TOO MANY BITS. ERROR.
	MOVB	RX(R1),R1	;GET DECODED REGISTER NUMBER
	BPL	7$		;ITS X,Y,U OR S
	ASLB	R1		;PC?
	BMI	4$		;NO. ERROR INVALID REGISTER
	BIT	#FG.1M!FG.2M!FG.5,(SP)	;NO SPECIAL STUFF
	BNE	4$		;ERROR
	MOV	#^B10001101,PBYTE	;SET TO PC REL 16 BIT OFFSET
	BIS	#FG.PC,(SP)	;SIGNAL PC MODE
	BR	AMPC

4$:	CLR	R1		;SET TYPE TO 0
	ERROR	R
7$:	BISB	R1,PBYTE	;PUT IN REGISTER CODE
	MOV	PBYTE,R0	;GET POST BYTE
	BIC	#15.,R0		;ZAP LOWER BITS
	BIT	#FG.O,(SP)	;ANY OFFSET?
	BNE	OFFSET		;YES. DO OFFSET FUNCTION
	BIT	#FG.1M+FG.2M,(SP)	;AUTO-DECREMENT DETECTED?
	BEQ	9$		;NO. CONTINUE
	BIS	#3,R0		;SELECT AUTO-DEC BY 2
	BIT	#FG.N+FG.2M,(SP)	;INDIRECT OR AUTO-DEC BY 2?
	BNE	11$		;YES. CONTINUE
	DEC	R0		;NO. AUTO-DEC BY 1. ADJUST PBYTE
11$:	MOV	R0,PBYTE
9$:

STICK:	STUFPB			;PUT PBYTE INTO CODROL
	PULL	R0		;GET FLAGS
	CLRB	R0
	SWAB	R0		;PUT THEM IN LOW BYTE
	RETURN

AMOP1:	.WORD	AM00+1,'#	;IMMEDIATE
	.WORD	AM01,'@		;INDIRECT
	.WORD	AM02,'-		;AUTO-DEC
	.WORD	REXP,'(		;REGISTER-IND
	.WORD	FIVE,'5		;5 BIT OFFSET
	.WORD	EIGHT,'8	;8 BIT OFFSET
	.WORD	0		;TERMINATOR

AMOP2:	.WORD	AM03,'@
	.WORD	AM02,'-
	.WORD	REXP,'(
	.WORD	0

AM00:	BIT	#FG.N,(SP)	;@ FOUND?
	BEQ	1$		;NO. DO IMMEAD
	GLBEXP			;EVALUATE EXPRESSION
	JMP	NDIM		;@# MODE
1$:	JMP	IMM

AM01:	BIS	#FG.N,(SP)	;SAY @ FOUND
	JMP	OPRTN		;CONTINUE
	.PAGE
OFFSET:	BIS	#9.,R0		;SET OFFSET MODE TO 16 BITS
	MOV	R0,PBYTE	;SAVE UPDATED PBYTE
	BITB	#REGFLG,EXPFGS	;OFFSET A REGISTER?
	BEQ	1$		;NOPE
	CLR	R1
	MOV	(RVAL),R0		;GET REGISTER VALUE
	BEQ	3$		;THERE'S NO BIT

4$:	ROR	R0		;LOOK FOR REGISTER BIT
	BCS	2$		;FOUND IT
	INC	R1
	BR	4$

2$:	BNE	3$		;SHOULD ONLY BE 1 BIT
	MOVB	RX(R1),R1	;DECODE REGISTER
	BIC	#-16.,R1	;LEGAL REG(REG)
	BEQ	3$		;NOPE
	BIC	#15.,PBYTE	;CLEAR OUT OLD DATA FROM PBYTE
	BIS	R1,PBYTE	;PUT IN NEW DATA
	BR	STICK

3$:	ERROR	R
	CLR	(RVAL)		;ZAP ANY GIVEN OFFSET
1$:

AMPC:	MOV	(RVAL),R0	;GET GIVEN OFFSET
	BIT	#FG.5,(SP)	;FORCED TO 5 BIT CODE?
	BNE	20$		;YES. GIVE 'EM 5 BITS
	BIT	#FG.8,(SP)	;FORCED TO 8 BIT CODE?
	BNE	50$		;YES. GIVE 'EM 8 BITS
	BIT	#ERR.A+ERR.U,ERRBTS	;ANY ERRORS?
	BNE	60$		;YEP. GIVE 16 BIT OFFSET
	BITB	#BSEFLG,(RMODE)	;ANY BYTE GLOBALS?
	BNE	45$		;YEP, GIVE 'EM 8 BITS IF NO FWD REFS
	BITB	#CPXFLG!GLBFLG!RELFLG,(RMODE) ;EXTERNAL OR RELOCATABLE?
	BNE	60$		;YEP. DO 16 BITS
	TST	R0		;VALUE?
	BNE	20$		;ITS NOT 0(R)
	CALL	FWDTST		;CHECK FOR FORWARD REFERENCE
	BCS	60$		;THERE ARE, FORCE TO 16 BIT
	BIT	#FG.PC,(SP)	;PC MODE?
	BNE	50$		;YEP. NO 0 OFFSET. FORCE 8 BIT
	BIC	#15.,PBYTE	;OUT WITH OLD
	BIS	#4,PBYTE	;IN WITH NEW
10$:	BR	STICK		;(R) MODE

20$:	BIT	#FG.N!FG.PC,(SP)	;INDIRECT OR PC MODE?
	BNE	40$		;YES. DON'T TRY FOR 5 BITS
	CMP	R0,#15.		;WILL IT FIT IN 5 BITS?
	BLOS	30$		;YES
	CMP	R0,#-16.	;CHECK THE OTHER SIDE
	BLO	40$		;TRY FOR 8 BITS
30$:	CALL	FWDTST		;ANY FORWARD REFERENCES?
	BCS	60$		;YEP, HAFTA GIVE 'EM 16 BITS
	BIC	#-32.,R0	;MASK TO 5 BITS
	BIC	#200+31.,PBYTE	;MAKE ROOM IN PBYTE FOR NEW DATA
	BIS	R0,PBYTE	;SELECT 5 BIT OFFSET
	BR	10$

40$:	CMP	R0,#127.	;WILL IT FIT IN 8 BITS
	BLOS	45$		;YES.
	CMP	R0,#-128.	;CHECK OTHER SIDE
	BLO	60$		;NO. DO 16 BITS
45$:	CALL	FWDTST		;ANY FORWARD REFERENCES?
	BCS	60$		;YEP, HAFTA GIVE 'EM 16 BITS
50$:	DEC	PBYTE		;ADJUST PBYTE
	INC	BYTMOD		;SET TO BYTEMOD
60$:	STUFPB
	JMP	IRTN		;DO IMMEDIATE MODE RETURN

FWDTST:	CLC			;ASSUME ITS OK
	BIT	#PS1FLG,EXPFGS	;FWD REFERENCE?
	BEQ	20$		;NOPE
	BIT	#ED.WRN,EDMASK	;.ENABL WRN?
	BNE	10$		;NO, JUST GIVE 'EM 16 BITS
	ERROR	<>		;ELSE GIVE 'EM A WARNING TOO
10$:	SEC
20$:	RETURN

RX:	.BYTE	300,306,305,300,0,40,140,100,200,313
	.BYTE	300,300,300,300,300,300		;ROUND OFF TO 16 PLACES

OPCMAP:	.WORD	0		;ADDRESS MODE MAP GOES HERE
PBYTE:	.WORD	0		;POST BYTE IS CONSTRUCTED HERE
	.PAGE
STUFPB:	MOV	2(SP),R0	;GET FLAGS
	BICB	#^C<FG.N>,R0	;ZAP ALL BUT @ BIT
	BIS	PBYTE,R0	;PUT PBYTE INTO R0
	BIT	#OPC10!OPC11,OPCMAP	;16 BIT OPCODE?
	BNE	1$		;YES. PUT PBYTE SEPERATE
	PUSH	R1		;SAVE R1
	MOV	ROLBAS+CODROL,R1 ;GET ADDRESS OF OBJECT ROLL
	ADD	#6,R1		;SKIP TO OPCODE TEXT
	SWAB	(R1)		;FLIP OPCODE BYTE TO UPPER BYTE
	ADD	R0,(R1)		;FORCE INDEXED AND SET PBYTE
	BIC	#100000,-(R1)	;SET OPCODE TO WORD MODE
	PULL	R1		;RESTORE R1
	CLR	2(SP)		;ZAP ALL FLAGS
	RETURN			;AND EXIT

1$:	PUSH	(R4)		;SAVE CURRENT VALUE
	MOVB	R0,(R4)		;PUT PBYTE INTO VALUE
	CLRB	1(R4)		;ZAP UPPER BYTE
	PUSH	-(R4)		;SAVE MODE
	CLR	(R4)		;AND ZAP IT
	PUSH	<-(R4),-(R4),BYTMOD>	;SAVE SYMBOL AND BYTMOD
	INC	BYTMOD		;SET BYTE
	SETIMM			;PREPARE FOR OBJECT ROLL
	STCODE			;STUFF IT
	PULL	<BYTMOD,(R4)+,(R4)+,(R4)+,(R4)>
	RETURN

	.SBTTL DPAGE CONTROL

	.GLOBL DPAGE,DPREG,TSTRLD,OBJDMP,objpnt

DPAGE:	ABSEXP			;GET VALUE
	bit	#-256.,r0	;high byte = 0?
	bne	1$		;nope, error then
	MOV	R0,DPREG	;SAVE IT
	tst	objpnt		;any object stuff?
	beq	2$		;nope, take an easy exit
	call	objdmp		;flush out buffer
	mov	#4,r0		;.dpage RLD arg is 4 bytes big
	call	tstrld		;get args
	mov	#rldt20,(r2)+	;set the RLD type
	mov	dpreg,(r2)	;and the dp reg value
	jmp	objdmp		;flush it again
	
1$:	ERROR	A		;ELSE ERROR
2$:	RETURN
	.PAGE
	.SBTTL EXG,PSHS,PSHU,PLUS,PULU,TFR

EXG:	
TFR:
	CLR	BYTMOD
	MOV	#2,ARG$CNT	;OP CODE TO UPPER BYTE
	SWAB	R1
7$:	GSARG			;GET A SYMBOL
	BEQ	1$		;DONE
	SSRCH			;SEARCH SYMOBL TABLES
	INSERT			;UPDATE SYMBOL TABLE
	CRFREF			;CROSS-REF IT
	BITB	#REGFLG,MODE	;REGISTER TYPE?
	BNE	2$		;YES
	CLR	(RVAL)		;NOT ALLOWED
2$:	CLR	R2
	MOV	(RVAL),R0		;GET BIT
5$:	INC	R2	
	ROR	R0		;LOOK FOR BIT
	BCS	3$		;FOUND IT
	BNE	5$		;CONTINUE
6$:	CLR	R2
	CLR	R0		;ZAP ANY EXTRANEOUS BITS
3$:	BNE	6$		;ONLY 1 BIT ALLOWED
	ASLB	R1
	ASLB	R1
	ASLB	R1
	ASLB	R1
	BISB	TFEX(R2),R0
	BMI	9$		;NO, GOOD
	BISB	R0,R1
	MOVB	#200,CRFDFL+1	;DESTRUCTIVE REF
	DEC	ARG$CNT		;2 OPERANDS RQD.	
	BNE	7$		;CONTINUE
1$:	TST	ARG$CNT		;2 ARG?
	BEQ	8$		;YES
9$:	ERROR	R		;ERROR
8$:	CLR	MODE		;SET ABS
	MOV	R1,(RVAL)	;SET VALUE
	MOV	R1,R0		;GET A COPY
	ASR	R1
	ASR	R1
	ASR	R1
	ASR	R1
	BIC	#^C10,R1	;ZAP ALL BUT 1 BIT
	BIC	#^C10,R0	;ZAP ALL BUT 1 BIT
	SUB	R0,R1		;TYPES MATCH
	BEQ	10$		;YES
	ERROR	R		;NO. SET ERROR
10$:	SETIMM			;SET UP FLAGS
	STCODE			;STUFF IT
	RETURN			;DONE
	
ARG$CNT: .WORD	0
	
TFEX:	.BYTE -1,12,10,11,13,1,2,4,3,5,0,-1,-1,-1,-1,-1,-1,-1	;18 BYTES
	.PAGE
PULS:	MOV	#16.,R3
PULU:	MOVB	#200,CRFDFL+1	;SIGNAL DEST
	BR	PPLL
PSHS:	MOV	#16.,R3
PSHU:
PPLL:
	SWAB	R1		;PUT VALUE INTO UPPER BYTE
	CLR	BYTMOD		;SET TO WORD MODE
4$:	GSARG			;TRY FOR AN ARGUMENT
	BEQ	1$		;END
	SSRCH			;LOOK FOR IT IN SYMBOL TABLE
	INSERT			;UPDATE SYMROL
	CRFREF			;CROSS REFERENCE IT
	BITB	#REGFLG,MODE	;REGISTER TYPE?
	BEQ	2$		;NO. ERROR
	CLR	R2
	MOV	(RVAL),R0	;GET VALUE
	BEQ	2$		;NONE PRESENT. ERROR
5$:	ROR	R0		;LOOK FOR BIT
	BCS	3$
	BEQ	4$		;DONE. TRY FOR ANOTHER
	INC	R2
	BR	5$
3$:	PUSH	R3		;SAVE POINTER INDEX
	ADD	#PSHTBL,(SP)	;COMPUTE ADDRESS
	ADD	R2,(SP)
	MOVB	@(SP)+,-(SP)	;GET DATA
	BNE	6$
	ERROR	R
	CLR	(SP)
6$:	BISB	(SP)+,R1	;PUT IN DATA
	BR	5$		;CONTINUE

2$:	ERROR	R		;SIGNAL ERROR
	BR	4$

1$:	MOV	R1,(RVAL)	;PASS VALUE
	CLR	MODE		;SET ABS
	SETIMM			;SET FLAGS
	STCODE			;STUFF IT
	RETURN			;DONE

PSHTBL:	.BYTE 1,2,4,10,20,40,100,0,200,6,0,0,0,0,0,0
	.BYTE 1,2,4,10,20,40,0,100,200,6,0,0,0,0,0,0

	.END

