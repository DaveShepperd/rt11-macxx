	.TITLE	OPC65C	65C02 OP CODE PROCESSOR
	.ENABL LC

	.PSECT OPC65C

	.MACRO GENCAL NAME
	.MACRO NAME
	CALL	NAME
	.ENDM NAME
	.ENDM GENCAL

	GENCAL STCODE
	GENCAL SETIMM
	GENCAL SAVREG
	GENCAL GETSYM
	GENCAL SETSYM
	GENCAL TSTARG
	GENCAL GLBEXP
	GENCAL ABSEXP
	GENCAL RELEXP
	GENCAL GETNB

	.MACRO AMM Z
	.IRP X,Z
AM.'X=..AMI
..AMI=..AMI+..AMI
	.RAD50	/X/
	.ENDR
	.ENDM AMM

..AMI=1
AMCHR:
	AMM	<<<NX >,<Z  >,<I  >,<A  >,<NY >,<ZX >>>
	AMM	<<<AY >,<AX >,<S  >,<AC >,<N  >,<ZY >>>
AM.SPC=..AMI
	AMM	<<<X  >,<Y  >>>
	.WORD	0		;STOPPER


	.MACRO	XOR	S,D
	MOV	S,-(6)
	BIC	D,(6)
	BIC	S,D
	BIS	(6)+,D
	.ENDM	XOR

	.MACRO	PUSH ARG
	MOV	ARG,-(SP)
	.ENDM

	.MACRO	PULL ARG
	MOV	(SP)+,ARG
	.ENDM


	.MACRO	ERROR CHR
	BIS	#ERR.'CHR,ERRBTS
	.ENDM

ERRI=1
	.IRPC	X,< ABDEILMNOPQRTUZ>
ERR.'X=ERRI
ERRI=ERRI+ERRI
	.ENDR
	.PAGE
.if ne,macxx&..m65c
	.GLOBL OP.BIT,OP.DEC,OP.INC,OP.JMP,OP.STZ
.endc
	.GLOBL CODROL,EXPFGS

OPCL00=0		;0 operands required
OPCL01=1		;Bit mode instruction
OPCL02=2		;0,1 or 2 operands required
OPCL03=3		;Branch instruction
OPCL04=4		;Branch on bit instruction

OPCODE:			;PROCESS OPCODE
	MOV	#77776,PCRCNT	;LIST LOCATION OF FIRST BYTE ONLY
	INC	BYTMOD		;ALL OPCODES ARE BYTE MODE
	MOV	R1,R2		;GET A COPY OF THE CLASS
	CLRB	R2
	SWAB	R2		;GET CLASS
	ASLB	R2		;*2 SO WE CAN JUMP @
	BIC	#-256.,R1	;GET VALUE
	MOV	(R4),OPCMAP	;GET COPY OF AM
	MOV	R1,(R4)		;REPLACE VALUE
.if ne,macxx&..m65c
	MOV	R1,(PC)+	;KEEP A COPY FOR LATER
OPCVAL:	.WORD
.endc
	SETIMM			;CONVERT TO OBJECT FORMAT
	STCODE			;INSERT INTO CODROL
	CLR	(R4)		;RESET VALUE
	MOVB	OPCMAP+1,CRFDFL+1	;PASS DES FLAG TO CREF
	PULL	R1		;PRUNE STACK
	JMP	@OPTYPE(R2)	;GO TO TYPE OF OPCODE

OPTYPE:	.WORD	CPOPJ		;NO OPERANDS REQUIRED
.if ne,macxx&..m65c
	.WORD	BITMODE		;BIT MODE INSTRUCTION
	.WORD	ANYARG		;ORDINARY INSTRUCTIONS
	.WORD	BRANCH		;BRANCH INSTRUCTION
	.WORD	BITBRN		;BRANCH ON BIT
.iff
	.WORD	CPOPJ		;class 1 is illegal in MAC65
	.WORD	ANYARG		;ORDINARY INSTRUCTIONS
	.WORD	BRANCH		;BRANCH INSTRUCTIONS
	.WORD	CPOPJ		;class 4 is illegal in MAC65
.endc

ANYARG:	TSTARG			;SPACE TO OPERAND
	BNE	50$		;OPERAND is PRESENT
	BIT	#AM.AC,OPCMAP	;GADS! NO OPERAND. IS THIS LEGAL?
	BNE	10$		;YEAH. HE LUCKED OUT.
	ERROR	Q		;FLAG IT AS ERROR
	CLR	BYTMOD		;AND GIVE HIM 2 BYTE OF ZEROES
	SETIMM
	STCODE
	MOV	#12.,R0		;FORCE TO 'AM.A' MODE
	BR	60$		;EXIT

10$:
.if ne,macxx&..m65c
	MOV	#170,R0		;ASSUME ITS A "DEC"
	CMPB	OP.DEC+4,OPCVAL	;TRUE?
	BEQ	60$		;YEP
	MOV	#70,R0		;ASSUME ITS A "INC"
	CMPB	OP.INC+4,OPCVAL	;TRUE?
	BEQ	60$		;YEP
.endc
	MOV	#10,R0		;"accum" mode is same as "#"
	BR	60$

50$:	PUSH	ERRBTS
	CLR	ERRBTS
	CALL	OPRAND		;DO OPERAND ROUTINE
	BIS	(SP)+,ERRBTS
60$:
OPCMOD:	MOV	ROLBAS+CODROL,R1   ;ADDRESS OF OPCODE
	ADD	6(R1),R0	;UPDATE OPCODE TO CORRECT ADDRESS MODE
	MOVB	R0,6(R1)	;STUFF IT BACK
CPOPJ:	RETURN			;EXIT
	.PAGE
	.SBTTL	OPERAND PROCESSOR
	.ENABL	LSB
	.GLOBL	GETNB,ED.MOS,ED.AMA,EDMASK,SYMBOL,EXPFGS

OPRAND:	SAVREG			;1 OR 2 OPERANDS REQUIRED
	INC	EXPFLG		;COMMA EXPECTED.
	CLR	(PC)+		;START WITH NO ADDRESS MODE
AMDCD:	.WORD	0
	CMP	#'#,R5		;IMMEADIATE MODE REQUEST?
	BNE	40$		;NO
	GETNB			;YES. SKIP THE CHARACTER
	MOV	#AM.I,R0	;GET IMMEADIATE MODE CODE
20$:	MOV	R0,AMDCD
30$:	MOV	#100000,-(SP)	;SIGNAL IT MUST NOT BE INDEXED
	JMP	INDEX		;GOTO INDEX PROCESS

40$:	MOV	#'@,R0		;ASSUME MAC65 FORMAT
	BIT	#ED.MOS,EDMASK	;MOS TECH FORMAT?
	BNE	45$		;NOPE, OK AS IS THEN
	MOV	#'(,R0		;ELSE USE ALTERNATE FORMAT
45$:	CMP	R0,R5		;INDIRECT MODE REQUEST?
	BNE	50$		;NO
	GETNB			;YES. SKIP THE CHARACTER
	MOV	#200,-(SP)	;SIGNAL THE "@" OR "(" DETECTED
	JMP	INDEX		;GOTO INDEX PROCESSING

50$:	BIT	#ED.MOS,EDMASK	;MOS TECH FORMAT?
	BNE	60$		;NOPE
	CLR	-(SP)		;SIGNAL THAT IT MAY BE INDEXED
	JMP	INDEX

60$:	GETSYM			;TRY FOR AM SYMBOL
	CMP	#',,R5		;IS THE NEXT THING A COMMA?
	BEQ	70$		;YEP. THIS MUST BE AN ADDRESS MODE
	SETSYM			;RESET POINTERS
	CLR	-(SP)		;SIGNAL THAT IT MAY BE INDEXED
	JMP	INDEX

70$:	MOV	#AMCHR,R1
	MOV	#1,R2
80$:	CMP	R0,(R1)+	;MATCH?
	BEQ	100$		;YEP
	ASL	R2		;COMPUTE NEW AM
	TST	(R1)		;END?
	BNE	80$		;NO. TRY AGAIN

INVAM:	ERROR	Q
90$:	TSTARG			;SKIP ARGUMENT
	BR	30$		;TRY FOR SOMETHING ELSE

100$:	BIT	#AM.X!AM.Y,R2	;SPECIAL X, OR Y,?
	BEQ	120$		;NOPE
	BIT	#AM.X,R2	;X,?
	BNE	110$		;YEP
	INC	R2
110$:	BIC	#-2,R2		;CLEAR ALL BUT BIT 1
	TSTARG			;SKIP TO SECOND ARG
	GLBEXP			;EVALUATE EXPRESSION
	CLR	-(SP)		;SET INDEX TYPE
	JMP	ALTNDX

120$:	MOV	R2,AMDCD	;SAVE AM
	BR	90$		;GO PROCESS OPERAND
	.DSABL	LSB

OPRET:	MOV	AMDCD,R0	;GET REQUEST AM
	BEQ	10$		;MUST BE INHERENT
	MOV	R0,R2		;ELSE USE IT
10$:	bit	r2,opcmap	;is the detected address mode legal here?
	bne	12$		;yep
	error	q		;else give 'em an "q"
	mov	#am.a,r2	;and force absolute mode
12$:
.IF NE,MACXX&..M65C
	CMPB	OP.JMP+4,OPCVAL	;"JMP"?
	BNE	15$		;NOPE
	BIT	#AM.N!AM.NX,R2	;SPECIAL MODES?
	BEQ	55$		;NOPE, LEAVE IT THEN
	MOV	#54,R1		;ASSUME "@" (^X2C)
	BIT	#AM.N,R2	;TRUE?
	BNE	85$		;YEP, RETURN WORD MODE
	MOV	#74,R1		;ELSE MUST BE "NX",
	BR	85$		;RETURN WORD MODE

.IFTF
15$:	BIT	#AM.N,R2	;INDIRECT REQUEST?
	BEQ	20$		;NO
.IFT
	MOV	#21,R1		;YES. USE A ^X11
	BR	80$
.IFF
	MOV	#54,R1		;YES, USE A ^X2C
	BR	85$		;EXIT WORD MODE
.IFTF

20$:
.IFT
	CMPB	OP.BIT+4,OPCVAL	;"BIT"?
	BNE	25$		;NOPE
	BIT	#AM.I,R2	;ASKING FOR "#"?
	BEQ	25$		;NOPE
	MOV	#151,R1		;YEP, RESET THE OFFSET
	BR	80$

.IFTF
25$:	BIT	#AM.SPC,OPCMAP	;SPECIAL INSTRUCTION?
	BEQ	50$		;NO
	BIT	#AM.I,R2	;IMMEADIATE MODE?
	BEQ	30$		;NO
	CLR	R1		;FAKE NX
	BR	80$

30$:	BIT	#AM.AY,R2	;AY?
	BEQ	40$		;NO
	MOV	#28.,R1		;YES. FAKE AX
	BR	80$

40$:	BIT	#AM.ZY,R2	;ZY?
	BEQ	50$		;NO
	MOV	#20.,R1		;YES. FAKE ZX
	BR	80$

50$:
.IFT
	CMPB	OP.STZ+4,OPCVAL	;"STZ"?
	BNE	55$		;NOPE
	MOV	#344,R1		;ASSUME "ZX"
	BIT	#AM.ZX,R2	;TRUE?
	BNE	80$		;YEP
	MOV	#16,R1		;ASSUME "AX"
	BIT	#AM.AX,R2	;TRUE?
	BNE	80$		;YEP
	MOV	#324,R1		;ASSUME "Z"
	BIT	#AM.Z,R2	;TRUE?
	BNE	80$		;YEP
	MOV	#14,R1		;ASSUME "A"
	BR	80$

.ENDC
55$:	MOV	R2,R0		;GET A COPY OF AM
	BEQ	INVAM		;NO GOOD
	CLR	R1
60$:	ROR	R0		;FIND AM BIT
	BCS	70$		;FOUND IT
	BIT	(R1)+,R1	;INCREMENT R1 BY 2 WITHOUT DISTURBING CARRY
	BR	60$

70$:	ASL	R1		;COMPUTE OPCODE MODIFIER
80$:	BIT	#AM.AX!AM.AY!AM.A,R2	;WORD MODE?
	BEQ	90$		;NOPE
85$:	CLR	BYTMOD		;YEP
90$:	PUSH	R1		;SAVE MODIFIER
OPXIT:	SETIMM
	STCODE
	PULL	R0
	RETURN

	.PAGE
	.ENABL LSB
BRANCH:	CLR	R4		;NO OPCODE MODIFIER ON BRANCHES
	MOV	#2,R3		;BRANCH OFFSET
	mov	#err.q,r1	;assume q error first
COMBRN:	TSTARG			;ANY ARG?
	BEQ	BRERR		;NOPE, ERROR OUT THEN
	mov	#err.a,r1	;bad address gets an "A"
	RELEXP			;CAN'T BE GLOBAL
	CLRB	MODE		;DISREGARD RELATIVE FLAGS
	CLR	RELLVL		;AND LEVEL
	CMPB	SECTOR,CLCSEC	;CAN'T BRANCH ACROSS CSECT
	BNE	BRERR
	SUB	CLCLOC,R0	;COMPUTE DISPLACEMENT
	SUB	R3,R0		;COMPUTE DISPLACEMENT
	BPL	3$		;BRANCH FORWARD
	ADD	#400,R0		;ALL 1'S IN HIGH BYTE?
	BMI	BRERR		;NO.ERROR OFFSET OUT OF RANGE
	TSTB	R0		;>128?
	BPL	BRERR		;ERROR. OFFSET OUT OF RANGE
5$:	BIC	#256.,R0	;RESET ANY HIGH BITS
	MOV	R0,VALUE
	BR	6$

3$:	BIT	#-128.,R0	;>127?
	BEQ	5$		;YEP.
BRERR:	NEG	R3		;SET IT TO BR .
	MOV	R3,VALUE
	bis	r1,errbts	;set the error
6$:	PUSH	#OPCMOD		;RETURN TO OPCMOD
	MOV	R4,-(SP)	;PASS OPCODE MODIFIER
	JMP	OPXIT		;STUFF IT

OPCMAP:	.BLKW	1
	.DSABL	LSB
.IF NE,MACXX&..M65C
	.PAGE
	.SBTTL BIT MODE INSTRUCTIONS

BITBRN:	CLR	R4		;ASSUME NO OPCODE MODIFIERS
	MOV	#3,R3		;3 BYTES TO THIS OPERAND
	mov	#err.q,r1	;assume "Q" if errors
	TSTARG			;ANY ARG?
	BEQ	5$		;NOPE, GIVE 'EM AN ERROR
	CALL	GETBIT		;GET THE BIT NUMBER
	MOV	R0,R4		;SAVE IT
	INC	EXPFLG		;COMMA EXPECTED
	TSTARG			;SKIP TO PZ ADDRESS
	BNE	10$		;GOT ONE
5$:	CLR	MODE
	CLR	VALUE
	SETIMM			;SET IMMEDIATE MODE
	STCODE			;INSERT IT
	BR	BRERR		;AND GO TO BRANCH ERROR

10$:	GLBEXP			;GET THE PAGE ZERO ADDRESS
	SETIMM			;STUFF IT
	STCODE
	BR	COMBRN		;DO COMMON BRANCH STUFF

BITMODE: TSTARG			;ANY ARG?
	BNE 10$			;YEP, OK THEN
	CLR	-(SP)		;NO OPCODE MODIFIER
5$:	ERROR	Q		;a missing argument
	CLR	VALUE		;GIVE 'EM A BYTE OF ZEROS
	CLR	MODE
	BR	OPXIT		;STUFF IT

10$:	CALL	GETBIT		;GET THE BIT NUMBER
	MOV	R0,-(SP)	;SAVE IT
	INC	EXPFLG		;COMMA EXPECTED
	TSTARG			;ANY ARG?
	BNE	20$		;YEP
	MOV	(SP),-(SP)	;MOVE THE BIT NUMBER
	MOV	#OPCMOD,2(SP)	;SET THE RETURN ADDRESS
	BR	5$		;AND GO SET ERROR

20$:	GLBEXP			;GET THE OPERAND ARGUMENT
	MOV	(SP),-(SP)	;MOVE THE BIT NUMBER
	MOV	#OPCMOD,2(SP)	;SET THE RETURN ADDRESS
	BR	OPXIT		;STUFF IT AND RETURN	

GETBIT:	ABSEXP			;GET THE BIT NUMBER
	BIT	#-8.,R0		;LEGAL?
	BEQ	20$		;YEP
	ERROR	A		;NOPE
	BIC	#-8.,R0		;BUT USE IT ANYWAY
20$:	ASL	R0		;SHIFT IT 4 PLACES LEFT
	ASL	R0
	ASL	R0
	ASL	R0
	RETURN
.ENDC
	.PAGE
	.SBTTL OPERAND EVALUATOR
	.ENABL	LSB
INDEX:	GLBEXP				;EVALUATE EXPRESSION
	MOV	#2,R2			;START WITH Z PAGE ADDRESSING
	TST	(SP)			;INDEX ALLOWED?
	BMI	30$			;NOPE
	BIT	#ED.MOS,EDMASK		;MAC65 FORMAT?
	BNE	5$			;YEP
	JMP	MOSTEC			;ELSE TRY FOR MOSTECH FORMAT

5$:	CMP	#'(,R5			;IS IT INDEXED?
	BEQ	10$			;YES
	TSTB	(SP)			;NO. "@" DETECTED?
	BPL	30$			;NO. ITS OK AS IS
	MOV	#AM.N,R0		;ITS JUST "N"
	BR	70$

10$:	GETNB				;SKIP OVER '('
	CLR	R2			;START WITH X
	CMPB	#'X,R5			;GOT IT?
	BEQ	20$			;YEP
	INC	R2			;SKIP UP TO Y
	CMPB	#'Y,R5			;GOT IT?
	BNE	60$			;ERROR
20$:	GETNB				;SKIP OVER 'X' OR 'Y'
	CMP	#'),R5			;CLOSING CORRECTLY?
	BEQ	25$			;YEP
	ERROR	Q			;ELSE GIVE 'EM TROUBLE
	BR	ALTNDX

25$:	GETNB				;SKIP OVER THE ')'

ALTNDX:
30$:	MOV	VALUE,R0		;GET VALUE
	MOVB	MODE,R1			;AND FLAGS
	CLC
	BIT	#ED.AMA,EDMASK		;AMA ON?
	BNE	50$			;NO
	BIT	#ERR.A!ERR.U!ERR.Q,ERRBTS	;ANY ERRORS?
	BNE	40$			;YES. FORCE ABS
	BIT	#FWDFLG,EXPFGS		;FWD REFERENCES?
	BNE	40$			;YEP, FORCE ABS
	BIT	#BSEFLG,R1		;BASE PAGE?
	BNE	50$			;YEP. DON'T CARE ABOUT ANYTHING ELSE
	BIT	#RELFLG!GLBFLG,R1	;RELOCATABLE?
	BNE	40$			;YES
	BIT	#DEFFLG,R1		;DEFINED?
	BEQ	40$			;NO
	BICB	R0,R0			;TEST FOR VALUE IN RANGE
	SWAB	R0
	BEQ	50$			;ITS < 256
40$:	SEC				;FORCE 'A' MODE
50$:	ROL	R2
	ASLB	(SP)
	ROL	R2
	ASL	R2
	MOV	NDXTBL(R2),R0		;GET ADDRESS MODE
	BIT	R0,OPCMAP		;LEGAL?
	BNE	70$			;YES
	XOR	#4,R2			;NO. FLIP AM A/Z
	MOV	NDXTBL(R2),R0		;TRY AGAIN
	BIT	R0,OPCMAP		;LEGAL?
	BNE	70$			;YES. OK
60$:	ERROR	Q
65$:	MOV	#AM.A,R0
70$:	MOV	R0,R2			;PASS THE AM
80$:	TST	(SP)+			;PURGE STACK
	JMP	OPRET			;DONE

MOSTEC:	tstb	(sp)			;what the hell is going on?
	bpl	150$			;hasn't started with a "@" or "("
	CMP	#'),R5			;IF IT ENDS WITH ONE THEN IT
	BEQ	110$			;  COULD BE AM.N OR AM.NY
	CMP	#',,R5			;IF IT ENDS WITH A COMMA THEN
	BEQ	120$			;  IT BETTER BE AM.NX
105$:	ERROR	Q			;ELSE IT PURE TRASH
	BR	65$			;  AND GIVE 'EM A COUPLA BYTES OF 0'S

110$:	GETNB				;SKIP THE ")"
	CMP	#',,R5			;is there a comma after it?
	beq	115$			;yep, there's more to do then
	mov	#am.n,r0		;nope, its just a simple (arg)
	br	70$

115$:	CALL	GETAMS			;GET THE ADDRESS MODE SYMBOL
	dec	r2			;assume its Y
	CMP	R0,#<^RY  >		;HAS TO BE A (xxx),Y in this syntax
	BEQ	ALTNDX			;IT IS, SUCCESS
	BR	105$			;ITS TRASH

120$:	CALL	GETAMS			;GET THE ADDRESS MODE SYMBOL
	CMP	#'),R5			;DOES IT CLOSE CORRECTLY?
	BNE	105$			;NOPE, GIVE 'EM AN ERROR
	getnb				;yep, eat it
	clr	r2			;can only be x passed this point
	BR	ALTNDX			;YEP, ITS OK THEN

150$:	CMP	#',,R5			;IS THE NEXT THING A COMMA?
	BNE	ALTNDX			;NOPE, ASSUME A, MODE
	CALL	GETAMS			;GET THE AM SYMBOL	
	clr	r2			;assume its "X"
	CMP	R0,#<^RX  >		;TRUE?
	BEQ	ALTNDX			;YEP
	inc	r2			;else change to "Y"
	CMP	R0,#<^RY  >		;TRUE?
	BEQ	ALTNDX			;YEP
	BR	105$			;DON'T KNOW WHAT THE HELL IT IS
	.DSABL  LSB

GETAMS:	MOV	#SYMBOL+2,R1		;POINT TO SYMBOL SPACE
	MOV	(R1),-(SP)		;SAVE THE SYMBOL
	MOV	-(R1),-(SP)
	GSARG				;eat the "," and get the next symbol
	MOV	(R1),R0			;GET THE SYMBOL
	MOV	(SP)+,(R1)+		;RESTORE THE SYMBOL
	MOV	(SP)+,(R1)
	RETURN

NDXTBL:	.WORD	AM.ZX,AM.NX,AM.AX,0
	.WORD	AM.ZY,AM.NY,AM.AY,0
	.WORD	AM.Z,0,AM.A,0,0,0,0,0
	.END
