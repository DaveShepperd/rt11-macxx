	.TITLE	EXPRS	Expression processing
	.IDENT	/V04.02/
	.SBTTL	MAIN EXPRESSION PROCESSING
;+
; **-GLBTRM-GLOBAL TERM
; **-GLBEXP-GLOBAL EXPRESSION
; **-RELTRM-RELATIVE TERM
; **-RELEXP-RELATIVE EXPRESSION
; **-RELTST-RELATIVE TEST
; **-ABSTRM-ABSOLUTE TERM
; **-ABSEXP-ABSOLUTE EXPRESSION
; **-ABSTST-ABSOLUTE TEST
; **-ABSERF-SET ADDRESS ERROR FLAG
;-

	PURE	PUREI		;++017
GTRMI:	CALL	TERMI		;++024 INTERNAL ENTRY TO GET GLOBAL TERM
	CALL	SETXPR		;++024 RESTORE EXPRESSION MODE REGISTERS
	TST	R0		;++024 TEST SUCCESS/FAIL
	BR	GTRMCK		;++024 BRANCH INTO COMMON CODE

GLBTRM::TERM			;GLOBAL TERM
GTRMCK:				;++024 REF LABEL TO VALIDATE TERM
	BEQ	ABSERR
	BR	GEXPXT

GLBEXP::EXPR			;GLOBAL EXPRESSION
GEXPCK:				;++023 INTERNAL ENTRY TO VALIDATE EXPR
	BEQ	ABSERR
	BIT	#CPXFLG,FLAGS	;++001 IS EXPRESSION COMPLEX?
	BEQ	GEXPXT		;++001 NO, JUST LEAVE
	CMP	#RLDLEN-2,CPXSTL ;++001 YES, IS THE COMPLEX STRING TOO LONG...
				;++001 ... FOR A SINGLE RLD RECORD?
	BLT	ABSERR		;++001 YES, FLAG EXPRESSION IN ERROR
	BR	GEXPXT

RELTRM::GLBTRM			;RELATIVE TERM
	BR	RELTST

RELEXP::GLBEXP			;RELATIVE EXPRESSION
RELTST::BITB	#CPXFLG!GLBFLG,FLAGS	;++001 EXPR CAN'T BE COMPLEX OR GLOBAL
	BEQ	ABSERX
	BR	ABSERR

ABSTRM::GLBTRM			;ABSOLUTE TERM
	BR	ABSTST

ABSEXP::GLBEXP			;ABSOLUTE EXPRESSION
ABSTST::BITB	#CPXFLG!GLBFLG!RELFLG,FLAGS ;++001 EXPR MUST BE ABSOLUTE
	BEQ	ABSERX
ABSERR::CLR	MODE		;
	CLR	RELLVL

ABSERF:	ERROR	A
ABSERX:	.IF NDF	MAC8K		;++030 CODHD $EXPRS ARE IN THE SAME REGION
	.IFF
	CALL	ZAPCPX		;++001 CLEAR CPXROL & INIT STRING LENGTH
	.IFT
	MOV #CPXLST,R0
	JSR PC,ZAP
	MOV #<1*2+1>,CPXSTL
	.ENDC			;++030
GEXPXT:	MOV	VALUE,R0	;RETURN WITH VALUE IN R0
	RETURN

ABXTST:	BITB	#RELFLG,FLAGS	;++019 IS EXPRESSION RELOCATABLE?
	BNE	SETCPX		;++019 YES, ABSOLUTE TEST FAILS
REXTST:	BITB	#GLBFLG!CPXFLG,FLAGS ;++001 IS EXPR GLOBAL OR COMPLEX?
	BEQ	CPXRTN		;++001 YES, CONTINUE EVALUATING IT
SETCPX:	BISB	#CPXFLG,FLAGS	;++001 SET COMPLEX RELOCATION EXPRESSION
CPXRTN:	RETURN			;++001

; **-EXPR-EXPRESSION EVALUATION

EXPR::	SAVREG			;SAVE REGISTERS
.IF ne,MACXX&<..m69!.6502>	; MAC69 >>>>>>>>>>>>>>>>>>>>>>
	CLR	EXPFGS		;SAVE PS1/REG FLAGS HERE
.ENDC			; MAC69 <<<<<<<<<<<<<<<<<<<<<<
EXPI:	CALL	TERMI		;++023 GET FIRST TERM
	TST	R0		;++023 TEST RESULT
	BEQ	5$		;EXIT IF NULL
.IF ne,MACXX&.pdp11		;MACRO >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	CLR	-(SP)		;NON-NULL, SET REGISTER FLAG STORAGE
.IFTF			;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1$:	SETXPR			;SET EXPRESSION REGISTERS
.IFT			;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	BIS	(R3),(SP)	;SAVE REGISTER FLAG
.IFTF			;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	CHSCAN	BOPTBL		;SCAN THE BINARY OPERATOR TABLE
	BEQ	2$		;  BRANCH IF NOT FOUND
	CALL	10$		;FOUND, CALL HANDLER
	BR	1$		;TEST FOR MORE

.IFTF			;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
2$:
.IFT			;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	BIC	#-1-REGFLG,(SP)	;MASK ALL BUT REGISTER FLAG
	BEQ	6$		;BRANCH IF NOT REGISTER
	BIT	#177770,(R4)	;IN BOUNDS?
	BNE	7$		;  NO, ERROR
.IFTF			;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
6$:	ASR	RELLVL		;TEST RELOCATON LEVEL
	BNE	3$		;BRANCH IF NOT 0 OR 1
.IFT			;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	BCC	4$		;BRANCH IF 0
	BIT	#REGFLG,(SP)	;RELOCATABLE, TEST REGISTER FLAG
	BEQ	4$		;BRANCH IF NOT SET
7$:	ERROR	R		;REL AND REG, ERROR
	CLR	(SP)		;CLEAR REGISTER BIT
.IFTF			;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	BR	4$
3$:	BISB	#CPXFLG,(R3)	;++001 SET COMPLEX RELOCATION EXPRESSION
4$:
.IFT			;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	BIS	(SP)+,(R3)	;MERGE REGISTER BIT
.ENDC			; MACRO <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	SETNZ	R0		;SET TRUE
5$:	RETURN

10$:	MOV	#STXOPC,-(SP)	;++001 RETURN THRU COMPLEX OPCODER ROUTINE
	MOV	R0,-(SP)	;++001 STACK OPERATOR ROUTINE ADDRESS
	MOV	(R1)+,-(SP)	;STACK SYMBOL
	MOV	(R1)+,-(SP)
	MOV	(R1)+,-(SP)	;  MODE,
	MOV	(R1)+,-(SP)	;  VALUE,
	MOV	(R1)+,-(SP)	;  AND REL LEVEL
	CALL	GTRMI		;++024 GET NEXT TERM
	MOV	#EXPBAK+10.,R3	;++024 POINT TO EXPRESSION SCRATCH AREA
	MOV	(SP)+,-(R3)	;++024 UNSTACK PREVIOUS RELOCATION LEVEL
	MOV	(SP)+,-(R3)	;++024 		VALUE,
	MOV	R3,R2		;++024 LEAVE R2 POINTING TO PREVIOUS VALUE
	MOV	(SP)+,-(R3)	;++024 		MODE (FLAG & PSECT)
	MOV	(SP)+,-(R3)	;++024		AND SYMBOL.
	MOV	(SP)+,-(R3)	;++024
	CMPB	-(R2),-(R4)	;++019 ARE PSECT'S THE SAME?
	BEQ	100$		;++019 YES, PSECT TEST SUCCESS
	TSTB	(R2)		;++019 ELSE, IS FIRST VALUE A CONSTANT?
	BEQ	100$		;++019 YES, PSECT TEST SUCCESS
	TSTB	(R4)		;++019 ELSE, IS SECOND VALUE A CONSTANT?
	BEQ	100$		;++019 YES, PSECT TEST SUCCESS
	CALL	SETCPX		;++019 ELSE, EXPRESSION WILL BE COMPLEX

100$:	CMPB	(R2)+,(R4)+	;++019 RESTORE REGISTERS
	ASR	(SP)		;IS OPERATOR FOR ABSOLUTE VALUES ONLY?
	BCS	12$		;  NO
	BIS	-(R2),-(R4)	;MERGE ATTRIBUTES AND PSECT NUMBERS
	CALL	ABXTST		;++001 COMPLEX IF BOTH NOT ABSOLUTE
	CMP	(R2)+,(R4)+	;RESTORE REGISTERS
12$:	ASL	(SP)		;RESTORE DISPATCH ADDRESS
	JMP	@(SP)+		;DISPATCH TO BINARY OPERATOR FUNCTION

	PURE	IMPLIN
EXPBAK:	.BLKW	5
ERRSTK:	.BLKW	1
EXPFGS::.BLKW	1

	PURE	DPURE		;++017
BOPTBL:				;BINARY OP TABLE
	GCHTBL	CH.ADD,	BOPADD+1; "+" ADD
	GCHTBL	CH.SUB,	BOPSUB+1; "-" SUB
	GCHTBL	CH.MUL,	BOPMUL	; "*" MUL
	GCHTBL	CH.DIV,	BOPDIV	; "/" DIV
	GCHTBL	CH.AND,	BOPAND	; "&" AND
	GCHTBL	CH.IOR,	BOPIOR	; "!" OR
	GCHTBL	CH.QM,	BOPXOR	; "?" XOR
	gchtbl	ch.bsl,	bopmod	; "\" MODulo
	gchtbl	ch.ocrl,bopshl	; "{" shift left
	gchtbl	ch.ccrl,bopshr	; "}" shift right
	.WORD	0
	PURE	PUREI		;++017

BOPSUB:	CALL	REXTST		;++001 TEST FOR COMPLEX EXPRESSION
	NEG	(R4)		; -, NEGATE VALUE
	NEG	RELLVL		;  AND RELLVL
	MOV	#CPXSUB*400!CPXOPC,R0 ;++001 SET COMPLEX OPCODE FOR SUB
	BR	ADDX		;++001 BRANCH INTO COMMON CODE

BOPADD:	MOV	#CPXADD*400!CPXOPC,R0 ;++001 SET COMPLEX OPCODE FOR ADD
ADDX:	ADD	(R2)+,(R4)+	;++001 + ADD VALUES
	ADD	(R2),(R4)	;  AND RELOCATION LEVELS
	CMP	-(R2),-(R4)	;POINT BACK TO VALUES
	BIT	#177400!GLBFLG!CPXFLG,-(R2)  ;++019 FIRST VALUE CONSTANT?
	BEQ	3$		;++019 YES, CONSIDER ADDITION DONE
	BIT	#177400!GLBFLG!CPXFLG,-(R4)  ;++019 SECOND VALUE CONSTANT?
	BEQ	4$		;++019 YES, USE ATTRIBUTES OF FIRST VALUE
	BISB	(R2),(R4)	;++019 NO CONSTANTS--MERGE ATTRIBUTES
	CALL	REXTST		;++019 COMPLEX IF ANY GLOBALS
	TST	RELLVL		;CHECK RELOCATION LEVEL
	BNE	3$
	BITB	#CPXFLG!GLBFLG,(R4)  ;++019 IS EXPR GLOBAL OR COMPLEX?
	BNE	3$		;++019 YES, LEAVE
	BIC	#177400!RELFLG,(R4)  ;SET ATTRIBUTES FOR CONSTANT
3$:	RETURN

4$:	MOV	(R3)+,(R1)+	;++024 TRANSFER PREVIOUS SYMBOL NAME
	MOV	(R3)+,(R1)+	;++024 
	BIS	(R3)+,(R1)+	;++024 AND MERGE PREVIOUS ATTRIBUTES
	RETURN

BOPAND:	COM	(R2)
	BIC	(R2),(R4)
	MOV	#CPXAND*400!CPXOPC,R0 ;++001 SET COMPLEX OPCODE FOR AND
	RETURN

BOPIOR:	BIS	(R2),(R4)
	MOV	#CPXIOR*400!CPXOPC,R0 ;++001 SET COMPLEX OPCODE FOR OR
	RETURN

BOPXOR:	MOV	(R2),-(SP)
	BIC	(R4),(SP)
	BIC	(R2),(R4)
	BIS	(SP)+,(R4)
	MOV	#CPXXOR*400!CPXOPC,R0 ;++001 SET COMPLEX OPCODE FOR XOR
	RETURN

BOPMUL:	MOV	(R2),R0		;FETCH FIRST ARGUMENT
	MOV	#CPXMUL*400!CPXOPC,-(SP) ;++001 STK COMPLEX OPCODE FOR MULT
	MOV	R0,-(SP)	;SAVE A COPY
	BPL	1$		;POSITIVE?
	NEG	R0		;  NO, MAKE IT SO
1$:	MOV	(R4),R3		;SET SECOND ARG
	BPL	2$		;BRANCH IF POSITIVE
	NEG	R3		;NEGATIVE, MAKE IT +
	COM	(SP)		;TOGGLE RESULT SIGN
2$:	MUL	R3,R0		;MULTIPLY
	MOV	R1,R0		;SET FOR EXIT
	BR	BOPDVX		;EXIT THROUGH DIVIDE

bopmod:	mov	edmask,-(sp)	;save current flags
	bic	#ed.usd,edmask	;say we're to do unsigned divides only
	call	bopdiv		;do a division
	mov	r1,(r4)		;pass back real value
	mov	(sp)+,edmask	;restore enable flags
	mov	#cpxmod*400!cpxopc,r0	;assume signed mod
	return

BOPDIV:	MOV	(R2),R1		;SET DIVIDEND
	MOV	#CPXUSD*400!CPXOPC,-(SP) ;++001 STK COMPLEX OPCODE FOR DIV
	CLR	-(SP)		;START WITH A + RESULT BEFORE CORRECTION
	CLR	-(SP)		;START WITH A + RESULT AFTER CORRECTION
	MOV	(R4),R3		;GET DIVISOR
	BPL	10$		;PLUS, OK SO FAR
	BIT	#ED.USD,EDMASK	;UNSIGNED?
	BNE	5$		;NOPE, DO NORMAL STUFF
	CMP	(SP)+,(SP)+	;PURGE THE STACK
	CLR	R0		;ASSUME ANSWER IS 0
	cmp	R3,R1		;DIVIDE BY NEGATIVE DIVISOR
	BHI	2$		;THE ANSWER IS 0
	sub	r3,r1		;compute modulo for MOD "\"
	INC	R0		;ELSE THE ANSWER IS 1
2$:	BR	BOPDSV

5$:	MOV	R3,2(SP)	;SAVE THE DIVISOR'S SIGN AND...
	NEG	R3		;...MAKE IT PLUS (ALWAYS DO AN UNSIGNED DIVIDE)
	MOV	R3,(SP)		;SAVE CORRECTED SIGN
10$:	BIT	#ED.USD,EDMASK	;UNSIGNED DIVIDE REQUESTED?
	BEQ	20$		;YES, DISREGARD THE SIGN OF DIVIDEND
	MOV	#CPXDIV*400!CPXOPC,4(SP) ;++001 STK COMPLEX OPCODE FOR DIV
	TST	R1		;CHECK THE DIVIDEND SIGN
	BPL	20$		;OK AS IS
	NEG	R1
	MOV	(SP),R0
	XOR	R1,R0
	MOV	R0,(SP)		;ADJUST THE CORRECTED SIGN
	COM	2(SP)		;ADJUST THE FINAL SIGN
20$:	CLR	R0		;EXTEND IT
	DIV	R3,R0		;DIVIDE IT
	TST	(SP)+		;ANY CORRECTIONS?
	BPL	BOPDVX		;NOPE
	NEG	R0		;YES, ADJUST RESULT
	neg	r1		;adjust remainder for modulo too

BOPDVX:	TST	(SP)+		;TEST RESULT
	BPL	BOPDSV		;  OK AS IS
	NEG	R0		;NO, NEGATE IT
	neg	r1		;adjust remainder for modulo too
BOPDSV:	MOV	R0,(R4)		;SET RESULT
	MOV	(SP)+,R0	;++001 SET THE COMPLEX OPCODE
	RETURN

bopshr:	mov	(pc)+,-(sp)	;this is code crashing
	ror	r1		;  init the loop instruction
	mov	#cpxshr*400!cpxopc,r0	;init the cmplx instruction
	br	bopshx		;and go to common code

bopshl:	mov	(pc)+,-(sp)	;watch this space!!!!!
	rol	r1		;  this is really code crashing
	mov	#cpxshl*400!cpxopc,r0	;indicate to the cmplx stuff

bopshx:	mov	(sp)+,20$	;crash our instruction at 20$
	mov	(r2),r1		;get the argument to shift
	mov	(r4),r3		;get the shift count
	bgt	10$		;its gotta shift some
	beq	30$		;nuthin to do
	neg	r3		;fix the shift count
	bmi	25$		;its too big, give 'em a 0
	xor	#100,20$	;change the ROL/ROR instruction (code crash)
10$:	cmp	r3,#16.		;shifting more than 16 bits?
	bge	25$		;yep, just give 'em a 0
15$:	clc
20$:	rol	r1		;shift it
	sob	r3,15$		;until all shifted
	br	30$

25$:	clr	r1		;force a 0
30$:	mov	r1,(r4)		;set the value
	return			;and return

	.SBTTL	TERM EVALUATOR

TERM:	SAVREG			;SAVE REGISTERS
TERMI:				;++023 REF LABEL FOR INTERNAL ENTRY
	SETXPR			;  AND SET "EXPRESSION" TYPE
	CLR	(R3)		;CLEAR MODE
	CLR	(R4)		;  AND VALUE
	CALL	TERM10		;PROCESS TERM
	.IF eq,MACXX&.pdp11
	BIC	#LBLFLG!MDFFLG,(R3)	;CLEAR EXTRA STUFF
	.IFF
	BIC	#DEFFLG!LBLFLG!MDFFLG,(R3)	;CLEAR EXTRANEOUS
	.ENDC
	CLR	RELLVL		;ASSUME ABSOLUTE
	BIT	#RELFLG,(R3)	;TRUE?
	BEQ	1$
	INC	RELLVL		;  NO, RELOCATABLE
1$:	INC	EXPFLG		;MARK AS EXPRESSION
	JMP	SETNB		;EXIT WITH NON-BLANK AND R0 SET

TERM10:	GETSYM			;TRY FOR A SYMBOL
	BEQ	TERM20		;BRANCH IF NOT A SYMBOL
	CMP	SYMBOL,#^R.	;LOCATION COUNTER?
	BEQ	14$		;  YES, TREAT SPECIAL
	SSRCH			;SEARCH THE SYMBOL TABLE
	BEQ	16$		;BRANCH IF NOT FOUND
.IF ne,MACXX&<..m69!.6502>	; IF MAC69 THEN  >>>>>>>>>>>>>>>>>>>>>>
	BISB	(R3),EXPFGS	;SAVE REG/FWD FLAGS
	mov	(r3),r1		;save flags
	BICB	#FWDFLG,(R3)	;DROP THE PASS 1 FLAG
.ENDC			;     MAC69  <<<<<<<<<<<<<<<<<<<<<<<<<<
	BIT	#MDFFLG,(R3)	;MULTIPLY DEFINED?
	BEQ	11$		;  NO
	ERROR	D		;  YES
11$:	BIT	#DEFFLG,(R3)	;DEFINED?
	BNE	12$		;  YES
.IF ne,MACXX&<..m69!.6502>	; IF MAC69 THEN  >>>>>>>>>>>>>>>>>>>>>>
	mov	(r3),-(sp)	;save the current flags
	xor	#fwdflg,r1	;flip the fwdflag back to its original state
	mov	r1,(r3)		;restore the old flags
.iftf
	inc	(r4)		;count the reference
	insert			;and update it
.ift
	mov	(sp)+,(r3)	;fix the flags again
.endc
	clr	(r4)		;but use a 0 for calculations
	BIT	#GLBFLG,(R3)	;NO, GLOBAL?
	BNE	CRFTRM		;  YES
	ERROR	U		;NO, UNDEFINED ERROR
12$:	.if ne,MACXX&..m69
	BIC	#GLBFLG!BSEFLG,(R3) ;DEFINED SYMBOLS DON'T GET BASE ATTRIBUTES
.IFF
	BIC	#GLBFLG,(R3)	;CLEAR INTERNAL GLOBAL FLAG
.ENDC
	BR	CRFTRM		;FINISH UP TERM PROCESSING

14$:	MOV	#CLCNAM,R1	;DOT, MOVE TO WORKING AREA
	MOV	#SYMBOL,R2
	CALL	XMIT4
	BICB	#^C<RELFLG>,(R3) ;CLEAR ALL BUT REL FLAG
	BR	TERM28

16$:
.IF ne,MACXX&.pdp11		;MACXX = MACRO
	OSRCH			;NOT USER DEFINED, PERHAPS AN OP-CODE?
	TST	(R3)		;OP CODE?
	BMI	17$		;YES
	SSRCH			;SET SEARCH POINTERS
.IF DF	RSX11D
	BIS	#DFGFLG!GLBFLG,(R3)
	BIT	#ED.GBL,EDMASK
	BEQ	20$
	BIC	#DFGFLG!GLBFLG,(R3)
.ENDC
.ENDC			;MACXX = MACRO
	ERROR	U
	inc 	(r4)		;count the reference
	INSERT			;NOT IN TABLE, INSERT AS UNDEFINED
	clr	(r4)		;but use a 0 for calculations
17$:	CLR	(R3)		;BE SURE MODE IS ZERO
CRFTRM:
.IF NDF	XCREF
	CRFREF			;CREF IT
.ENDC
	BR	TERM28

TERM20:
	MOV	CRADIX,R2	;ASSUME NUMBER, CURRENT RADIX
	MOV	ERRBTS,ERRSTK	;SAVE ANY EXISTING ERROR BITS
	BIC	#^C<ERR.T>,ERRSTK	;CLEAR ALL EXCEPT ERROR T
21$:	CVTNUM			;CONVERT
	BEQ	TERM30		;  NOPE, MISSED AGAIN
	BPL	22$		;NUMBER, ANY OVERFLOW?
	ERROR	T		;  YES, FLAG IT
22$:	CMP	R5,#CH.DOT	;NUMBER, DECIMAL?
	BEQ	24$		;  YES
	.IF NDF	XEDLSB
	CMP	R5,#CH.DOL	;NO, LOCAL SYMBOL?
	BEQ	24$		;  YES
	.ENDC
	TSTB	R0		;NO, ANY NUMBERS OUT OF RANGE?
	BEQ	TERM28		;  NO
	ERROR	N		;YES, FLAG IT
	CMP	R2,#16.		;HEX?
	BEQ	25$		;YEP. CAN'T DO ANYMORE
	CMP	R2,#10.		;DECIMAL?
	BNE	23$		;TRY AGAIN WITH DECIMAL
	MOV	#16.,R2		;ELSE TRY WITH HEX
	BR	26$

24$:	CMP	R2,#10.		;"." OR "$", WERE WE DECIMAL?
	BEQ	25$		;  YES
23$:	MOV	#10.,R2		;  TRY AGAIN WITH DECIMAL RADIX
26$:	SETSYM			;RESET POINTERS
	BIC	#ERR.T,ERRBTS	;RESET ANY 'T' ERRORS
	BIS	ERRSTK,ERRBTS	;UNLESS THERE WERE SOME SET AT ENTRY
	BR	21$

25$:	CMP	R5,#CH.DOT	;DECIMAL?
	BEQ	TERM27		;  YES
.IF NDF	XEDLSB
	LSRCH			;NO, LOCAL SYMBOL
.IF ne,MACXX&<..m69!.6502>	; IF MAC69 THEN  >>>>>>>>>>>>>>>>>>>>>>
	BISB	(R3),EXPFGS	;SAVE REG/PS1 FLAGS
	BICB	#FWDFLG,(R3)	;DROP THE PASS 1 FLAG
.ENDC			;     MAC69  <<<<<<<<<<<<<<<<<<<<<<<<<<
	TST	R0		;FOUND?
	BNE	TERM27		;YEP.
.ENDC

TERM26:	ERROR	U		;  NO, FLAG AS UNDEFINED
TERM27:	GETCHR			;BYPASS DOT OR DOLLAR
TERM28:	ADD	#2,CPXSTL	;++001 UPDATE COMPLEX STRING LENGTH FOR CONST
	MOV	(R3),-(SP)	;++001 SAVE FLAGS/SECTOR WORD
	BICB	#^C<RELFLG!GLBFLG>,(R3) ;++001 SAVE ONLY GLOBAL/REL FLAGS
	BEQ	2$		;++001 BRANCH IF TERM IS ABSOLUTE
	BITB	#GLBFLG,(R3)	;++001 IS THE TERM GLOBAL?
	BEQ	1$		;++001 SKIP IF NOT
	INC	CPXSTL		;++001 INCR COMPLEX STRING LENGTH BY 2 MORE...
1$:	INC	CPXSTL		;++001 ... FOR GLOBAL & 1 MORE FOR RELATIVE
2$:	CALL	APPCPX		;++001 PUT ELEMENT IN COMPLEX ROLL
	MOV	(SP)+,(R3)	;++001 RESTORE FLAGS/SECTOR WORD
ALT28:	SETNB			;++001 RETURN POINTING TO NON-BLANK
	SETNZ	R0		;FLAG AS FOUND
TERM29:	RETURN

TERM30:	CHSCAN	UOPTBL		;SCAN UNARY OPERATOR TABLE
	BEQ	TERM29		;  NOT THERE
	CLR	R2		;CLEAR FOR FUTURE USE
	CALL	(R0)		;FOUND, GO AND PROCESS
	BR	ALT28		;++001 EXIT TRUE VIA ALTERNATE EXIT

	PURE	DPURE		;++017
UOPTBL:
	GCHTBL	CH.ADD,	GTRMI	; "+" ++024
	GCHTBL	CH.SUB,	TERM42	; "-"
	GCHTBL	CH.QTM,	TERM44	; """
	GCHTBL	CH.XCL,	TERM45	; "'"
	GCHTBL	CH.PCT,	TERM46	; "%"
	GCHTBL	CH.LAB,	TERM47	; "<"
	GCHTBL	CH.UAR,	TERM50	; "^"
	.WORD	0
	PURE	PUREI		;++017

TERM42:	MOV	#1,-(SP)	;++001 INDICATE NEGATE
	BR	COMTRX		;++001 USE COMMON CODE TO PROCESS

TERM44:	INC	R2		; """, MARK IT
TERM45:	MOV	R4,R1		; "'", SET TEMP STORE REGISTER
	SETSYM			;POINT BACK TO OPERATOR
1$:	GETCHR			;GET THE NEXT CHARACTER
	BEQ	TERM48		;ERROR IF EOL
	.IF NDF	XEDLC
	.GLOBL	CHRPNT
	MOVB	@CHRPNT,(R1)	;STORE ABSOLUTE CHAR
	BICB	#200,(R1)+	;CLEAR POSSIBLE SIGN BIT AND INDEX
	.IFF
	MOVB	R5,(R1)+
	.ENDC
	DEC	R2		;ANOTHER CHARACTER
	BEQ	1$		;  YES
	BR	TERM27		;BYPASS LAST CHAR

TERM46:	ABSTRM			;REGISTER EXPRESSION
	BIS	#REGFLG,(R3)	;FLAG IT
	RETURN

TERM47:				;++023 "<"
	CALL	EXPI		;++023 EVALUATE EXPRESSION
	CALL	GEXPCK		;++023 VALIDATE IT
	CMP	R5,#CH.RAB	;">"?
	BNE	TERM48		;++001 NO, REPORT ERROR
	GETCHR			;++001 YES, BYPASS IT
	BR	ALT28		;++001 EXIT

TERM48:	JMP	ABSERF		;ERROR, FLAG IT
	.PAGE
TERM50:	CHSCAN	UARTBL		;"^"-SCAN ON NEXT CHARACTER
	BEQ	TERM48		;  INVALID, ERROR
	JMP	(R0)		;CALL ROUTINE

	PURE	DPURE		;++017
UARTBL:				;UP ARROW TABLE
	GCHTBL	LET.C,	TERM51	;  ^C = COMPLIMENT
	GCHTBL	LET.D,	TERM52	;  ^D = DECIMAL RADIX
	GCHTBL	LET.O,	TERM53	;  ^O = OCTAL RADIX
	GCHTBL	LET.B	TERM54	;  ^B = BINARY RADIX
	GCHTBL	LET.H,	TERM57	;  ^H = HEX RADIX
	GCHTBL	LET.X,	TERM57	;  ^X = HEX RADIX
	.IF NDF	XFLTG
	GCHTBL	LET.F,	TERM55	;  ^F = FLOATING
	.ENDC
	GCHTBL	'R,	TERM56	;  ^R = RAD50
	gchtbl	ch.tld,	term58	;  ^~ = swap bytes
	gchtbl	ch.uar,	term59	;  ^^ = high byte
	gchtbl	'V,	term60	;  ^V = low byte
	.WORD	0

	PURE	PUREI		;++017

TERM51:	clr	-(sp)		;++024 signal to compliment
COMTRX:	CALL	GTRMI		;++024 GET GLOBAL TERM
	CALL	REXTST		;++001 IF TERM IS GLOBAL, SET COMPLEX
	COM	(R4)		;++001 COMPLEMENT VALUE
	ADD	(SP),(R4)	;++001 MAKE IT NEGATE IF 1 ON STACK
	NEG	RELLVL		;++001 NEGATE THE RELOCATION LEVEL
	mov	#cpxopc*400!cpxcom,r0 ;+001 get complex command backwards
	sub	(SP)+,R0	;++001 compute complex command
	swab	r0		;++001 fix the bytes
	BR	STXOPC		;++001 STORE OPCODE IN CPXROL

term58:	call	gtrmi		;get global term
	call	rextst		;set complex if any globals/rels/cmplxs
	swab	(r4)		;switch bytes around
	mov	#cpxswb*400!cpxopc,r0 ;get the complex command
	br	stxopc		;and stuff it

term59:	call	gtrmi		;get global term
	call	rextst		;set complex if necessary
	clrb	(r4)		;make a hole in the low byte
	swab	(r4)		;put the high byte there
	mov	#cpxhib*400!cpxopc,r0 ;set the complex command
	br	stxopc

term60:	call	gtrmi		;get global term
	call	rextst		;set complex if necessary
	clrb	1(r4)		;zap the upper byte
	mov	#cpxlob*400!cpxopc,r0 ;set the complex command
	br	stxopc

TERM57:	ADD	#6.,R2		;HEX
TERM52:	ADD	#2.,R2		;DECIMAL
TERM53:	ADD	#6.,R2		;OCTAL
TERM54:	ADD	#2.,R2		;BINARY
	MOV	CRADIX,-(SP)	;STACK CURRENT RADIX
	MOV	R2,CRADIX	;REPLACE WITH LOCAL
	CALL	GTRMI		;++024 EVALUATE TERM
	MOV	(SP)+,CRADIX	;RESTORE RADIX
	RETURN

	.IF NDF	XFLTG
TERM55:	CALL	FLTG1W		;++018 PROCESS ONE WORD FLOATING
	BEQ	TERM48		;ERROR IF NULL
	RETURN
	.ENDC

TERM56:				;++022 ^R
	CALL	SETSYM		;++022 BACK UP CHAR PTR TO THE "R"
	MOV	#64,R2		;++022 SET CONTROL MASK IN R2
10$:	CALL	GETR50		;++022 FETCH A RADIX-50 CHAR
	BMI	40$		;++ IF MI, NON-RAD50 CHAR ENCOUNTERED
	TST	R2		;++022 CHECK CONTROL MASK
	BEQ	10$		;++022 IF EQ SKIP CHARS PAST 3
20$:	ASR	R2		;++022 SHIFT CONTROL MASK
	BCS	30$		;++022 IF CS PROPER RAD50 POWER REACHED
	CALL	MULR50		;++022 ELSE, MULTIPLY BY 50
	BR	20$		;++022 REPEAT MULTIPLY LOOP
30$:	ADD	R0,(R4)		;++022 ADD RESULT TO ACCUMULATED VALUE
	BR	10$		;++022 REPEAT FOR 3 RADIX-50 CHARACTERS
40$:	JMP	TERM28

STXOPC:	MOV	#FLAGS,R3	;++001 POINT R3 TO FLAGS
	MOV	(R3),-(SP)	;++001 SAVE FLAGS/SECTOR WORD
	MOV	R0,(R3)		;++001 SET OPCODE FLAG & NUMBER
	CALL	APPCPX		;++001 PUT ELEMENT IN CPXROL
	MOV	(SP)+,(R3)	;++001 RESTORE FLAGS/SECTOR WORD
	RETURN			;++001

APPCPX:	INC	CPXSTL		;++001 INCR COMPLEX STRING LENGTH FOR OPCODE
	APPEND	CPXROL		;++021 APPEND COMPLEX EXPRS ELE TO LIST
	RETURN			;++001

	.END
