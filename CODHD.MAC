	.TITLE	CODHD	Code Roll processing
	.IDENT	/08.02/
	.SBTTL	CODE ROLL PROCESSING

;+
; STCODE
; STORE CODE IN CODE ROLL FOR LATER OUTPUT AND LISTING
; ENTER WITH 4 WORD BLOCK AT "SYMBOL" SETUP. ANY COMPLEX GLOBAL EXPRESSIONS
; ARE APPEDNED TO THE CODE ROLL AT THIS POINT.
;-

	PURE	PUREI
STCODE::TST	PASS		;IS THIS FIRST PASS?
	BEQ	4$		;YES, IGNORE COMPLEX ROLL
	TST	OBJPNT		;OBJECT CODE NEEDED?
	BEQ	4$		;NO, JUST STORE CODE
	SAVREG			;SAVE REGISTERS
	SETXPR			;SET EXPRESSION REGISTERS
	BITB	#CPXFLG,(R3)	;COMPLEX RELOCATION EXPRESSION?
	BEQ	4$		;NO, BRANCH TO APPEND CODE ONLY
	MOV	(R4),-(SP)	;SAVE VALUE--IT REVEALS MODE
	MOVB	CPXROL+ROLSIZ+1,(R4)+  ;PUT # OF CPX ELEMENTS IN VALUE
	MOVB	CPXSTL,(R4)+	;PUT SIZE OF COMPLEX STRING IN VALUE
	APPEND	CODROL		;APPEND EXPR VALUE TO CODE ROLL
	CLR	ROLUPD		;INIT POINTER TO START OF LIST
2$:	NEXT	CPXROL		;FETCH NEXT COMPLEX EXPR ELEMENT
	BEQ	3$		;BRANCH IF NONE LEFT
	MOV	ROLUPD,-(SP)	;SAVE LIST POINTER
	APPEND	CODROL		;APPEND ELEMENT TO CODE ROLL
	MOV	(SP)+,ROLUPD	;RESTORE LIST POINTER
	BR	2$		;BRANCH TO GET NEXT CPX ELEMENT
3$:	MOV	#<CPXOPC*400!CPXSTO>,(R3) ;FORM CPX STORE OPCODE (BKWDS)
	ADD	(SP)+,(R3)	;MAKE STORE DISPLACED IF 1 ON STACK
	SWAB	(R3)		;STRAIGHTEN OUT THE BYTES
	CLR	-(R4)		;SET COSMETIC VALUE OF ZERO
4$:	APPEND	CODROL		;APPEND IT TO CODROL

ZAPCPX::ZAP	CPXROL		;EMPTY COMPLEX EXPR LIST
	MOV	#<1*2+1>,CPXSTL ;INIT COMPLEX STRING LENGTH
PCR3A:	RETURN			;

	.SAVE
	PURE	XCTLIN
	CALL	ZAPCPX
	.RESTORE

CPXSTL::.WORD	1*2+1		;INIT COMPLEX STRING LENGTH

;+
; PCROLL
; PROCESS GENERATED CODE AT END OF LINE
; CONVERTS ENTRIES IN THE CODE ROLL TO OBJECT FORMAT AND LISTS
; ANY BINARY IF NECESSARY
;-

PCROLL::NEXT	CODROL		;FETCH NEXT ITEM OF GENERATED CODE
	BEQ	PCR3A		;END
	SAVREG
	CLR	R5		;ASSUME BYTE
	CLR	R4
	BISB	SECTOR,R4	;GET THE RLD TYPE
	BMI	1$		;BRANCH IF BYTE
	INC	R5		;  WORD, BUMP TO 1
1$:	TST	PASS		;PASS ONE?
	BEQ	9$		;YES, JUST UPDATE PC
	SETPF0			;LIST COLUMN ZERO
	SETPF1			;SET PRINT FIELD ONE
	ASLB	R4		;BYTE?
	TST	OBJPNT		;ANY OBJECT CODE CALLED FOR?
	BEQ	9$		;NO
	.IF NDF	XEDPNC
	BIT	#ED.PNC,EDMASK	;PUNCH DISABLED?
	BNE	9$		;YES
	.ENDC
	.IF NDF	XREL
	MOV	PCRTBL(R4),R4	;GET PROPER TABLE ENTRY
	CMPB	CLCSEC,OBJSEC	;SECTOR CHANGE?
	BEQ	10$		;  NO
	CALL	EVNRLD		;INSURE EVEN RLD POINTER
	MOV	#4*2,R0
	CALL	TSTRLD		;SOFTEN UP RLD BUFFER
	MOV	#RLDT07,(R2)+	;SET RLD TYPE 7
	MOV	CLCNAM,(R2)+	;  AND NEW SECTOR NAME
	MOV	CLCNAM+2,(R2)+
	MOVB	CLCSEC,OBJSEC
	BR	12$
	.IFTF
9$:	JMP	PCROL2		;
10$:	CMP	CLCLOC,OBJLOC	;DID PC MOVE ON US?
	BEQ	14$		;  NO
	.IFT
	CALL	EVNRLD		;INSURE EVEN RLD POINTER
	MOV	#2*2,R0
	CALL	TSTRLD		;MAKE ROOM
	MOV	#RLDT10,(R2)+
12$:	.IFTF
	MOV	CLCLOC,(R2)	;SET NEW PC
	.IF DF	YPHASE
	SUB	PHAOFF,(R2)
	.ENDC
13$:	CALL	OBJDMP		;DUMP BUFFER
14$:	MOV	OBJPNT,R0	;GET CODE POINTER
	ADD	R5,R0		;COMPUTE NEW END
	SUB	BUFTBL+BINCHN,R0
	CMP	R0,#OBJLEN-1	;ROOM?
	BHI	13$		;  NO
	.IFT
	MOVB	R4,R0		;YES, GET RLD SIZE
	BPL	90$		;IF NEGATIVE, RLD IS COMPLEX
	MOVB	VALUE+1,R0	;GET THE COMPLEX STRING LENGTH
	INCB	R0		;FORCE IT TO BE EVEN
	BICB	#1,R0
90$:				;
	CALL	TSTRLD		;BE SURE WE HAVE ROOM
	.IFTF
	MOV	OBJPNT,R1
	CMP	R1,BUFTBL+BINCHN ;FIRST ITEM?
	BNE	16$		;  NO
	.IFT
	.IF NDF	XEDABS
	BIT	#ED.ABS,EDMASK	;ABS OUTPUT?
	BEQ	15$		;  YES
	.ENDC
	MOV	#BLKT03,(R1)+	;NO, SET BLOCK TYPE
15$:	.IF DF	YPHASE
	MOV	CLCLOC,(R1)	;GET CURRENT PC
	SUB	PHAOFF,(R1)+	;SUBTRACT OUT PHASE OFFSET
	.IFF
	MOV	CLCLOC,(R1)+	;SET NEW PC
	.ENDC
16$:	.IFT
	ASL	R4		;ANY RLD?
	BCC	PCROL1		;  NO
	MOVB	SECTOR,(R2)	;YES, SET CODE
.IF eq,MACXX&.pdp11
	BIT	#ED.M68,EDMASK	;6800 MODE?
	BNE	33$		;NOPE
	BISB	#100,(R2)	;SET 6800 MODE FLAG
.ENDC
33$:	INCB	R2
	MOV	R1,R0
	SUB	BUFTBL+BINCHN,R0 ;COMPUTE INDEX
	MOVB	R0,(R2)+
	TSTB	R4		;IS RLD FOR COMPLEX EXPRESSION?
	BPL	PCROL1		;NO, CONTINUE NORMAL PROCESSING
	MOVB	VALUE,-(SP)	;PUT # OF CPX ELEMENTS ON STACK
GCODX:	NEXT	CODROL		;FETCH NEXT COMPLEX EXPR ELEMENT
	MOVB	FLAGS,R4	;PUT FLAGS BYTE IN R4
	BITB	#CPXOPC,R4	;IS THIS A COMPLEX OP CODE?
	BNE	RELX1		;YES, STORE IT IN RLD
	MOV	R2,R0		;SAVE RLD POINTER--FORM CPX STACK CMD
	MOVB	#CPXGLB,(R2)+	;ASSUME 'STACK GLOBAL' COMMAND
	BITB	#GLBFLG,R4	;IS THIS A GLOBAL SYMBOL?
	BEQ	50$		;NO, TRY RELOCATABLE
	CALL	RLDSYM		;PUT SYMBOL NAME IN RLD
	BR	XMORE		;BRANCH TO GET NEXT ELEMENT
50$:	INCB	(R0)		;'STACK' COMMAND IS RELOC OR CONSTANT
	TSTB	R4		;IS IT CONSTANT?
	BEQ	CONSTX		;YES, BRANCH TO MOVE ITS VALUE
RELX1:	MOVB	SECTOR,(R2)+	;MOVE INTO RLD, SECTOR # IF RELOCATABLE
				;	..., OPCODE # IF OPCODE
	BITB	#RELFLG,R4	;IS IT RELOCATABLE VALUE?
	BEQ	XMORE		;NO, GET NEXT ELEMENT FROM ROLL
	BR	CONS1X		;YES, MOVE ITS OFFSET
CONSTX:	INCB	(R0)		;'STACK' COMMAND IS FOR CONSTANT
CONS1X:	MOVB	VALUE,(R2)+	;MOVE THE VALUE ...
	MOVB	VALUE+1,(R2)+	;... INTO THE RLD
XMORE:	DECB	(SP)		;DECREMENT ELEMENT COUNT
	BPL	GCODX		;IF NON-NEGATIVE, GET NEXT ELEMENT
	BIT	#1,R2		;IS THE POINTER EVEN?
	BEQ	10$		;YES, PROCEED
	MOVB	-1(R2),(R2)+	;MOVE THE LAST CPLX COMMAND UP 1 BYTE
	CLRB	-2(R2)		;AND INSERT A CPLX.NOP COMMAND
10$:	TST	(SP)+		;CLEAN STACK
	CLR	PF1+2		;SET VALUE TO BE PRINTED TO ZERO
	BR	MVOBJ		;BRANCH TO PUT VALUE IN OBJECT RECORD

PCROL1:	ASL	R4		;ANY SYMBOL REQUESTED?
	BCC	21$		;  NO
	MOV	SYMBOL,(R2)+	;YES, COPY SYMBOL INTO RLD RECORD
	MOV	SYMBOL+2,(R2)+
21$:	ASL	R4		;ANY VALUE?
	BCC	22$		;  NO
	MOV	VALUE,R0
.IF eq,MACXX&.pdp11
	BIT	#ED.M68,EDMASK	;6800 MODE?
	BNE	23$		;NOPE
	SWAB	R0		;YES, EXCHANGE H <=> L
.ENDC
23$:	MOV	R0,(R2)+	;MOVE THE VALUE INTO THE RLD
22$:
	.ENDC
MVOBJ:				;
	MOV	VALUE,R0
	TST	R5
	BEQ	29$		;BRANCH IF BYTE INSTRUCTION
.IF eq,MACXX&.pdp11
	BIT	#ED.M68,EDMASK	;6800 MODE?
	BNE	25$		;NOPE, NORMAL STORE
	SWAB	R0
.ENDC
25$:	MOVB	R0,(R1)+	;PUT DATA INTO TXT RECORD...
	SWAB	R0
29$:	MOVB	R0,(R1)+	; ...IN THE APPROPRIATE ORDER
	MOV	R1,OBJPNT

PCROL2:	INC	R5		;MAKE COUNT 1 OR 2
	ADD	R5,CLCLOC	;UPDATE PC
	MOV	CLCLOC,OBJLOC	;SET SEQUENCE BREAK
	SETNZ	R0		;SET TRUE RETURN
PCROL3:	RETURN

RLDSYM:	MOV	#SYMBOL,R3	;PUT SYMBOL ADDR IN R3
	.REPT	4		;PUT 4 BYTES OF SYMBOL IN RLD
	MOVB	(R3)+,(R2)+	;
	.ENDR			;
	RETURN			;

	.IF NDF	XREL

	PURE	DPURE		;
PCRTBL::			;REF LABEL
	.WORD	0		;illegal
	.WORD	120004		;RLDT01 internal relocation (2 w)
	.WORD	140006		;RLDT02 global relocation (3 w)
	.WORD	120004		;RLDT03 internal displaced relocation (2 w)
	.WORD	140006		;RLDT04	global displaced relocation (2 w)
	.WORD	160010		;RLDT05 global additive relocation (4 w)
	.WORD	160010		;RLDT06 global additive displaced rel (4 w)
	.WORD	0		;RLDT07 location counter definition (4 w)
	.WORD	0		;RLDT10 location counter modification (2 w)
	.WORD	100002		;RLDT11 .LIMIT (1 w)
	.WORD	0		;RLDT12 Psect relocation (3 w)
	.WORD	0		;RLDT13 VCTRS/CKSUM type
	.WORD	0		;RLDT14 Psect displaced relocation (3 w)
	.WORD	160010		;RLDT15	Psect additive relocation (4 w)
	.WORD	160010		;RLDT16 Psect additive displaced rel (4 w)
	.WORD	100377		;RLDT17 Complex relocation
	.WORD	120020		;RLDT20 Dpage definition from MAC69
	.ENDC

	PURE	IMPLIN
PCRCNT::.BLKW
	PURE	IMPPAS
	.BLKB
OBJSEC::.BLKB			;OBJECT FILE SECTOR
OBJLOC::.BLKW			;OBJECT FILE LOCATION

	PURE	IMPURE
OBJPNT::.BLKW
RLDPNT::.BLKW

	PURE	PUREI		;

	.IF NDF	XEDPNC
PNCSET::MOVB	#-1,OBJSEC	;FORCE SEQUENCE BREAK
	RETURN
	.ENDC

;+
; **-TSTRLD-TEST RELOCATION BUFFER
; **-OBJDMP-DUMP OBJECT BUFFER
; **-RLDDMP-DUMP RELOCATION BUFFER
;-

TSTRLD::MOV	R0,-(SP)	;SAVE BYTE COUNT
	ADD	RLDPNT,R0
	SUB	BUFTBL+RELCHN,R0
	CMP	R0,#RLDLEN	;ROOM TO STORE?
	BLOS	1$		;  YES
	CALL	OBJDMP		;NO, DUMP CURRENT
1$:	MOV	RLDPNT,R2	;RETURN WITH POINTER IN R2
	ADD	(SP)+,RLDPNT	;UPDATE POINTER
	RETURN

EVNRLD:	BIT	#1,RLDPNT	;IS RLD POINTER ODD?
	BEQ	OBJINX		;NO, JUST RETURN
				;ELSE FALL INTO OBJECT DUMP ROUTINE AND EXIT
OBJDMP::MOV	OBJPNT,@CNTTBL+BINCHN;POINT TO COUNT SLOT
	BEQ	OBJINX		;EXIT IF NOT PRE-SET
	SUB	BUFTBL+BINCHN,@CNTTBL+BINCHN	;COMPUTE ACTUAL COUNT
	BEQ	1$		;  EMPTY, FORGET IT
	$WRITE	BIN		;+;014 ELSE, WRITE OUT OBJECT BUFFER
1$:
	.IF NDF	XREL
	MOV	BUFTBL+RELCHN,R0
	TST	(R0)+		;IGNORE FIRST WORD
	CMP	RLDPNT,R0	;ANYTHING IN RLD?
	BLOS	OBJINI		;  NO, JUST INIT
				;ELSE FINISH IN RLD DUMP ROUTINE
RLDDMP::			;REF LABEL
	.IF NDF	XEDABS
	BIT	#ED.ABS,EDMASK	;ABS OUTPUT?
	BEQ	OBJINI		;  YES, NO RLD
	.ENDC
	MOV	RLDPNT,@CNTTBL+RELCHN
	SUB	BUFTBL+RELCHN,@CNTTBL+RELCHN	;COMPUTE BYTE COUNT
	$WRITE	REL		;ELSE, WRITE OUT RLD BUFFER
	.IFTF

OBJINI::MOV	BUFTBL+BINCHN,OBJPNT;SET BUFFER POINTER
	.IFT
	MOV	BUFTBL+RELCHN,RLDPNT
	ADD	#2,RLDPNT	;RESERVE WORD FOR BLOCK TYPE
	.IFTF
OBJINX:	RETURN
	.ENDC			;Impure data moved to RSDAT module	;JR01

	.END
